<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Cloud</title>
    <link href="/posts/springcloud-v1/"/>
    <url>/posts/springcloud-v1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>分布式网络并不可靠，微服务架构存在4个核心问题：</p><ol><li><p>服务很多，客户端该怎么访问?</p></li><li><p>这么多服务，服务之间如何通信？</p></li><li><p>这么多服务，如何治理？</p></li><li><p>服务挂了怎么办?</p></li></ol><p>解决方案：Spring Cloud生态：</p><ol><li>Spring Cloud NetFlix，一站式解决方案，已停止维护。<ul><li>API网关，zuul组件</li><li>Feign，HttpClient ，Http通信方式，同步、阻塞</li><li>服务注册发现：Eureka</li><li>熔断机制：Hystrix</li><li>…</li></ul></li><li>Spring Dubbo Zookeeper，半自动。<ul><li>无API，借助别人的，或者自己实现。</li><li>Dubbo</li><li>Zookeeper</li><li>无熔断，借助别人的</li></ul></li><li>Spring Cloud Alibaba，一站式解决方案，更简单</li></ol><p>新概念：服务网格~ Server Mesh</p><ul><li>istio</li></ul><p>总的体系：</p><ol><li>API网关：解决服务路由问题。</li><li>HTTP\RPC：解决通信问题。</li><li>注册和发现：解决高可用问题。</li><li>熔断机制：解决服务降级问题。</li></ol><p><img src="https://i.loli.net/2020/08/08/UNmhwAD42YMqcSW.png" srcset="/img/loading.gif" alt="" /></p><p><img src="https://i.loli.net/2020/08/08/lejrV5cJPp29ikq.png" srcset="/img/loading.gif" alt="" /></p><p>以下技术如今大部分都出现了替代品。</p><p><img src="https://i.loli.net/2020/08/08/4J8gFikxe6mpXRt.png" srcset="/img/loading.gif" alt="" /></p><p>截止2020.08.08，springcloud官网推荐版本选择。或者点击相关springcloud版本查看推荐的springcloud版本。</p><table><thead><tr><th style="text-align:center">Hoxton</th><th>2.2.x, 2.3.x (Starting with SR5)</th></tr></thead><tbody><tr><td style="text-align:center">Greenwich</td><td>2.1.x</td></tr><tr><td style="text-align:center">Finchley</td><td>2.0.x</td></tr><tr><td style="text-align:center">Edgware</td><td>1.5.x</td></tr><tr><td style="text-align:center">Dalston</td><td>1.5.x</td></tr></tbody></table><a class="btn" href="https://start.spring.io/actuator/info"  target="_blank">技术选型</a><p><img src="https://i.loli.net/2020/08/08/RJzYQ5h7K4m8obr.png" srcset="/img/loading.gif" alt="" /></p><h2 id="一-父工程建立"><a class="markdownIt-Anchor" href="#一-父工程建立"></a> 一、父工程建立</h2><ol><li>字符编码；</li><li>注解生效激活；</li><li>java编译版本选择；</li><li>File type过滤。</li></ol><h2 id="二-服务注册中心"><a class="markdownIt-Anchor" href="#二-服务注册中心"></a> 二、服务注册中心</h2><h3 id="1-eureka"><a class="markdownIt-Anchor" href="#1-eureka"></a> 1. Eureka</h3><p>Server端集群：互相注册，相互守望。</p><p>自我保护机制：CAP中的AP。</p><h3 id="2zookeeper"><a class="markdownIt-Anchor" href="#2zookeeper"></a> 2.Zookeeper</h3><h3 id="3consul"><a class="markdownIt-Anchor" href="#3consul"></a> 3.Consul</h3><p><code>consul agent -dev</code></p><h3 id="4异同点"><a class="markdownIt-Anchor" href="#4异同点"></a> 4.异同点</h3><table><thead><tr><th style="text-align:center">组件名</th><th style="text-align:center">语言</th><th style="text-align:center">CAP</th><th style="text-align:center">服务健康检查</th><th style="text-align:center">对外暴露接口</th><th style="text-align:center">Spring Cloud集成</th></tr></thead><tbody><tr><td style="text-align:center">Eureka</td><td style="text-align:center">Java</td><td style="text-align:center">AP</td><td style="text-align:center">可配支持</td><td style="text-align:center">HTTP</td><td style="text-align:center">已集成</td></tr><tr><td style="text-align:center">Zookeeper</td><td style="text-align:center">Java</td><td style="text-align:center">CP</td><td style="text-align:center">支持</td><td style="text-align:center">HTTP/DNS</td><td style="text-align:center">已集成</td></tr><tr><td style="text-align:center">Consul</td><td style="text-align:center">Go</td><td style="text-align:center">CP</td><td style="text-align:center">支持</td><td style="text-align:center">客户端</td><td style="text-align:center">已集成</td></tr></tbody></table><h2 id="三-服务调用"><a class="markdownIt-Anchor" href="#三-服务调用"></a> 三、服务调用</h2><h3 id="1ribbon"><a class="markdownIt-Anchor" href="#1ribbon"></a> 1.Ribbon</h3><h4 id="ribbon核心组件irule"><a class="markdownIt-Anchor" href="#ribbon核心组件irule"></a> Ribbon核心组件IRule</h4><p>抽象类AbstractLoadBalancerRule。</p><p>在主启动类@ComponentScan范围外建立配置类，并在主启动类上添加@RibbonClient(name=“服务名”, configuration= xxxx.class)</p><p><img src="https://i.loli.net/2020/08/09/KPED3r1FiO5fxYU.png" srcset="/img/loading.gif" alt="" /></p><div class="hljs"><pre><code class="hljs JAVA">RestTemplate restTemplate;restTemplate.getForObject ----&gt;  返回jsonrestTemplate.getForEntity ----&gt;  返回ResponsrEntity。包括.getStatusCode().is2xxSuccessful()  .getBody()</code></pre></div><h4 id="轮询负载均衡算法"><a class="markdownIt-Anchor" href="#轮询负载均衡算法"></a> 轮询负载均衡算法</h4><p>自加一再求余数，获得ServicesInstances的索引。</p><h5 id="cas"><a class="markdownIt-Anchor" href="#cas"></a> CAS</h5><p>CAS（CompareAndSet）：比较并交换。</p><ol><li><p>自旋锁</p></li><li><p>Unsafe</p></li></ol><h4 id="手写负载均衡算法"><a class="markdownIt-Anchor" href="#手写负载均衡算法"></a> 手写负载均衡算法</h4><p>以下代码在有两个Eureka客户端时，访问0号客户端两次，访问1号客户端一次，需要去掉@LoadBalanced注解。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rooftopj.mylb.impl;<span class="hljs-keyword">import</span> com.rooftopj.mylb.LoadBalance;<span class="hljs-keyword">import</span> org.springframework.cloud.client.ServiceInstance;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalanceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>&#123;    <span class="hljs-keyword">private</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">int</span> cur;        <span class="hljs-keyword">int</span> next;                <span class="hljs-comment">// 自旋锁</span>        <span class="hljs-keyword">do</span>&#123;            cur = <span class="hljs-keyword">this</span>.atomicInteger.get();            next = cur &gt;= <span class="hljs-number">2147483647</span> ? <span class="hljs-number">0</span> : cur + <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">while</span>(!atomicInteger.compareAndSet(cur,next));                System.out.println(<span class="hljs-keyword">this</span>.atomicInteger.get());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.atomicInteger.get();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServiceInstance <span class="hljs-title">get</span><span class="hljs-params">(List&lt;ServiceInstance&gt; lists)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = getNum() % (lists.size() + <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> index;        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || i == <span class="hljs-number">1</span>)&#123;            index = <span class="hljs-number">0</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            index = <span class="hljs-number">1</span>;        &#125;        System.out.println(<span class="hljs-string">"index:"</span> + index);        <span class="hljs-keyword">return</span> lists.get(index);    &#125;&#125;</code></pre></div><h3 id="2openfeign"><a class="markdownIt-Anchor" href="#2openfeign"></a> 2.OpenFeign</h3><p>在之前的操作中，消费者端我们采用的是Ribbon+RestTemplate的方式，而使用OpenFeign也是另一种可行方式。使用接口+注解@FeignClient方式，入口类也需加上注解@EnableFeignClients。</p><p>OpenFeign默认超时限制为1s，可以修改</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">5000</span>  <span class="hljs-comment">#建立连接的时间</span><span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">5000</span><span class="hljs-comment">#从服务器读取可用资源所用时间</span></code></pre></div><p>OpenFeign日志</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-comment"># feign日志以什么级别监控哪个接口</span>    <span class="hljs-string">全限定类名:</span> <span class="hljs-string">debug</span></code></pre></div><h2 id="四-服务降级"><a class="markdownIt-Anchor" href="#四-服务降级"></a> 四、服务降级</h2><h3 id="1hystrix"><a class="markdownIt-Anchor" href="#1hystrix"></a> 1.Hystrix</h3><p>fallback：服务降级。系统不可用时，需要一个预期的，可处理的备选响应，而不是长时间的等待或者抛出调用方无法处理的异常。如：服务器忙，请稍后再试。</p><p>哪些情况下会发生降级：</p><ol><li>程序运行异常；</li><li>超时；</li><li>服务熔断触发降级；</li><li>线程池、信号量打满。</li></ol><p>break：服务熔断。达到最大访问后，直接拒绝访问，然后调用服务降级返回友好提示。当微服务调用响应正常后，恢复调用链路。</p><p>在滚动时间窗内，当错误率高于设定值且请求次数高于设定值，熔断。直接降级。之后过一段时间，休眠时间窗，默认5秒，进入半开半闭状态，若能够正常处理请求，则恢复，否则，熔断，再等待5秒后循环以上判断过程。</p><p>flowlimit：服务限流。秒杀等高并发操作，过于拥挤后需要排队。</p><h2 id="五-api网关"><a class="markdownIt-Anchor" href="#五-api网关"></a> 五、API网关</h2><h3 id="1gateway"><a class="markdownIt-Anchor" href="#1gateway"></a> 1.gateway</h3><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">ch07-gateway</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">gateway:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">locator:</span>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>      <span class="hljs-attr">routes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">the_first</span>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://ch01-provider</span>          <span class="hljs-attr">predicates:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/provider/get/**</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">After=2020-08-10T11:51:37.485+08:00[Asia/Shanghai]</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2020-08-10T11:51:37.485+08:00[Asia/Shanghai]</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Between=2020-08-10T11:51:37.485+08:00[Asia/Shanghai],</span> <span class="hljs-number">2020</span><span class="hljs-number">-08</span><span class="hljs-string">-10T12:51:37.485+08:00[Asia/Shanghai]</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Cookie=username,zzyy</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Header=X-Request-Id,\d+</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Host=**.somehost.org,**.anotherhost.org</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Method=GET,POST</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Query=green</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">RemoteAddr=192.168.1.1/24</span> <span class="hljs-comment">#IPV4 IPV6</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">Weight=group1,</span> <span class="hljs-number">2</span> <span class="hljs-comment">#同一个组可以分权重</span>          <span class="hljs-attr">filters:</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=red,</span> <span class="hljs-string">blue</span></code></pre></div><h2 id="六-配置中心"><a class="markdownIt-Anchor" href="#六-配置中心"></a> 六、配置中心</h2><h3 id="1spring-cloud-config"><a class="markdownIt-Anchor" href="#1spring-cloud-config"></a> 1.Spring Cloud Config</h3><p><code>curl -X POST &quot;http://localhost:3355/actuator/refresh&quot;</code></p><h3 id="2spring-cloud-bus消息总线"><a class="markdownIt-Anchor" href="#2spring-cloud-bus消息总线"></a> 2.Spring Cloud Bus消息总线</h3><p>自动化动态刷新、差异化动态刷新。</p><ol><li>利用消息总线触发一个客户端/bus/refresh，从而刷新所有客户端配置；</li><li>利用消息总线触发一个服务端/bus/refresh，从而刷新所有客户端配置。（更合理）</li></ol><p>刷新所有客户端，先触发服务端：</p><p><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh&quot;</code></p><p>刷新指定客户端：</p><p><code>curl -X POST &quot;http://localhost:3344/actuator/bus-refresh/config-client:3355&quot;</code></p><h2 id="七-spring-cloud-stream"><a class="markdownIt-Anchor" href="#七-spring-cloud-stream"></a> 七、Spring Cloud Stream</h2><p>屏蔽底层消息中间件差异。</p><p><img src="https://i.loli.net/2020/08/10/PVLOc69RK27qTMD.png" srcset="/img/loading.gif" alt="" /></p><ol><li>避免重复消费</li></ol><p>不同的组会重复消费，相同的组是竞争消费。</p><ol start="2"><li>分组</li><li>持久化，加group</li></ol><h2 id="八-spring-cloud-sleuth"><a class="markdownIt-Anchor" href="#八-spring-cloud-sleuth"></a> 八、Spring Cloud Sleuth</h2><p>微服务跟踪(sleuth)其实是一个工具,它在整个分布式系统中能跟踪一个用户请求的过程(包括数据采集，数据传输，数据存储，数据分析，数据可视化)，捕获这些跟踪数据，就能构建微服务的整个调用链的视图，这是调试和监控微服务的关键工具。Spring Cloud Sleuth提供了分布式追踪(distributed tracing)的一个解决方案。其基本思路是在服务调用的请求和响应中加入ID，标明上下游请求的关系。利用这些信息，可以方便地分析服务调用链路和服务间的依赖关系。</p><p><img src="https://i.loli.net/2020/08/10/eo8Ams9ujDqyVcB.png" srcset="/img/loading.gif" alt="" /></p><h2 id="九-spring-cloud-alibaba"><a class="markdownIt-Anchor" href="#九-spring-cloud-alibaba"></a> 九、Spring Cloud Alibaba</h2><h3 id="1nacos"><a class="markdownIt-Anchor" href="#1nacos"></a> 1.Nacos</h3><h4 id="1注册中心"><a class="markdownIt-Anchor" href="#1注册中心"></a> 1.注册中心</h4><p>Nacos可在AP模式和CP模式间切换。</p><h4 id="2配置中心"><a class="markdownIt-Anchor" href="#2配置中心"></a> 2.配置中心</h4><p><code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code></p><p>Namespace + Group + DataID。</p><p>Namespace区分部署环境，如开发、测试、生产。</p><p>Group可以将不同的微服务划分到同一个分组中。</p><h4 id="3集群"><a class="markdownIt-Anchor" href="#3集群"></a> 3.集群</h4><p>为保证数据一致性，需要使用MySql数据库替代内置Derby数据库。</p><p><img src="https://i.loli.net/2020/08/11/R7w9DyxKa8NImSh.png" srcset="/img/loading.gif" alt="" /></p><h3 id="2sentinel"><a class="markdownIt-Anchor" href="#2sentinel"></a> 2.Sentinel</h3><p>临时存储。可配置持久化。</p><h4 id="1流控规则"><a class="markdownIt-Anchor" href="#1流控规则"></a> 1.流控规则</h4><ul><li>阈值类型</li><li><ul><li>QPS：每秒请求数量。</li></ul></li><li><ul><li>线程数：正在处理的请求个数。</li></ul></li></ul><hr /><ul><li><p>流控模式</p></li><li><ul><li>直接：默认。</li></ul></li><li><ul><li>关联：与A关联的资源B达到阈值后，就限流A自己。（如支付限流后也限流下订单的接口）</li></ul></li><li><ul><li>链路：链路前面的资源被限流后，后面的资源也会被限流。</li></ul></li></ul><hr /><ul><li><p>流控效果</p></li><li><ul><li>直接，快速失败</li></ul></li><li><ul><li>Warm Up预热，冷加载因子coldFactor，默认为3。初始值为阈值 / 冷加载因子，经过预热时间后升至阈值。</li></ul></li><li><ul><li>排队等待，平均有序处理超过阈值的请求。</li></ul></li></ul><h4 id="2降级规则"><a class="markdownIt-Anchor" href="#2降级规则"></a> 2.降级规则</h4><p>降级后就熔断，没有半开半闭状态。</p><ul><li>RT(平均响应时间，秒级)</li></ul><p>平均响应时间均超出阈值且QPS&gt;=5，触发降级，熔断。在接下来的时间窗口内，对这个方法的调用都会抛出<code>DegradeException</code>异常，时间窗口结束后，关闭降级。</p><ul><li>异常比例（秒级）</li></ul><p>异常比例（秒级统计）超过阈值且QPS&gt;=5，触发降级。在接下来的时间窗口内，对这个方法的调用都会自动返回。时间窗口结束后，关闭降级。</p><ul><li>异常数（分钟级）</li></ul><p>异常数（分钟统计）超过阈值，触发降级，熔断。时间窗口大于60s，时间窗口结束后，关闭降级。</p><h4 id="3热点规则"><a class="markdownIt-Anchor" href="#3热点规则"></a> 3.热点规则</h4><p>普通：通过参数索引根据是否存在某个请求参数做流控。</p><p>高级：对于例外情况，根据某个请求参数的值是否为设定值做例外设定流控。只支持基本数据类型和String。</p><p><code>@SentinelResource(value=&quot;唯一即可，配置中填该名字&quot;, blockHandler=&quot;fallback方法名&quot;)</code>处理的是java控制台配置的违规情况。而对于RuntimeException不管。</p><h4 id="4系统规则"><a class="markdownIt-Anchor" href="#4系统规则"></a> 4.系统规则</h4><p>对整个网站入口进行流控。</p><ul><li><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 <code>maxQps * minRt</code> 估算得出。设定参考值一般是 <code>CPU cores * 2.5</code>。</li><li><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</li><li><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</li><li><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li><li><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</li></ul><h4 id="5sentinelresource"><a class="markdownIt-Anchor" href="#5sentinelresource"></a> 5.@SentinelResource</h4><p>Sentinel主要有三个核心API：1.SphU定义资源；2.Tracer定义统计；3.ContextUtil定义上下文。</p><p>解耦，自定义fallback类，不支持private方法，写静态方法。<code>@SentinelResource(value=&quot;唯一即可，配置中填该名字&quot;, blockHandlerClass=自定义fallback类.class,blockHandler=&quot;fallback方法名&quot;)</code></p><hr /><p>程序自身运行异常。<code>@SentinelResource(value=&quot;唯一即可，配置中填该名字&quot;, fallback=&quot;xxx&quot;)</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 一个要注意的，这里我用Exception作为形参类型没有捕捉到该fallback方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fallback</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Integer id, Throwable e)</span></code></pre></div><hr /><p>总的来说，blockHandler只管理配置设定的规则，fallback只负责程序自身运行异常。若抛出blockException异常，优先由blockHandler处理。</p><hr /><p>exceptionsToIgnore忽略特定异常：<code>@SentinelResource(value=&quot;唯一即可，配置中填该名字&quot;, fallback=&quot;xxx&quot;, exceptionsToIgnore={IllegalArgumentException.class})</code>。</p><h4 id="6规则持久化"><a class="markdownIt-Anchor" href="#6规则持久化"></a> 6.规则持久化</h4><p>可以持久化进Nacos中保存规则。</p><div class="hljs"><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">"resource"</span>: <span class="hljs-string">"getRibbon"</span>,        <span class="hljs-attr">"limitApp"</span>: <span class="hljs-string">"default"</span>,        <span class="hljs-attr">"grade"</span>: <span class="hljs-number">1</span>,        <span class="hljs-attr">"count"</span>: <span class="hljs-number">2</span>,        <span class="hljs-attr">"strategy"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"controlBehavior"</span>: <span class="hljs-number">0</span>,        <span class="hljs-attr">"clusterMode"</span>: <span class="hljs-literal">false</span>    &#125;]resources:资源名称limitApp:来源应用grade:阈值类型，0表示线程数，1表示QPScount:单机阈值strategy:流控模式，0表示直接，1表示关联，2表示链路controlBehavior:流控效果，0表示快速失败，1表示Warm Up，2表示排队等待clusterMode:是否集群</code></pre></div><h3 id="3seata"><a class="markdownIt-Anchor" href="#3seata"></a> 3.Seata</h3><p>支持AT、TCC、SAGA、XA模式。</p><h4 id="1分布式事务"><a class="markdownIt-Anchor" href="#1分布式事务"></a> 1.分布式事务</h4><p>多服务，多表，保证全局数据一致性。</p><p>分布式事务处理的一ID+三组件模型：</p><ol><li>全局唯一的事务ID；</li><li>TC-事务协调器</li><li>TM-事务管理器</li><li>RM-资源管理器</li></ol><p><img src="https://i.loli.net/2020/08/11/dWMsKePbkFp4oDz.png" srcset="/img/loading.gif" alt="" /></p><p>TM开启分布式事务（TM向TC注册全局事务记录）；</p><p>按业务场景，编排数据库、服务等事务内资源（RM向TC汇报资源状态）；</p><p>TM结束分布式事务，事务一阶段结束（TM通知TC提交/回滚分布式事务）；</p><p>TC汇总事务信息，决定分布式事务是提交还是回滚；</p><p>TC通知所有RM提交/回滚资源，事务二阶段结束。</p><hr /><p><strong>一阶段加载</strong></p><p><img src="https://i.loli.net/2020/08/11/lX5rPMbu7RwLcjO.png" srcset="/img/loading.gif" alt="" /></p><hr /><p><strong>二阶段提交</strong></p><p><img src="https://i.loli.net/2020/08/11/gJzGbncati6uySX.png" srcset="/img/loading.gif" alt="" /></p><hr /><p><strong>二阶段回滚</strong></p><p><img src="https://i.loli.net/2020/08/11/gpLVEPDqRhkuUBF.png" srcset="/img/loading.gif" alt="" /></p><h4 id="2实战"><a class="markdownIt-Anchor" href="#2实战"></a> 2.实战</h4><p><code>Seata1.3.0</code>最新版（截止2020.08.11），弄了好久才跑出来。Seata + Nacos + Sentinel + OpenFeign：下订单 -&gt; 减库存 -&gt; 减余额 -&gt; 记录订单，发生异常时返回友好界面且回滚保证数据一致性。</p><ul><li>新建seata数据库，建立如下三个表：</li></ul><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- -------------------------------- The script used when storeMode is 'db' --------------------------------</span><span class="hljs-comment">-- the table to store GlobalSession data</span><span class="hljs-comment">#分支事务表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`global_table`</span>(    <span class="hljs-string">`xid`</span>                       <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`transaction_id`</span>            <span class="hljs-built_in">BIGINT</span>,    <span class="hljs-string">`status`</span>                    <span class="hljs-built_in">TINYINT</span>      <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`application_id`</span>            <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">32</span>),    <span class="hljs-string">`transaction_service_group`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">32</span>),    <span class="hljs-string">`transaction_name`</span>          <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>),    <span class="hljs-string">`timeout`</span>                   <span class="hljs-built_in">INT</span>,    <span class="hljs-string">`begin_time`</span>                <span class="hljs-built_in">BIGINT</span>,    <span class="hljs-string">`application_data`</span>          <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2000</span>),    <span class="hljs-string">`gmt_create`</span>                DATETIME,    <span class="hljs-string">`gmt_modified`</span>              DATETIME,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`xid`</span>),    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_gmt_modified_status`</span> (<span class="hljs-string">`gmt_modified`</span>, <span class="hljs-string">`status`</span>),    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_transaction_id`</span> (<span class="hljs-string">`transaction_id`</span>)) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8;<span class="hljs-comment">-- the table to store BranchSession data</span><span class="hljs-comment">#全局事务表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`branch_table`</span>(    <span class="hljs-string">`branch_id`</span>         <span class="hljs-built_in">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`xid`</span>               <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`transaction_id`</span>    <span class="hljs-built_in">BIGINT</span>,    <span class="hljs-string">`resource_group_id`</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">32</span>),    <span class="hljs-string">`resource_id`</span>       <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">256</span>),    <span class="hljs-string">`branch_type`</span>       <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">8</span>),    <span class="hljs-string">`status`</span>            <span class="hljs-built_in">TINYINT</span>,    <span class="hljs-string">`client_id`</span>         <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">64</span>),    <span class="hljs-string">`application_data`</span>  <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">2000</span>),    <span class="hljs-string">`gmt_create`</span>        DATETIME(<span class="hljs-number">6</span>),    <span class="hljs-string">`gmt_modified`</span>      DATETIME(<span class="hljs-number">6</span>),    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`branch_id`</span>),    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_xid`</span> (<span class="hljs-string">`xid`</span>)) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8;<span class="hljs-comment">-- the table to store lock data</span><span class="hljs-comment">#全局锁</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`lock_table`</span>(    <span class="hljs-string">`row_key`</span>        <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`xid`</span>            <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">96</span>),    <span class="hljs-string">`transaction_id`</span> <span class="hljs-built_in">BIGINT</span>,    <span class="hljs-string">`branch_id`</span>      <span class="hljs-built_in">BIGINT</span>       <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    <span class="hljs-string">`resource_id`</span>    <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">256</span>),    <span class="hljs-string">`table_name`</span>     <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">32</span>),    <span class="hljs-string">`pk`</span>             <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">36</span>),    <span class="hljs-string">`gmt_create`</span>     DATETIME,    <span class="hljs-string">`gmt_modified`</span>   DATETIME,    PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`row_key`</span>),    <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_branch_id`</span> (<span class="hljs-string">`branch_id`</span>)) <span class="hljs-keyword">ENGINE</span> = <span class="hljs-keyword">InnoDB</span>  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span> = utf8;</code></pre></div><ul><li>在每个表中都需要建下表：</li></ul><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 注意此处1.3.0+ 增加唯一索引 ux_undo_log</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`undo_log`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`branch_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`xid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`context`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`rollback_info`</span> longblob <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`log_status`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`log_created`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`log_modified`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`ext`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`ux_undo_log`</span> (<span class="hljs-string">`xid`</span>,<span class="hljs-string">`branch_id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre></div><p>配置文件：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8881</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">seata-order-service</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">sentinel:</span>      <span class="hljs-attr">transport:</span>        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8080</span>        <span class="hljs-attr">port:</span> <span class="hljs-number">8719</span>    <span class="hljs-attr">alibaba:</span>      <span class="hljs-attr">seata:</span>        <span class="hljs-comment">#自定义事务组名称需要与seata-server中的对应</span>        <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">my_test_tx_group</span>    <span class="hljs-attr">nacos:</span>      <span class="hljs-attr">discovery:</span>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">localhost:8848</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/seata_order?serverTimezone=Asia/Shanghai</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">xxxxxxx</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">mapperLocations:</span> <span class="hljs-string">classpath:mapper/*.xml</span></code></pre></div><ul><li>数据源，需要在入口类中去掉自带数据源：</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.rooftopj.config;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<span class="hljs-keyword">import</span> io.seata.rm.datasource.DataSourceProxy;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;<span class="hljs-keyword">import</span> org.mybatis.spring.transaction.SpringManagedTransactionFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 使用Seata对数据源进行代理</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDataSource</span> </span>&#123;    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;mybatis.mapperLocations&#125;"</span>)    <span class="hljs-keyword">private</span> String mapperLocations;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProxy <span class="hljs-title">dataSourceProxy</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactoryBean</span><span class="hljs-params">(DataSourceProxy dataSourceProxy)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();        sqlSessionFactoryBean.setDataSource(dataSourceProxy);        sqlSessionFactoryBean.setMapperLocations(<span class="hljs-keyword">new</span> PathMatchingResourcePatternResolver().getResources(mapperLocations));        sqlSessionFactoryBean.setTransactionFactory(<span class="hljs-keyword">new</span> SpringManagedTransactionFactory());        <span class="hljs-keyword">return</span> sqlSessionFactoryBean.getObject();    &#125;&#125;</code></pre></div><ul><li>后面只需要正常按逻辑业务进行即可，在方法上加@GlobalTransactional。</li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/posts/rabbitmq-v1/"/>
    <url>/posts/rabbitmq-v1/</url>
    
    <content type="html"><![CDATA[<h2 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq"></a> RabbitMQ</h2><a class="btn" href="https://www.rabbitmq.com/"  target="_blank">RabbitMQ官网</a><h3 id="mq三大主要功能"><a class="markdownIt-Anchor" href="#mq三大主要功能"></a> MQ三大主要功能</h3><ul><li>解耦</li><li>异步</li><li>削峰</li></ul><h3 id="rabbitmq特点"><a class="markdownIt-Anchor" href="#rabbitmq特点"></a> RabbitMQ特点</h3><ol><li>RabbitMQ是由<code>Erlang</code>语言开发的AMQP的开源实现。</li><li>支持主流的操作系统：Linux、Window、MacOS。</li><li>多种开发语言支持：Java、Python、Ruby、PHP、C#、node.js等。</li></ol><p>…</p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>Erlang：<code>rpm -ivh esl-erlang_21.3.8.17-1_centos_7_amd64.rpm</code>，若报错，则执行下面两条命令后再进行安装：<code>sudo yum install epel-release</code>和<code>sudo yum install unixODBC unixODBC-devel wxBase wxGTK SDL wxGTK-gl</code></p><p>socat：<code>wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</code>和<code>yum -y install socat</code></p><p>RabbitMQ：<code>rpm -ivh rabbitmq-server-3.8.6-1.el7.noarch.rpm</code></p><p>启用管理插件：<code>rabbitmq-plugins enable rabbitmq_management</code></p><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p><code>systemctl start rabbitmq-server.service</code><br/></p><p><code>systemctl status rabbitmq-server.service</code><br/></p><p><code>systemctl restart rabbitmq-server.service</code><br/></p><p><code>systemctl stop rabbitmq-server.service</code><br/></p><p>添加管理员账号密码：<code>rabbitmqctl add_user admin admin</code></p><p>分配账号角色：<code>rabbitmqctl set_user_tags admin administrator</code></p><p>修改密码：<code>rabbitmqctl change_password admin 123456</code></p><p>查看用户列表：<code>rabbitmqctl list_users</code></p><h2 id="五种消息模型"><a class="markdownIt-Anchor" href="#五种消息模型"></a> 五种消息模型</h2><h3 id="1基本消息模型"><a class="markdownIt-Anchor" href="#1基本消息模型"></a> 1.基本消息模型</h3><p>点对点。</p><p><img src="https://i.loli.net/2020/08/10/fOFg5kZv96BxyUo.png" srcset="/img/loading.gif" alt="" /></p><h3 id="2work消息模型"><a class="markdownIt-Anchor" href="#2work消息模型"></a> 2.Work消息模型</h3><p>点对点。解决消息积压问题。能者多劳。</p><p><img src="https://i.loli.net/2020/08/11/moY8UlXBtPgdvGy.png" srcset="/img/loading.gif" alt="" /></p><h3 id="3发布-订阅-fanout"><a class="markdownIt-Anchor" href="#3发布-订阅-fanout"></a> 3.发布、订阅-Fanout</h3><p>路由器，不存储消息：direct、fanout、head、topic。</p><p><img src="https://i.loli.net/2020/08/10/iCQLVc5PUjdBE1s.png" srcset="/img/loading.gif" alt="" /></p><h3 id="4发布-订阅-direct"><a class="markdownIt-Anchor" href="#4发布-订阅-direct"></a> 4.发布、订阅-Direct</h3><p>需要交换机和队列的主题相匹配，队列才能收到对应消息。</p><p><img src="https://i.loli.net/2020/08/10/g3FnferNtCST1Q5.png" srcset="/img/loading.gif" alt="" /></p><h3 id="5发布-订阅-topic"><a class="markdownIt-Anchor" href="#5发布-订阅-topic"></a> 5.发布、订阅-Topic</h3><p><code>*</code>：一个词；</p><p><code>#</code>：零个或者多个词。</p><p><img src="https://i.loli.net/2020/08/10/YlMsSco6WQAL7PU.png" srcset="/img/loading.gif" alt="" /></p><h2 id="持久化"><a class="markdownIt-Anchor" href="#持久化"></a> 持久化</h2><p>消息、队列、交换机持久化，能避免数据丢失（如MQ宕机）。消费者的ACK机制也能避免数据丢失。</p><h2 id="spring-amqp"><a class="markdownIt-Anchor" href="#spring-amqp"></a> Spring AMQP</h2>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode成长之旅</title>
    <link href="/posts/leetcode-2020-08/"/>
    <url>/posts/leetcode-2020-08/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>本专栏记录<code>leetcode</code>Java题解。</p><a class="btn" href="https://leetcode-cn.com/problemset/all/"  target="_blank">leetcode题库</a><h2 id="题号1两数之和"><a class="markdownIt-Anchor" href="#题号1两数之和"></a> 题号1：两数之和</h2><div class="note note-danger">            <p>题号：<code>1</code>，难度：<code>简单</code><br></p><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><a class="btn" href="https://leetcode-cn.com/problems/two-sum/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>第一种思路：暴力解法，时间复杂度O(n^2)；</li><li>第二种思路：以空间换时间，将每个数值存入hash表的key中，将该数值在数组中的索引存入hash表的value中。每循环到一个数字，通过用targete减去该数字，在hash表中寻找是否有该key来判断是否找到结果了。要注意的是，先进行判断，将本次的数字存入hash表中，这样可以避免使用同一个元素两遍，而且如果有两个及以上的相同数字，该结构也能够得到解。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);        &#125;        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">int</span> temp = target - nums[i];            <span class="hljs-keyword">if</span>(map.containsKey(temp))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;map.get(temp), i&#125;;            &#125;            map.put(nums[i],i);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"未找到目标数字！"</span>);    &#125;&#125;</code></pre></div><h2 id="题号2两数相加"><a class="markdownIt-Anchor" href="#题号2两数相加"></a> 题号2：两数相加</h2><div class="note note-danger">            <p>题号：<code>2</code>，难度：<code>中等</code><br></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><div class="hljs"><pre><code class="hljs angelscript">输入：(<span class="hljs-number">2</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">3</span>) + (<span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">4</span>)输出：<span class="hljs-number">7</span> -&gt; <span class="hljs-number">0</span> -&gt; <span class="hljs-number">8</span>原因：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/add-two-numbers/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>直接顺着向前加即可，保留进位，一条链表走到头后不再继续让这条链表向前走。走出循环后，还得判断最后一位是否发生了进位。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode cur = head;        <span class="hljs-keyword">int</span> higher = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">int</span> temp1 = (l1 != <span class="hljs-keyword">null</span>) ? l1.val : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> temp2 = (l2 != <span class="hljs-keyword">null</span>) ? l2.val : <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> sum = temp1 + temp2 + higher;            higher = sum / <span class="hljs-number">10</span>;            cur.next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);            cur = cur.next;            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-keyword">null</span>)  l1 = l1.next;            <span class="hljs-keyword">if</span>(l2 != <span class="hljs-keyword">null</span>)  l2 = l2.next;        &#125;        <span class="hljs-keyword">if</span>(higher != <span class="hljs-number">0</span>)&#123;            cur.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> head.next;    &#125;&#125;</code></pre></div><h2 id="题号3无重复字符的最长子串"><a class="markdownIt-Anchor" href="#题号3无重复字符的最长子串"></a> 题号3：无重复字符的最长子串</h2><div class="note note-danger">            <p>题号：<code>3</code>，难度：<code>中等</code><br></p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><div class="hljs"><pre><code class="hljs makefile"><span class="hljs-section">输入: "abcabcbb"</span><span class="hljs-section">输出: 3 </span><span class="hljs-section">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><span class="hljs-section">输入: "bbbbb"</span><span class="hljs-section">输出: 1</span><span class="hljs-section">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span><span class="hljs-section">输入: "pwwkew"</span><span class="hljs-section">输出: 3</span><span class="hljs-section">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">"pwke"</span> 是一个子序列，不是子串。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>剑指offer原题。</p><ol><li>动态规划，dp[i] 表示以索引为 i 元素结尾的字串能够有的最长字串。初始化 dp[0] = 1。向后遍历，更新规律：若之前出现过本次的字符，且在本次所涉及的最长字串中，需要裁剪子串；反之，则自加一。</li><li>滑动窗口，思想类似动态规划，遇到重复字符且在当前最长字串中，需要重新展开窗口。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> dp = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;        Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        map.put(s.charAt(<span class="hljs-number">0</span>),<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)) &amp;&amp; (i - map.get(s.charAt(i))) &lt;= dp)&#123;                max = (max &gt; dp) ? max : dp;                dp = i - map.get(s.charAt(i));            &#125;<span class="hljs-keyword">else</span>&#123;                dp++;            &#125;            map.put(s.charAt(i),i);        &#125;        <span class="hljs-keyword">return</span> max &gt; dp ? max : dp;    &#125;&#125;</code></pre></div><h2 id="题号4寻找两个正序数组的中位数"><a class="markdownIt-Anchor" href="#题号4寻找两个正序数组的中位数"></a> 题号4：寻找两个正序数组的中位数</h2><div class="note note-danger">            <p>题号：<code>4</code>，难度：<code>困难</code><br></p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><div class="hljs"><pre><code class="hljs angelscript">nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]nums2 = [<span class="hljs-number">2</span>]则中位数是 <span class="hljs-number">2.0</span>nums1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]nums2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]则中位数是 (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>)/<span class="hljs-number">2</span> = <span class="hljs-number">2.5</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>首先，设定二分法最后得到的索引为 i ：若数组长度N为奇数，则 i = (N+1) / 2，若数组长度N为偶数，则 i = (N) / 2，而又由于偶数和int除法的性质，数组长度N为偶数，也可以为 i = (N+1) / 2。</p><ol><li>将两个数组整体进行二分法查找，我们将数组长度较短的数组称为一号数组，i 为一号数组最后找到的索引位置，j 对应为二号数组最后找到的索引位置。若两个数组的长度和为奇数，则最后输出结果应该是左半部分中最大的那个元素；若为偶数，则为左半部分最大的、右半部分最小的元素的平均数。</li></ol><p><img src="https://i.loli.net/2020/08/07/hmvICqfJ38oX6Ow.png" srcset="/img/loading.gif" alt="" /></p><ol start="2"><li>一些特殊情况，长度较小的数组，可能整体都被囊括进了左边、或者右边。</li><li>注意二分法的特点，例如当while条件为<code>left &lt; right</code>时，中位点 i 为<code>(left+right)/2</code>，右边更新条件为<code>right = i - 1</code>，左边更新条件为<code>left = i</code>，当出现<code>left = 1,right=2</code>，而更新条件为<code>left = i</code>，就会陷入死循环。同时本题代码中循环内出现<code>nums1[i - 1]</code>，还有可能索引为 -1 溢出。因此，我们应该将中位点设置在偏右位置。</li><li>二分法判断条件，第一个数组中左边最大的元素应该不大于第二个数组中右边最小的元素；第二个数组中左边最大的元素应该不大于第二个数组中右边最小的元素。若违反，则需要更新。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums1.length &lt; nums2.length)&#123;            <span class="hljs-keyword">return</span> find(nums1, nums2);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> find(nums2, nums1);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span></span>&#123; <span class="hljs-comment">// nums1肯定是长度更小的那个数组</span>        <span class="hljs-keyword">int</span> m = nums1.length;        <span class="hljs-keyword">int</span> n = nums2.length;        <span class="hljs-keyword">int</span> all = m + ((n - m + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);   <span class="hljs-comment">// 左边元素的个数，偶数（m+n）/2 奇数(m+n+1)/2，但是，由于是int除法，偶数也可以表示为（m+n+1）/2</span>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = m;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> j = all - i;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            i = left + ((right - left + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);            j = all - i;            <span class="hljs-keyword">if</span>(nums1[i - <span class="hljs-number">1</span>] &gt; nums2[j])&#123;                right = i - <span class="hljs-number">1</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                left = i;            &#125;        &#125;        i = left;        j = all - left;        <span class="hljs-keyword">int</span> nums1Left = i == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> nums1Right = i == m ? Integer.MAX_VALUE : nums1[i];        <span class="hljs-keyword">int</span> nums2Left = j == <span class="hljs-number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="hljs-number">1</span>];        <span class="hljs-keyword">int</span> nums2Right = j == n ? Integer.MAX_VALUE : nums2[j];        <span class="hljs-keyword">if</span>((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(Math.max(nums1Left,nums2Left) + Math.min(nums1Right,nums2Right)) / <span class="hljs-number">2.0</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)Math.max(nums1Left,nums2Left);        &#125;    &#125;&#125;</code></pre></div><h2 id="题号5最长回文字串"><a class="markdownIt-Anchor" href="#题号5最长回文字串"></a> 题号5：最长回文字串</h2><div class="note note-danger">            <p>题号：<code>5</code>，难度：<code>中等</code><br></p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><div class="hljs"><pre><code class="hljs 1c">输入: <span class="hljs-string">"babad"</span>输出: <span class="hljs-string">"bab"</span>注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。输入: <span class="hljs-string">"cbbd"</span>输出: <span class="hljs-string">"bb"</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/longest-palindromic-substring/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>动态规划，时间复杂度O(N<sup>2</sup>)，空间复杂度O(N<sup>2</sup>)。dp[ i ] [ j ]表示索引为 i 到索引为 j 的子字符串是否为回文串。首先 j 肯定大于等于 i。初始条件： i=j，一定是；i=j+1，需要判断索引为 i j 的两个字符是否相等；其它情况下，dp[ i ] [ j ] 由 dp[ i + 1 ] [ j - 1 ] 和索引为 i j 的两个字符是否相等来判断，也就是将本次需要判断的串缩小一个长度级别，判断该小子字符串是否为回文串，再判断新加在左边右边的字符是否相等。</li><li>中心扩展算法时间复杂度O(N<sup>2</sup>)，空间复杂度O(1)。直接向外边扩张，初始字符串应该由一个字符和两个字符来分别讨论。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 动态规划</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        &#125;        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()][s.length()];        String ans = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> L = <span class="hljs-number">0</span>; L &lt; s.length(); L++)&#123; <span class="hljs-comment">// 回文串长度</span>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length() - L; i++)&#123;                <span class="hljs-keyword">int</span> j = i + L;                <span class="hljs-keyword">if</span>(L == <span class="hljs-number">0</span>)&#123;                    dp[i][j] = <span class="hljs-keyword">true</span>;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(L == <span class="hljs-number">1</span>)&#123;                    dp[i][j] = (s.charAt(i) == s.charAt(j));                &#125;<span class="hljs-keyword">else</span>&#123;                    dp[i][j] = (dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; s.charAt(i) == s.charAt(j));                &#125;                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; (j - i + <span class="hljs-number">1</span>) &gt; ans.length())&#123;                    ans = s.substring(i, j+<span class="hljs-number">1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;<span class="hljs-comment">// 中心扩展算法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        &#125;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;            <span class="hljs-keyword">int</span> length_1 = CalLength(s, i, i);            <span class="hljs-keyword">int</span> length_2 = CalLength(s, i, i + <span class="hljs-number">1</span>);            <span class="hljs-keyword">int</span> len = Math.max(length_1,length_2);            <span class="hljs-keyword">if</span>(len &gt; end - begin + <span class="hljs-number">1</span>)&#123;                begin = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;                end = i + len / <span class="hljs-number">2</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.substring(begin,end + <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">CalLength</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;        <span class="hljs-keyword">while</span>(begin &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(begin) == s.charAt(end))&#123;  <span class="hljs-comment">//当初始为 i i+1时，要判断这时是否满足</span>            begin--;            end++;        &#125;        <span class="hljs-keyword">return</span> end - begin - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h2 id="题号7整数反转"><a class="markdownIt-Anchor" href="#题号7整数反转"></a> 题号7：整数反转</h2><div class="note note-danger">            <p>题号：<code>7</code>，难度：<code>简单</code><br></p><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2<sup>31</sup>, 2<sup>31</sup> − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><div class="hljs"><pre><code class="hljs angelscript">输入: <span class="hljs-number">123</span>输出: <span class="hljs-number">321</span>输入: <span class="hljs-number">-123</span>输出: <span class="hljs-number">-321</span>输入: <span class="hljs-number">120</span>输出: <span class="hljs-number">21</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/reverse-integer/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>这道题关键是要防止溢出，因此需要在运算前做出判断。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-keyword">int</span> y = x % <span class="hljs-number">10</span>;        x /= <span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span>(x != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(y &gt; <span class="hljs-number">214748364</span> || (y == <span class="hljs-number">214748364</span> &amp;&amp; x % <span class="hljs-number">10</span> &gt; <span class="hljs-number">6</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span>(y &lt; -<span class="hljs-number">214748364</span> || (y == -<span class="hljs-number">214748364</span> &amp;&amp; x % <span class="hljs-number">10</span> &lt; -<span class="hljs-number">7</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            y = y * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;            x /= <span class="hljs-number">10</span>;        &#125;        <span class="hljs-keyword">return</span> y;    &#125;&#125;</code></pre></div><h2 id="题号8字符串转换整数"><a class="markdownIt-Anchor" href="#题号8字符串转换整数"></a> 题号8：字符串转换整数</h2><div class="note note-danger">            <p>题号：<code>8</code>，难度：<code>简单</code><br></p><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br />假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br />该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br />注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。</p><p>本题中的空白字符只包括空格字符 ’  ’ 。<br />假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2<sup>31</sup>,  2<sup>31</sup> − 1]。如果数值超过这个范围，请返回  INT_MAX (2<sup>31</sup> − 1) 或 INT_MIN (−2<sup>31</sup>) 。</p><div class="hljs"><pre><code class="hljs makefile"><span class="hljs-section">输入: "42"</span><span class="hljs-section">输出: 42</span><span class="hljs-section">输入: "   -42"</span><span class="hljs-section">输出: -42</span><span class="hljs-section">解释: 第一个非空白字符为 '-', 它是一个负号。</span>     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<span class="hljs-section">输入: "4193 with words"</span><span class="hljs-section">输出: 4193</span><span class="hljs-section">解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</span><span class="hljs-section">输入: "words and 987"</span><span class="hljs-section">输出: 0</span><span class="hljs-section">解释: 第一个非空字符是 'w', 但它不是数字或正、负号。</span>     因此无法执行有效的转换。     <span class="hljs-section">输入: "-91283472332"</span><span class="hljs-section">输出: -2147483648</span><span class="hljs-section">解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 </span>     因此返回 INT_MIN (−231) 。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/reverse-integer/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>剑指Offer原题。注意判断溢出的地方即可。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(String str)</span> </span>&#123;        <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span> || str.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> length = str.length();        <span class="hljs-keyword">while</span>(i &lt; length &amp;&amp; str.charAt(i) == <span class="hljs-string">' '</span>)&#123;            i++;        &#125;        <span class="hljs-keyword">if</span>(i == length)&#123; <span class="hljs-comment">// 去除完空格后字符串为空</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> posi = <span class="hljs-number">1</span>; <span class="hljs-comment">// true为整数</span>        <span class="hljs-keyword">if</span>(str.charAt(i) == <span class="hljs-string">'-'</span> || str.charAt(i) == <span class="hljs-string">'+'</span>)&#123;            <span class="hljs-keyword">if</span>(str.charAt(i) == <span class="hljs-string">'-'</span>)&#123;                posi = -<span class="hljs-number">1</span>;            &#125;            i++;        &#125;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i &lt; length &amp;&amp; str.charAt(i) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; str.charAt(i) &lt;= <span class="hljs-string">'9'</span>)&#123;            <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">214748364</span> || (res == <span class="hljs-number">214748364</span> &amp;&amp; str.charAt(i) &gt; <span class="hljs-string">'7'</span>))&#123;                <span class="hljs-keyword">return</span> posi == <span class="hljs-number">1</span> ? <span class="hljs-number">2147483647</span> : -<span class="hljs-number">2147483648</span>;            &#125;            res = res * <span class="hljs-number">10</span> + str.charAt(i) - <span class="hljs-string">'0'</span>;            i++;        &#125;        <span class="hljs-keyword">return</span> posi * res;    &#125;&#125;</code></pre></div><h2 id="题号10正则表达式匹配"><a class="markdownIt-Anchor" href="#题号10正则表达式匹配"></a> 题号10：正则表达式匹配</h2><div class="note note-danger">            <p>题号：<code>10</code>，难度：<code>困难</code><br></p><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><div class="hljs"><pre><code class="hljs makefile">'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素<span class="hljs-section">输入:</span>s = <span class="hljs-string">"aa"</span>p = <span class="hljs-string">"a"</span><span class="hljs-section">输出: false</span><span class="hljs-section">解释: "a" 无法匹配 "aa" 整个字符串。</span><span class="hljs-section">输入:</span>s = <span class="hljs-string">"aa"</span>p = <span class="hljs-string">"a*"</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span><span class="hljs-section">输入:</span>s = <span class="hljs-string">"ab"</span>p = <span class="hljs-string">".*"</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span><span class="hljs-section">输入:</span>s = <span class="hljs-string">"aab"</span>p = <span class="hljs-string">"c*a*b"</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span><span class="hljs-section">输入:</span>s = <span class="hljs-string">"mississippi"</span>p = <span class="hljs-string">"mis*is*p*."</span><span class="hljs-section">输出: false</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/regular-expression-matching/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>剑指Offer原题。可以看我的题解。<a class="btn" href="https://rooftopj.cn/posts/point-to-offer-v2-java/#19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"  target="_blank">剑指Offer-19-正则表达式匹配</a></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || p == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>][p.length() + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; p.length(); j++)&#123;            <span class="hljs-keyword">if</span>(p.charAt(j) == <span class="hljs-string">'*'</span> &amp;&amp; dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>])&#123;                dp[<span class="hljs-number">0</span>][j + <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p.length(); j++)&#123;                <span class="hljs-keyword">if</span>(p.charAt(j) == <span class="hljs-string">'.'</span> || p.charAt(j) == s.charAt(i))&#123;                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j];                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p.charAt(j) == <span class="hljs-string">'*'</span>)&#123;                    <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="hljs-number">1</span>) != <span class="hljs-string">'.'</span>)&#123;                        dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                    &#125;<span class="hljs-keyword">else</span>&#123;                        dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = (dp[i + <span class="hljs-number">1</span>][j] || dp[i][j + <span class="hljs-number">1</span>] || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[s.length()][p.length()];    &#125;&#125;</code></pre></div><h2 id="题号11盛水最多的容器"><a class="markdownIt-Anchor" href="#题号11盛水最多的容器"></a> 题号11：盛水最多的容器</h2><div class="note note-danger">            <p>题号：<code>11</code>，难度：<code>中等</code><br></p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p><img src="https://i.loli.net/2020/08/13/63kYOoU721QzGVJ.png" srcset="/img/loading.gif" alt="" /></p><div class="hljs"><pre><code class="hljs angelscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>]输出：<span class="hljs-number">49</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/container-with-most-water/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>双指针，高度更小的那个指针向中间靠拢。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length &lt;= <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = height.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> max = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;            <span class="hljs-keyword">int</span> area = Math.min(height[begin],height[end]) * (end - begin);            max = area &gt; max ? area : max;            <span class="hljs-keyword">if</span>(height[begin] &lt; height[end])&#123;                begin++;            &#125;<span class="hljs-keyword">else</span>&#123;                end--;            &#125;        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre></div><h2 id="题号13罗马数字转整数"><a class="markdownIt-Anchor" href="#题号13罗马数字转整数"></a> 题号13：罗马数字转整数</h2><div class="note note-danger">            <p>题号：<code>13</code>，难度：<code>简单</code><br></p><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><div class="hljs"><pre><code class="hljs angelscript">字符          数值I             <span class="hljs-number">1</span>V             <span class="hljs-number">5</span>X             <span class="hljs-number">10</span>L             <span class="hljs-number">50</span>C             <span class="hljs-number">100</span>D             <span class="hljs-number">500</span>M             <span class="hljs-number">1000</span>I 可以放在 V (<span class="hljs-number">5</span>) 和 X (<span class="hljs-number">10</span>) 的左边，来表示 <span class="hljs-number">4</span> 和 <span class="hljs-number">9</span>。X 可以放在 L (<span class="hljs-number">50</span>) 和 C (<span class="hljs-number">100</span>) 的左边，来表示 <span class="hljs-number">40</span> 和 <span class="hljs-number">90</span>。 C 可以放在 D (<span class="hljs-number">500</span>) 和 M (<span class="hljs-number">1000</span>) 的左边，来表示 <span class="hljs-number">400</span> 和 <span class="hljs-number">900</span>。输入: <span class="hljs-string">"LVIII"</span>输出: <span class="hljs-number">58</span>解释: L = <span class="hljs-number">50</span>, V= <span class="hljs-number">5</span>, III = <span class="hljs-number">3.</span>输入: <span class="hljs-string">"MCMXCIV"</span>输出: <span class="hljs-number">1994</span>解释: M = <span class="hljs-number">1000</span>, CM = <span class="hljs-number">900</span>, XC = <span class="hljs-number">90</span>, IV = <span class="hljs-number">4.</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/roman-to-integer/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>若当前字符表示数字比它后面一个字符表示的数字小，则是减法，否则，加法。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">romanToInt</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> cur = getVal(s.charAt(<span class="hljs-number">0</span>));        <span class="hljs-keyword">int</span> next;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;            next = getVal(s.charAt(i));            <span class="hljs-keyword">if</span>(cur &lt; next)&#123;                sum -= cur;            &#125;<span class="hljs-keyword">else</span>&#123;                sum += cur;            &#125;            cur = next;        &#125;        sum += cur;        <span class="hljs-keyword">return</span> sum;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVal</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123;        <span class="hljs-keyword">switch</span>(c)&#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">'I'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'V'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'X'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'L'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'C'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'D'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">500</span>;            <span class="hljs-keyword">case</span> <span class="hljs-string">'M'</span>:   <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;            <span class="hljs-keyword">default</span>:    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre></div><h2 id="题号14最长公共前缀"><a class="markdownIt-Anchor" href="#题号14最长公共前缀"></a> 题号14：最长公共前缀</h2><div class="note note-danger">            <p>题号：<code>14</code>，难度：<code>简单</code><br></p><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><div class="hljs"><pre><code class="hljs prolog">输入: [<span class="hljs-string">"flower"</span>,<span class="hljs-string">"flow"</span>,<span class="hljs-string">"flight"</span>]输出: <span class="hljs-string">"fl"</span>输入: [<span class="hljs-string">"dog"</span>,<span class="hljs-string">"racecar"</span>,<span class="hljs-string">"car"</span>]输出: <span class="hljs-string">""</span>解释: 输入不存在公共前缀。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/longest-common-prefix/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>横向扫描。依次取出数组中的元素，与之前的结果相比较，找出至此的最长公共前缀，若中间出现了空字符串，不需要再继续比较了，直接返回。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> </span>&#123;        <span class="hljs-keyword">if</span>(strs == <span class="hljs-keyword">null</span> || strs.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        &#125;        String res = strs[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; strs.length; i++)&#123;            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(; j &lt; res.length() &amp;&amp; j &lt; strs[i].length() &amp;&amp; strs[i].charAt(j) == res.charAt(j); j++)&#123;                            &#125;            res = strs[i].substring(<span class="hljs-number">0</span>,j);            <span class="hljs-keyword">if</span>(res.length() == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> res;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="题号15三数之和"><a class="markdownIt-Anchor" href="#题号15三数之和"></a> 题号15：三数之和</h2><div class="note note-danger">            <p>题号：<code>15</code>，难度：<code>中等</code><br></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p>**注意：**答案中不可以包含重复的三元组。</p><div class="hljs"><pre><code class="hljs angelscript">给定数组 nums = [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-4</span>]，满足要求的三元组集合为：[  [<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],  [<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">2</span>]]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/3sum/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>先排序数组。</li><li>第一个外层循环遍历数组中每个元素，索引为 index，在这个循环内，再建立两个指针，指向位置分别初始化为：index + 1（左指针），以及数组最后一个元素（右指针），这样，就得到三个数字。</li><li>若 index 的数字大于零或者最后一个数字小于0，则一定找不到新的组合了；若index 指向的元素 和他前一个位置所指向的元素相同，那么可能会重复，需要跳过本次循环。若 sum = 0，则还得判断是否可能会重复，若左指针元素和他右边一个元素相同，左指针直接右移；若右指针元素和他左边一个元素相同，则直接左移。找到后，，还得让这两个指针都往中间移动一步。</li><li>若本次 sum 不为0，若小于0，则左指针右移，若大于0，则右指针左移。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> list;        &#125;        Arrays.sort(nums);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span> || nums[nums.length - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">int</span> L = i + <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> R = nums.length - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(L &lt; R)&#123;                <span class="hljs-keyword">int</span> sum = nums[i] + nums[L] + nums[R];                <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;                    list.add(Arrays.asList(nums[i],nums[L],nums[R]));                    <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; nums[L] == nums[L + <span class="hljs-number">1</span>]) L++;                    <span class="hljs-keyword">while</span>(L &lt; R &amp;&amp; nums[R] == nums[R - <span class="hljs-number">1</span>]) R--;                    L++;                    R--;                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;                    R--;                &#125;<span class="hljs-keyword">else</span>&#123;                    L++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre></div><h2 id="题号17电话号码的字母组合"><a class="markdownIt-Anchor" href="#题号17电话号码的字母组合"></a> 题号17：电话号码的字母组合</h2><div class="note note-danger">            <p>题号：<code>17</code>，难度：<code>中等</code><br></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://i.loli.net/2020/08/23/Ksjk2FNESxa87eV.png" srcset="/img/loading.gif" alt="" /></p><div class="hljs"><pre><code class="hljs prolog">输入：<span class="hljs-string">"23"</span>输出：[<span class="hljs-string">"ad"</span>, <span class="hljs-string">"ae"</span>, <span class="hljs-string">"af"</span>, <span class="hljs-string">"bd"</span>, <span class="hljs-string">"be"</span>, <span class="hljs-string">"bf"</span>, <span class="hljs-string">"cd"</span>, <span class="hljs-string">"ce"</span>, <span class="hljs-string">"cf"</span>].</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>回溯法。每次套一个循环，这个循环遍历这个数字所代表的字母，并且往后走一个数字。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">private</span> Map&lt;Character, Character[]&gt; phone = <span class="hljs-keyword">new</span> HashMap&lt;&gt;() &#123;&#123;    put(<span class="hljs-string">'2'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>&#125;);    put(<span class="hljs-string">'3'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'d'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'f'</span>&#125;);    put(<span class="hljs-string">'4'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'g'</span>,<span class="hljs-string">'h'</span>,<span class="hljs-string">'i'</span>&#125;);    put(<span class="hljs-string">'5'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'j'</span>,<span class="hljs-string">'k'</span>,<span class="hljs-string">'l'</span>&#125;);    put(<span class="hljs-string">'6'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'m'</span>,<span class="hljs-string">'n'</span>,<span class="hljs-string">'o'</span>&#125;);    put(<span class="hljs-string">'7'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'p'</span>,<span class="hljs-string">'q'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'s'</span>&#125;);    put(<span class="hljs-string">'8'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'t'</span>,<span class="hljs-string">'u'</span>,<span class="hljs-string">'v'</span>&#125;);    put(<span class="hljs-string">'9'</span>, <span class="hljs-keyword">new</span> Character[] &#123;<span class="hljs-string">'w'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>&#125;);  &#125;&#125;;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;        <span class="hljs-keyword">if</span>(digits == <span class="hljs-keyword">null</span> || digits.length() &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();        &#125;        <span class="hljs-keyword">int</span> length = digits.length();        combinationRecur(<span class="hljs-number">0</span>,length,digits,<span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combinationRecur</span><span class="hljs-params">(<span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> max, String input, String temp)</span></span>&#123;        <span class="hljs-keyword">if</span>(begin &gt;= max)&#123;            res.add(temp);            <span class="hljs-keyword">return</span>;        &#125;        Character[] choice = phone.get(input.charAt(begin));        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : choice)&#123;            String s = temp + String.valueOf(c);            combinationRecur(begin + <span class="hljs-number">1</span>, max, input, s);        &#125;    &#125;&#125;</code></pre></div><h2 id="题号19删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#题号19删除链表的倒数第n个节点"></a> 题号19：删除链表的倒数第N个节点</h2><div class="note note-danger">            <p>题号：<code>19</code>，难度：<code>中等</code><br></p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><div class="hljs"><pre><code class="hljs angelscript">给定一个链表: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>, 和 n = <span class="hljs-number">2.</span>当删除了倒数第二个节点后，链表变为 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">5.</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>双指针，先让一个指针往前走N步，再让两个指针同时往前走。这里要注意的是，利用了哑节点简化某些极端情况，如最后删除的是第一个节点等。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || n &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        ListNode temp = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        temp.next = head;        ListNode first = temp;        ListNode second = temp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;            first = first.next;            <span class="hljs-keyword">if</span>(first == <span class="hljs-keyword">null</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;        <span class="hljs-keyword">while</span>(first.next != <span class="hljs-keyword">null</span>)&#123;            second = second.next;            first = first.next;        &#125;        second.next = second.next.next;        <span class="hljs-keyword">return</span> temp.next;    &#125;&#125;</code></pre></div><h2 id="题号20有效的括号"><a class="markdownIt-Anchor" href="#题号20有效的括号"></a> 题号20：有效的括号</h2><div class="note note-danger">            <p>题号：<code>20</code>，难度：<code>简单</code><br></p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><div class="hljs"><pre><code class="hljs actionscript">输入: <span class="hljs-string">"()[]&#123;&#125;"</span>输出: <span class="hljs-literal">true</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/valid-parentheses/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>利用辅助栈，每出现一个正向的括号，就向栈中压入一个对应的反向括号；每遇到一个反向的括号，就弹栈，判断弹出元素是否为该反向括号，同时，栈的大小不能小于0。最后，若栈的大小大于0，说明没匹配完全，也是false。可以哈希表来存放括号对应关系，简化代码。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        Stack&lt;Character&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'('</span>)&#123;                stack.push(<span class="hljs-string">')'</span>);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'&#123;'</span>)&#123;                stack.push(<span class="hljs-string">'&#125;'</span>);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'['</span>)&#123;                stack.push(<span class="hljs-string">']'</span>);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">')'</span>)&#123;                <span class="hljs-keyword">if</span>(stack.size() &lt;= <span class="hljs-number">0</span> || <span class="hljs-string">')'</span> != stack.pop())&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">'&#125;'</span>)&#123;                <span class="hljs-keyword">if</span>(stack.size() &lt;= <span class="hljs-number">0</span> || <span class="hljs-string">'&#125;'</span> != stack.pop())&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">']'</span>)&#123;                <span class="hljs-keyword">if</span>(stack.size() &lt;= <span class="hljs-number">0</span> || <span class="hljs-string">']'</span> != stack.pop())&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(stack.size() &gt; <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h2 id="题号21合并两个有序链表"><a class="markdownIt-Anchor" href="#题号21合并两个有序链表"></a> 题号21：合并两个有序链表</h2><div class="note note-danger">            <p>题号：<code>21</code>，难度：<code>简单</code><br></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><div class="hljs"><pre><code class="hljs angelscript">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>经典题目。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode temp = res;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(l1.val &lt; l2.val)&#123;                temp.next = <span class="hljs-keyword">new</span> ListNode(l1.val);                l1 = l1.next;            &#125;<span class="hljs-keyword">else</span>&#123;                temp.next = <span class="hljs-keyword">new</span> ListNode(l2.val);                l2 = l2.next;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;            temp.next = l2;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;            temp.next = l1;        &#125;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre></div><h2 id="题号22括号生成"><a class="markdownIt-Anchor" href="#题号22括号生成"></a> 题号22：括号生成</h2><div class="note note-danger">            <p>题号：<code>22</code>，难度：<code>中等</code><br></p><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><div class="hljs"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>输出：[       <span class="hljs-string">"((()))"</span>,       <span class="hljs-string">"(()())"</span>,       <span class="hljs-string">"(())()"</span>,       <span class="hljs-string">"()(())"</span>,       <span class="hljs-string">"()()()"</span>     ]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/generate-parentheses/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>回溯法。remain 表示还剩余几个正括号没有使用，extra 表示还剩余多少个已使用的正括号没有用反括号配对。如果正括号和其对应反括号已经使用完毕，那么得到一个组合。如果仅仅正括号使用完毕，那么直接加反括号；如果仅仅反括号使用完毕，那么只能加正括号；如果正括号没有使用完并且对应的反括号也没匹配完，那么既可以加正括号，也可以加反括号。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        &#125;        generateRecu(n,<span class="hljs-number">0</span>,<span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateRecu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> remain, <span class="hljs-keyword">int</span> extra, String s)</span></span>&#123;        <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span> &amp;&amp; extra == <span class="hljs-number">0</span>)&#123;            list.add(s);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(remain == <span class="hljs-number">0</span>)&#123;            String temp = s + <span class="hljs-string">")"</span>;            generateRecu(remain, extra - <span class="hljs-number">1</span>, temp);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(extra == <span class="hljs-number">0</span>)&#123;            String temp = s + <span class="hljs-string">"("</span>;            generateRecu(remain - <span class="hljs-number">1</span>, extra + <span class="hljs-number">1</span>, temp);        &#125;<span class="hljs-keyword">else</span>&#123;            String temp1 = s + <span class="hljs-string">"("</span>;            generateRecu(remain - <span class="hljs-number">1</span>, extra + <span class="hljs-number">1</span>, temp1);            String temp2 = s + <span class="hljs-string">")"</span>;            generateRecu(remain, extra - <span class="hljs-number">1</span>, temp2);        &#125;    &#125;&#125;</code></pre></div><h2 id="题号23合并k个升序链表"><a class="markdownIt-Anchor" href="#题号23合并k个升序链表"></a> 题号23：合并K个升序链表</h2><div class="note note-danger">            <p>题号：<code>23</code>，难度：<code>中等</code><br></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><div class="hljs"><pre><code class="hljs angelscript">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]解释：链表数组如下：[  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span>]将它们合并到一个有序链表中得到。<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>利用最小堆，将数组中所有链表的头节点都加入最小堆进行排序，每次从最小堆中取出最小的元素，加入到链表中。</li><li>小循环内两两排序，大循环内重复所有链表的两两排序，直到最后只剩一个链表。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//======================================================法1==========================================================</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || lists.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Queue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1,v2) -&gt; v1.val-v2.val);        <span class="hljs-keyword">for</span>(ListNode node : lists)&#123;            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;                queue.offer(node);            &#125;        &#125;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode temp = res;        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;            ListNode l = queue.poll();            temp.next = l;            temp = temp.next;            <span class="hljs-keyword">if</span>(l.next != <span class="hljs-keyword">null</span>)&#123;                queue.offer(l.next);            &#125;        &#125;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;<span class="hljs-comment">//======================================================法2==========================================================</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || lists.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">int</span> k = lists.length;        <span class="hljs-keyword">while</span>(k &gt; <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i += <span class="hljs-number">2</span>)&#123;                <span class="hljs-keyword">if</span>(i == k - <span class="hljs-number">1</span>)&#123;                    lists[temp++] = lists[i];                &#125;<span class="hljs-keyword">else</span>&#123;                    lists[temp++] = merge2Lists(lists[i], lists[i+<span class="hljs-number">1</span>]);                &#125;            &#125;            k = temp;        &#125;        <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge2Lists</span><span class="hljs-params">(ListNode n1, ListNode n2)</span></span>&#123;        ListNode res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);        ListNode temp = res;        <span class="hljs-keyword">while</span>(n1 != <span class="hljs-keyword">null</span> &amp;&amp; n2 != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(n1.val &lt; n2.val)&#123;                temp.next = n1;                n1 = n1.next;            &#125;<span class="hljs-keyword">else</span>&#123;                temp.next = n2;                n2 = n2.next;            &#125;            temp = temp.next;        &#125;        <span class="hljs-keyword">if</span>(n1 == <span class="hljs-keyword">null</span>)&#123;            temp.next = n2;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n2 == <span class="hljs-keyword">null</span>)&#123;            temp.next = n1;        &#125;        <span class="hljs-keyword">return</span> res.next;    &#125;&#125;</code></pre></div><h2 id="题号26删除排序数组中的重复项"><a class="markdownIt-Anchor" href="#题号26删除排序数组中的重复项"></a> 题号26：删除排序数组中的重复项</h2><div class="note note-danger">            <p>题号：<code>26</code>，难度：<code>简单</code><br></p><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><div class="hljs"><pre><code class="hljs angelscript">给定数组 nums = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], 函数应该返回新的长度 <span class="hljs-number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">2</span>。 你不需要考虑数组中超出新长度后面的元素。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>双指针法，第二个指针帮助寻找不同的元素，存放到第一个指针处。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> res = nums.length;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> end = <span class="hljs-number">1</span>; end &lt; nums.length; end++)&#123;            <span class="hljs-keyword">if</span>(nums[end] == nums[begin])&#123;                res--;                <span class="hljs-keyword">continue</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                nums[++begin] = nums[end];            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="题号28实现strstr"><a class="markdownIt-Anchor" href="#题号28实现strstr"></a> 题号28：实现strStr()</h2><div class="note note-danger">            <p>题号：<code>28</code>，难度：<code>简单</code><br></p><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><div class="hljs"><pre><code class="hljs nix">输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">"hello"</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">"ll"</span>输出: <span class="hljs-number">2</span>输入: <span class="hljs-attr">haystack</span> = <span class="hljs-string">"aaaaa"</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">"bba"</span>输出: -<span class="hljs-number">1</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/implement-strstr/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>KMP。</p><ol><li>构造一个dp矩阵，行为模式字符串长度，列为256，就是所有的char字符。实质上是一个有限状态机。dp i j 表示在匹配完 i 个字符后，遇到字符 j，该转移到哪个状态。</li><li>进行匹配。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String haystack, String needle)</span> </span>&#123;        <span class="hljs-keyword">if</span>(haystack == <span class="hljs-keyword">null</span> || needle == <span class="hljs-keyword">null</span> || needle.length() &gt; haystack.length())&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(needle.length() == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// KMP构造dp矩阵</span>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[needle.length()][<span class="hljs-number">256</span>];        dp[<span class="hljs-number">0</span>][needle.charAt(<span class="hljs-number">0</span>)] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> X = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; needle.length(); i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++)&#123;                dp[i][j] = dp[X][j];            &#125;            dp[i][needle.charAt(i)] = i + <span class="hljs-number">1</span>;            X = dp[X][needle.charAt(i)];         &#125;        <span class="hljs-comment">// 开始匹配</span>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.length(); i++)&#123;            j = dp[j][haystack.charAt(i)];            <span class="hljs-keyword">if</span>(j == needle.length())&#123;                <span class="hljs-keyword">return</span> i - j + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h2 id="题号29两数相除"><a class="markdownIt-Anchor" href="#题号29两数相除"></a> 题号29：两数相除</h2><div class="note note-danger">            <p>题号：<code>29</code>，难度：<code>中等</code><br></p><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p><p>返回被除数 dividend 除以除数 divisor 得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p><div class="hljs"><pre><code class="hljs angelscript">输入: dividend = <span class="hljs-number">10</span>, divisor = <span class="hljs-number">3</span>输出: <span class="hljs-number">3</span>解释: <span class="hljs-number">10</span>/<span class="hljs-number">3</span> = truncate(<span class="hljs-number">3.33333</span>..) = truncate(<span class="hljs-number">3</span>) = <span class="hljs-number">3</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/divide-two-integers/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>可以用加法，让除数不断加自己，也就是让自己翻一番，每加一次，结果就翻一番，超过的部分，进行递归，看中间差的部分结果是多少。注意边界条件。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dividend, <span class="hljs-keyword">int</span> divisor)</span> </span>&#123;        <span class="hljs-keyword">if</span>(divisor == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> dividend;        &#125;        <span class="hljs-keyword">if</span>(divisor == -<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(dividend &gt; Integer.MIN_VALUE)&#123;                <span class="hljs-keyword">return</span> -dividend;            &#125;            <span class="hljs-keyword">return</span> Integer.MAX_VALUE;        &#125;        <span class="hljs-keyword">int</span> isPosi = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>((dividend &lt; <span class="hljs-number">0</span> &amp;&amp; divisor &gt; <span class="hljs-number">0</span>) || (dividend &gt; <span class="hljs-number">0</span> &amp;&amp; divisor &lt; <span class="hljs-number">0</span>))&#123;            isPosi = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">long</span> dividendTemp = dividend &gt; <span class="hljs-number">0</span> ? dividend : -(<span class="hljs-keyword">long</span>)dividend;        <span class="hljs-keyword">long</span> divisorTemp = divisor &gt; <span class="hljs-number">0</span> ? divisor : -(<span class="hljs-keyword">long</span>)divisor;        <span class="hljs-keyword">int</span> res = div (dividendTemp,divisorTemp);        <span class="hljs-keyword">if</span>(isPosi == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -res;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">long</span> a, <span class="hljs-keyword">long</span> b)</span></span>&#123;        <span class="hljs-keyword">if</span>(a &lt; b)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">long</span> tb = b;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(a &gt;= (tb + tb))&#123;            res = res + res;            tb = tb + tb;        &#125;        <span class="hljs-keyword">return</span> res + div(a - tb, b);    &#125;&#125;</code></pre></div><h2 id="题号33搜索旋转排序数组"><a class="markdownIt-Anchor" href="#题号33搜索旋转排序数组"></a> 题号33：搜索旋转排序数组</h2><div class="note note-danger">            <p>题号：<code>33</code>，难度：<code>中等</code><br></p><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><div class="hljs"><pre><code class="hljs angelscript">输入: nums = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], target = <span class="hljs-number">0</span>输出: <span class="hljs-number">4</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>二分查找，每次查找的时候需要先确定是在左半部分的排序数组中查找还是在右半部分的排序数组中查找。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(begin &lt;= end)&#123;            mid = begin + ((end - begin + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-comment">// 前半部分有序</span>            <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[begin])&#123;                <span class="hljs-comment">// 在前半部分</span>                <span class="hljs-keyword">if</span>(nums[mid] &gt; target &amp;&amp; nums[begin] &lt;= target)&#123;                    end = mid - <span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    begin = mid + <span class="hljs-number">1</span>;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 后半部分有序</span>                <span class="hljs-comment">// 在后半部分</span>                <span class="hljs-keyword">if</span>(nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target)&#123;                    begin = mid + <span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    end = mid - <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><h2 id="题号34在排序数组中查找元素的第一个和最后一个元素位置"><a class="markdownIt-Anchor" href="#题号34在排序数组中查找元素的第一个和最后一个元素位置"></a> 题号34：在排序数组中查找元素的第一个和最后一个元素位置</h2><div class="note note-danger">            <p>题号：<code>34</code>，难度：<code>中等</code><br></p><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><div class="hljs"><pre><code class="hljs angelscript">输入: nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">8</span>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输入: nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>], target = <span class="hljs-number">6</span>输出: [<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>二分查找，找到目标元素后还需要进一步查找。分别为进一步向左查找和进一步向右查找。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        <span class="hljs-keyword">int</span>[] res = &#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">int</span> left = search(nums,target,<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">if</span>(left == nums.length || nums[left] != target)&#123;            <span class="hljs-keyword">return</span> res;        &#125;        res[<span class="hljs-number">0</span>] = left;        <span class="hljs-keyword">int</span> right = search(nums,target,<span class="hljs-keyword">false</span>);        res[<span class="hljs-number">1</span>] = right - <span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">boolean</span> flag)</span></span>&#123;        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> end = nums.length;        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;            <span class="hljs-keyword">int</span> mid = begin + ((end - begin) &gt;&gt; <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span>(nums[mid] &gt; target || (flag &amp;&amp; nums[mid] == target))&#123;                end = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                begin = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> begin;    &#125;&#125;</code></pre></div><h2 id="题号36有效的数独"><a class="markdownIt-Anchor" href="#题号36有效的数独"></a> 题号36：有效的数独</h2><div class="note note-danger">            <p>题号：<code>36</code>，难度：<code>中等</code><br></p><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br />数字 1-9 在每一列只能出现一次。<br />数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p><p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p><div class="hljs"><pre><code class="hljs cs">输入:[<span class="hljs-meta"></span><span class="hljs-meta">  [<span class="hljs-meta-string">"5"</span>,<span class="hljs-meta-string">"3"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"7"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"6"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"1"</span>,<span class="hljs-meta-string">"9"</span>,<span class="hljs-meta-string">"5"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"9"</span>,<span class="hljs-meta-string">"8"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"6"</span>,<span class="hljs-meta-string">"."</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"8"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"6"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"3"</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"4"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"8"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"3"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"1"</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"7"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"2"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"6"</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"6"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"2"</span>,<span class="hljs-meta-string">"8"</span>,<span class="hljs-meta-string">"."</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"4"</span>,<span class="hljs-meta-string">"1"</span>,<span class="hljs-meta-string">"9"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"5"</span></span>],  [<span class="hljs-meta"><span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"8"</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"."</span>,<span class="hljs-meta-string">"7"</span>,<span class="hljs-meta-string">"9"</span></span>]]输出: <span class="hljs-literal">true</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/valid-sudoku/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>用一个双层循环，遍历数独矩阵中的每个元素。在最内层循环中，可以想办法将行、列、宫全进行一次遍历。具体可以看代码。判断是否存在重复元素，可以通过位运算。哪一位为一就是已经出现过该数字，如第三位为一就是出现过三，每次判断时，将用来记录的数字右移判断的数字位，将其与1比较，判断是否出现过该数字，若没有，则可以将1左移判断的数字位，并与用来记录的数字进行异或。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;        <span class="hljs-keyword">if</span>(board == <span class="hljs-keyword">null</span> || board.length &lt;= <span class="hljs-number">0</span> || board[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)&#123;            <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>, sqre = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)&#123;                <span class="hljs-keyword">int</span> colNum = board[i][j] - <span class="hljs-number">48</span>;                <span class="hljs-keyword">int</span> rowNum = board[j][i] - <span class="hljs-number">48</span>;                <span class="hljs-keyword">int</span> sqreNum = board[<span class="hljs-number">3</span> * (i / <span class="hljs-number">3</span>) + j / <span class="hljs-number">3</span>][<span class="hljs-number">3</span> * (i % <span class="hljs-number">3</span>) + j % <span class="hljs-number">3</span>] - <span class="hljs-number">48</span>;                <span class="hljs-keyword">if</span>(colNum &gt; <span class="hljs-number">0</span>)&#123;                    col = bitCal(col, colNum);                &#125;                <span class="hljs-keyword">if</span>(rowNum &gt; <span class="hljs-number">0</span>)&#123;                    row = bitCal(row, rowNum);                &#125;                                <span class="hljs-keyword">if</span>(sqreNum &gt; <span class="hljs-number">0</span>)&#123;                    sqre = bitCal(sqre, sqreNum);                &#125;                <span class="hljs-keyword">if</span>(row == -<span class="hljs-number">1</span> || col == -<span class="hljs-number">1</span> || sqre == -<span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bitCal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> input)</span></span>&#123;        <span class="hljs-keyword">return</span> ((cur &gt;&gt; input) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : (<span class="hljs-number">1</span> &lt;&lt; input) ^ cur;    &#125;    &#125;</code></pre></div><h2 id="题号38外观数列"><a class="markdownIt-Anchor" href="#题号38外观数列"></a> 题号38：外观数列</h2><div class="note note-danger">            <p>题号：<code>38</code>，难度：<code>简单</code><br></p><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p><p>注意：整数序列中的每一项将表示为一个字符串。</p><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>     <span class="hljs-number">1</span><span class="hljs-number">2.</span>     <span class="hljs-number">11</span><span class="hljs-number">3.</span>     <span class="hljs-number">21</span><span class="hljs-number">4.</span>     <span class="hljs-number">1211</span><span class="hljs-number">5.</span>     <span class="hljs-number">111221</span>第一项是数字 <span class="hljs-number">1</span>描述前一项，这个数是 <span class="hljs-number">1</span> 即 “一个 <span class="hljs-number">1</span> ”，记作 <span class="hljs-number">11</span>描述前一项，这个数是 <span class="hljs-number">11</span> 即 “两个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">21</span>描述前一项，这个数是 <span class="hljs-number">21</span> 即 “一个 <span class="hljs-number">2</span> 一个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">1211</span>描述前一项，这个数是 <span class="hljs-number">1211</span> 即 “一个 <span class="hljs-number">1</span> 一个 <span class="hljs-number">2</span> 两个 <span class="hljs-number">1</span> ” ，记作 <span class="hljs-number">111221</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/count-and-say/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>递归。通过StringBuffer提升效率。遇到不同的就记录下来，同时，到达最后一个元素，直接记录下来。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"1"</span>;        &#125;        String temp = countAndSay(n - <span class="hljs-number">1</span>);        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; temp.length() + <span class="hljs-number">1</span>; i++)&#123;            <span class="hljs-keyword">if</span>(i == temp.length())&#123;                sb.append(i - begin).append(temp.charAt(begin));            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp.charAt(begin) != temp.charAt(i))&#123;                sb.append(i - begin).append(temp.charAt(begin));                begin = i;            &#125;        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><h2 id="题号41缺失的第一个正数"><a class="markdownIt-Anchor" href="#题号41缺失的第一个正数"></a> 题号41：缺失的第一个正数</h2><div class="note note-danger">            <p>题号：<code>41</code>，难度：<code>困难</code><br></p><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><p>你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的额外空间。</p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]输出: <span class="hljs-number">3</span>输入: [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">2</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/first-missing-positive/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>直接在输入数组上进行操作。将数组中为 i 大小的值放在索引为 i - 1处。注意交换后，不能将 i 直接++，需要对交换到该位置上的元素也进行判断。最后，遍历交换结束后的数组，第一个不符合要求的就是未出现的正数，若遍历完后也没找到，那就是数组的长度加一。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; nums.length &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i])&#123;                swap(nums, i, nums[i] - <span class="hljs-number">1</span>);                i--;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums.length + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;        <span class="hljs-keyword">int</span> temp =nums[a];        nums[a] = nums[b];        nums[b] = temp;    &#125;&#125;</code></pre></div><h2 id="题号42接雨水"><a class="markdownIt-Anchor" href="#题号42接雨水"></a> 题号42：接雨水</h2><div class="note note-danger">            <p>题号：<code>42</code>，难度：<code>困难</code><br></p><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="https://i.loli.net/2020/08/28/zGwVyL6fgJrx4PB.png" srcset="/img/loading.gif" alt="" /></p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">6</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/trapping-rain-water/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划-&gt;双指针优化空间复杂度。</p><ol><li>遍历每一列，这一列左边最高一列，右边最高一列中较矮的那一列，若高于这一列，则这一列可以接雨水，量为高度差。所以，我们可以用动态规划得到每一列左边的最高列和右边的最高列，存放在两个数组中。</li><li>为了优化空间复杂度，可以用双指针，一个从头开始，一个从尾开始。若左指针较高，则左边界已找到，这时看右指针位置是否低于右边界，若低，则接水；若高，更新右边界高度；若右指针较高，则右边界已找到，这时看左指针位置是否低于左边界，若低，则接水；若高，则更新左边界高度。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;        <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length &lt; <span class="hljs-number">3</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> right = height.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> leftMax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> rightMax = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;                <span class="hljs-keyword">if</span>(height[left] &gt;= leftMax)&#123;                    leftMax = height[left];                &#125;<span class="hljs-keyword">else</span>&#123;                    res += (leftMax - height[left]);                &#125;                left++;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(height[right] &gt;= rightMax)&#123;                    rightMax = height[right];                &#125;<span class="hljs-keyword">else</span>&#123;                    res += (rightMax - height[right]);                &#125;                right--;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="题号44通配符匹配"><a class="markdownIt-Anchor" href="#题号44通配符匹配"></a> 题号44：通配符匹配</h2><div class="note note-danger">            <p>题号：<code>44</code>，难度：<code>困难</code><br></p><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>'?'</code> 和 <code>'*'</code> 的通配符匹配。</p><div class="hljs"><pre><code class="hljs makefile">'?' 可以匹配任何单个字符。'*' 可以匹配任意字符串（包括空字符串）。<span class="hljs-section">输入:</span>s = <span class="hljs-string">"aa"</span>p = <span class="hljs-string">"a"</span><span class="hljs-section">输出: false</span><span class="hljs-section">解释: "a" 无法匹配 "aa" 整个字符串。</span><span class="hljs-section">输入:</span>s = <span class="hljs-string">"aa"</span>p = <span class="hljs-string">"*"</span><span class="hljs-section">输出: true</span><span class="hljs-section">解释: '*' 可以匹配任意字符串。</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/wildcard-matching/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划。dp i j 表示前 i 个字符与前 j 个字符是否匹配。</p><ol><li>第一个循环，当输入空串时，模式字符串若不为空，则需要全为<code>*</code>，才能匹配上。</li><li>第二个循环，进行动态规划。若模式字符为<code>?</code>或者两个字符匹配上，则各往前看一步；若模式字符为<code>*</code>，则可能为空，可能匹配多次。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || p == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>][p.length() + <span class="hljs-number">1</span>];        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; dp[<span class="hljs-number">0</span>].length; i++)&#123;            <span class="hljs-keyword">if</span>(p.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span>)&#123;                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[<span class="hljs-number">0</span>].length; j++)&#123;                <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">'?'</span> || p.charAt(j - <span class="hljs-number">1</span>) == s.charAt(i - <span class="hljs-number">1</span>))&#123;                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">'*'</span>)&#123;                    dp[i][j] = dp[i -<span class="hljs-number">1</span>][j] || dp[i][j - <span class="hljs-number">1</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[s.length()][p.length()];    &#125;&#125;</code></pre></div><h2 id="题号46全排列"><a class="markdownIt-Anchor" href="#题号46全排列"></a> 题号46：全排列</h2><div class="note note-danger">            <p>题号：<code>46</code>，难度：<code>中等</code><br></p><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>'?'</code> 和 <code>'*'</code> 的通配符匹配。</p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出:[  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/permutations/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>回溯算法。需要注意的是回溯的细节。</p><ol><li>最后长度达到要求，就可以将这一份结果添加进链表中，添加时需要复制一份添加。</li><li>更新时，需要删除上一步添加进去的数值。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        List&lt;Integer&gt; visit = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        permuteRecu(nums,visit);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">permuteRecu</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, List&lt;Integer&gt; visit)</span></span>&#123;        <span class="hljs-keyword">if</span>(visit.size() == nums.length)&#123;            res.add(copyList(visit));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;            <span class="hljs-keyword">if</span>(visit.contains(num))&#123;                <span class="hljs-keyword">continue</span>;            &#125;            visit.add(num);            permuteRecu(nums,visit);            visit.remove((Integer) num);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">copyList</span><span class="hljs-params">(List&lt;Integer&gt; visit)</span></span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span>(Integer i : visit)&#123;            list.add(i);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;&#125;</code></pre></div><h2 id="题号48旋转图像"><a class="markdownIt-Anchor" href="#题号48旋转图像"></a> 题号48：旋转图像</h2><div class="note note-danger">            <p>题号：<code>48</code>，难度：<code>中等</code><br></p><p>给定一个 n × n 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p>说明：</p><p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><div class="hljs"><pre><code class="hljs angelscript">给定 matrix = [  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],  [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]],原地旋转输入矩阵，使其变为:[  [<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],  [<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/rotate-image/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>先转置矩阵；</li><li>再将矩阵镜像翻转即可。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; matrix[<span class="hljs-number">0</span>].length; j++)&#123;                <span class="hljs-keyword">int</span> temp = matrix[i][j];                matrix[i][j] = matrix[j][i];                matrix[j][i] = temp;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (matrix[<span class="hljs-number">0</span>].length &gt;&gt; <span class="hljs-number">1</span>); j++)&#123;                <span class="hljs-keyword">int</span> temp = matrix[i][j];                matrix[i][j] = matrix[i][matrix[<span class="hljs-number">0</span>].length - j - <span class="hljs-number">1</span>];                matrix[i][matrix[<span class="hljs-number">0</span>].length - j - <span class="hljs-number">1</span>] = temp;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="题号49字母异位词分组"><a class="markdownIt-Anchor" href="#题号49字母异位词分组"></a> 题号49：字母异位词分组</h2><div class="note note-danger">            <p>题号：<code>49</code>，难度：<code>中等</code><br></p><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><div class="hljs"><pre><code class="hljs prolog">输入: [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]输出:[  [<span class="hljs-string">"ate"</span>,<span class="hljs-string">"eat"</span>,<span class="hljs-string">"tea"</span>],  [<span class="hljs-string">"nat"</span>,<span class="hljs-string">"tan"</span>],  [<span class="hljs-string">"bat"</span>]]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/group-anagrams/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>可以将每个字符串排序，排序后相同的字符串就是同一组异位词，通过哈希表的键值对来存放结果。</li><li>可以统计每个字符串中每个字符出现的个数，每个字符出现个数相同的字符串就是同一组异位词，通过每个字符出现个数生成一组唯一字符，用来表示哈希表中的key。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;        <span class="hljs-keyword">if</span>(strs == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        <span class="hljs-keyword">int</span>[] chara = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];        HashMap&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span>(String str : strs)&#123;            Arrays.fill(chara,<span class="hljs-number">0</span>);            <span class="hljs-keyword">char</span>[] strChar = str.toCharArray();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : strChar)&#123;                chara[c - <span class="hljs-string">'a'</span>]++;            &#125;            StringBuilder s = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">""</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> ii : chara)&#123;                s.append(<span class="hljs-string">"#"</span>).append(ii);            &#125;            <span class="hljs-keyword">if</span>(map.get(s.toString()) == <span class="hljs-keyword">null</span>)&#123;                List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();                list.add(str);                map.put(s.toString(), list);            &#125;<span class="hljs-keyword">else</span>&#123;                map.get(s.toString()).add(str);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList(map.values());    &#125;&#125;</code></pre></div><h2 id="题号50powx-n"><a class="markdownIt-Anchor" href="#题号50powx-n"></a> 题号50：Pow(x, n)</h2><div class="note note-danger">            <p>题号：<code>50</code>，难度：<code>中等</code><br></p><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p><div class="hljs"><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span>输出: <span class="hljs-number">1024.00000</span>输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span>输出: <span class="hljs-number">9.26100</span>输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">-2</span>输出: <span class="hljs-number">0.25000</span>解释: <span class="hljs-number">2</span><span class="hljs-number">-2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0.25</span></code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/powx-n/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>直接用一个for循环，时间复杂度为O(n)。</li><li>递归，每次求一半的指数。时间复杂度为O(logn)，空间复杂度为O(logn)。</li><li>由于递归占用栈空间，本方法转为迭代，我们可以发现规律，就是次方数二进制表示中 1 所处的位置的次方相乘。代码演示的为本方法。</li></ol><p><img src="https://i.loli.net/2020/08/30/XUzb564IHTMAQdi.png" srcset="/img/loading.gif" alt="" /></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>;        &#125;        <span class="hljs-keyword">long</span> N = n;        <span class="hljs-keyword">return</span> N &gt; <span class="hljs-number">0</span> ? pow(x,N) : <span class="hljs-number">1</span> / pow(x, -N);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">long</span> n)</span></span>&#123;        <span class="hljs-keyword">double</span> xTemp = x;        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;                res *= xTemp;            &#125;            xTemp = xTemp * xTemp;            n = n &gt;&gt; <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="题号53最大子序和"><a class="markdownIt-Anchor" href="#题号53最大子序和"></a> 题号53：最大子序和</h2><div class="note note-danger">            <p>题号：<code>53</code>，难度：<code>简单</code><br></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大，为 <span class="hljs-number">6</span>。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/maximum-subarray/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>动态规划，时间复杂度O(n)。dp[n]表示以索引为 n 结尾的元素的最大子序和。</p></li><li><p>分治法。对于一个区间 l r，我们可以维护四个量：</p><ul><li>lsum 表示 l r 内以 l 为左端点的最大子段和</li><li>rsum 表示 l r 内以 r 为右端点的最大子段和</li><li>asum 表示 l r 内的最大子段和</li><li>ressum 表示 l r 的区间和</li></ul><ol><li>首先最好维护的是 iSum，区间 l r 的 asum 就等于「左子区间」的 asum 加上「右子区间」的 asum。</li><li>对于 l r 的 lsum ，存在两种可能，它要么等于「左子区间」的 lsum ，要么等于「左子区间」的 asum加上「右子区间」的 lsum ，二者取大。</li><li>对于 l r 的 rsum，同理，它要么等于「右子区间」的 rsum，要么等于「右子区间」的 asum加上「左子区间」的 rsum，二者取大。</li><li>当计算好上面的三个量之后，就很好计算 l r 的 ressum 了。我们可以考虑 l r 的 ressum 对应的区间是否跨越 m——它可能不跨越 m，也就是说 l r 的 ressum可能是「左子区间」的 ressum和 「右子区间」的 ressum 中的一个；它也可能跨越 m，可能是「左子区间」的 rsum和 「右子区间」的 lsum求和。三者取大。</li></ol></li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//====================================动态规划===============================================</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span> dp = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;            dp = Math.max(nums[i] + dp, nums[i]);            res = dp &gt; res ? dp : res;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;<span class="hljs-comment">//======================================分治法==============================================</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">int</span>[] res = merge(nums, <span class="hljs-number">0</span>, nums.length -<span class="hljs-number">1</span> );        <span class="hljs-keyword">return</span> res[<span class="hljs-number">3</span>];    &#125;    <span class="hljs-comment">// 分别为lsum rsum asum ressum</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] merge(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)&#123;        <span class="hljs-keyword">if</span>(begin == end)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;nums[begin],nums[begin],nums[begin],nums[begin]&#125;;        &#125;        <span class="hljs-keyword">int</span> mid = begin + ((end - begin) &gt;&gt; <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span>[] left = merge(nums, begin, mid);        <span class="hljs-keyword">int</span>[] right = merge(nums, mid + <span class="hljs-number">1</span>, end);        <span class="hljs-keyword">int</span> lsum = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">2</span>] + right[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">int</span> rsum = Math.max(right[<span class="hljs-number">1</span>], left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">2</span>]);        <span class="hljs-keyword">int</span> asum = left[<span class="hljs-number">2</span>] + right[<span class="hljs-number">2</span>];        <span class="hljs-keyword">int</span> ressum = Math.max(Math.max(left[<span class="hljs-number">3</span>],right[<span class="hljs-number">3</span>]), left[<span class="hljs-number">1</span>] + right[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;lsum, rsum, asum, ressum&#125;;    &#125;&#125;</code></pre></div><h2 id="题号54螺旋矩阵"><a class="markdownIt-Anchor" href="#题号54螺旋矩阵"></a> 题号54：螺旋矩阵</h2><div class="note note-danger">            <p>题号：<code>54</code>，难度：<code>中等</code><br></p><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><div class="hljs"><pre><code class="hljs angelscript">输入:[ [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ], [ <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ], [ <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> ]]输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]输入:[  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],  [<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>]]输出: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/spiral-matrix/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>定义四个索引，分别为：起始行，终点行，起始列，终点列。在循环中：</p><ol><li>在起始行，从起点列遍历至终点列，相当于从左到右，完成后起始行加一，若起始行大于终点行，则完成任务；</li><li>在终点列，从起始行遍历至终点行，想当于从上到下，完成后终点列减一，若终点列小于起点列，则完成任务；</li><li>在终点行，从终点列遍历至起点列，相当于从右到左，完成后终点行减一，若终点行小于起点行，则完成任务；</li><li>在起点列，从终点行遍历至起点行，相当于从下到上，完成后起点列加一，若起点列大于终点列，则完成任务。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;        <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span> || matrix.length == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        &#125;        <span class="hljs-keyword">int</span> rowBegin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> rowEnd = matrix.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> colBegin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> colEnd = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = colBegin; i &lt;= colEnd; i++)&#123;                res.add(matrix[rowBegin][i]);            &#125;            <span class="hljs-keyword">if</span>(++rowBegin &gt; rowEnd)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = rowBegin; i &lt;= rowEnd; i++)&#123;                res.add(matrix[i][colEnd]);            &#125;            <span class="hljs-keyword">if</span>(--colEnd &lt; colBegin)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = colEnd; i &gt;= colBegin; i--)&#123;                res.add(matrix[rowEnd][i]);            &#125;            <span class="hljs-keyword">if</span>(--rowEnd &lt; rowBegin)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = rowEnd; i &gt;= rowBegin; i--)&#123;                res.add(matrix[i][colBegin]);            &#125;            <span class="hljs-keyword">if</span>(++colBegin &gt; colEnd)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre></div><h2 id="题号55跳跃游戏"><a class="markdownIt-Anchor" href="#题号55跳跃游戏"></a> 题号55：跳跃游戏</h2><div class="note note-danger">            <p>题号：<code>55</code>，难度：<code>中等</code><br></p><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-literal">true</span>解释: 我们可以先跳 <span class="hljs-number">1</span> 步，从位置 <span class="hljs-number">0</span> 到达 位置 <span class="hljs-number">1</span>, 然后再从位置 <span class="hljs-number">1</span> 跳 <span class="hljs-number">3</span> 步到达最后一个位置。输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-literal">false</span>解释: 无论怎样，你总会到达索引为 <span class="hljs-number">3</span> 的位置。但该位置的最大跳跃长度是 <span class="hljs-number">0</span> ， 所以你永远不可能到达最后一个位置。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/jump-game/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>递归回溯，出现栈溢出问题，有非常高效的解法。</p><p>每遍历到一个元素，获取在该元素下能到的最右边索引 rightMost，若该最右边索引值能到最后，返回 true；若中途发现遍历到的元素索引大于了最右边索引值 rightMost，则返回 false。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> rightMost = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;            <span class="hljs-keyword">if</span>(i &lt;= rightMost)&#123;                rightMost = Math.max(rightMost, i + nums[i]);                <span class="hljs-keyword">if</span>(rightMost &gt;= nums.length - <span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客瞎玩玩</title>
    <link href="/posts/blog-techniques-v1/"/>
    <url>/posts/blog-techniques-v1/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-auto-refresh"><a class="markdownIt-Anchor" href="#hexo-auto-refresh"></a> hexo-auto-refresh</h2><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://img.shields.io/badge/python-3.8-orange" srcset="/img/loading.gif" alt="" /></div><div class="group-image-wrap"><img src="https://img.shields.io/badge/python-selenium-brightgreen" srcset="/img/loading.gif" alt="" /></div><div class="group-image-wrap"><img src="https://img.shields.io/badge/Node-%3E%3D8.1.0-orange" srcset="/img/loading.gif" alt="" /></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://img.shields.io/badge/ChromeDriver-%3Dversion--Browser-red" srcset="/img/loading.gif" alt="" /></div><div class="group-image-wrap"><img src="https://img.shields.io/badge/release-v1.0.0-blue" srcset="/img/loading.gif" alt="" /></div><div class="group-image-wrap"><img src="https://img.shields.io/badge/license-MIT-green" srcset="/img/loading.gif" alt="" /></div></div></div><p>hexo博客自动部署工具。每次部署，都要输入重复的指令，本着懒惰是第一生产力的原则，制作了hexo-auto-fresh这个小工具，简化我们对于hexo的一些操作。除一些基本功能外，还可自动刷新七牛云cdn目录缓存。</p><a class="btn" href="https://github.com/rooftopj/hexo-auto-refresh"  target="_blank">rooftopj/hexo-auto-refresh</a><h3 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h3><p>将本项目 <code>clone</code> 至你的博客根目录下。</p><h3 id="使用步骤"><a class="markdownIt-Anchor" href="#使用步骤"></a> 使用步骤</h3><p>打开hexo-auto-refresh.exe文件。</p><p><img src="https://i.loli.net/2020/07/17/874ksSuhDQnE6RP.png" srcset="/img/loading.gif" alt="hexo-auto-refresh界面图" /></p><ul><li>User name：你的七牛云账号。</li><li>Password：你的七牛云账号所对应的密码。</li><li>updateSite1：你要刷新的文件目录。注意最后需要一个 / 。</li><li>updateSite2：你要刷新的文件目录。注意最后需要一个 / 。</li></ul><p>以上四条个人信息在第一次使用时需要自己手动输入，运行<code>With CDN</code>下的功能后，会保存个人数据。往后每一次打开该工具，会自动导入上次输入的信息。</p><p><code>Create post:</code>创建博文，文件名为newPost中的内容。</p><ol><li>Without CDN，以下三个功能不会自动刷新七牛云CDN目录。</li></ol><ul><li><p><code>Local deployment:</code>本地部署。停止该服务时不要直接关闭对应的窗口，应按 crtl+C 退出。</p></li><li><p><code>Remote deploymen(gulp):</code>采用gulp插件压缩文件（需要先配置 gulp 插件），并部署至远端。</p></li><li><p><code>Remote deploymen:</code>不经压缩部署到远端（不使用gulp插件）。</p></li></ul><ol start="2"><li>With CDN，以下三个功能会自动刷新七牛云CDN目录。</li></ol><ul><li><p><code>Refresh CDN:</code>自动刷新七牛云cdn目录缓存。</p></li><li><p><code>Remote deployment(gulp, CDN):</code>采用gulp插件压缩文件（需要先配置 gulp 插件），部署至远端。并自动刷新七牛云cdn目录缓存。</p></li><li><p><code>Remote deployment(CDN):</code>不经压缩部署到远端（不使用gulp插件）。并自动刷新七牛云cdn目录缓存。</p></li></ul><h2 id="黑夜模式"><a class="markdownIt-Anchor" href="#黑夜模式"></a> 黑夜模式</h2><p>黑夜模式<code>fluid</code>正式版已经加入，但之前没更新该功能时我就想整个黑夜模式，看到强哥的 demo 网站有介绍，便改改拿过来用了，把黑夜功能完善了一下：包括搜索界面、遗漏的元素。把强哥 css 的配置替换为如下代码即可。</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-comment">/*暗黑模式*/</span>.dark  <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>  .modal-<span class="hljs-attribute">content</span>    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>  #leancloud-site-pv-container    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  #leancloud-site-uv-container    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  #local-search-close    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .page-number    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .category-count    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .circle-chart__percent    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .circle-chart__subline    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .circle-chart__info    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  #timeDate    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  #times    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .hover-with-bg    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .hidden-mobile    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .iconfont    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .circle-chart__subline    stroke: #cac4c4;    stroke-<span class="hljs-attribute">width</span>: <span class="hljs-number">0.2px</span>;  .circle-chart__percent    stroke: #cac4c4;    stroke-<span class="hljs-attribute">width</span>: <span class="hljs-number">0.2px</span>;  <span class="hljs-comment">/* 背景遮罩 */</span>  .<span class="hljs-attribute">mask</span>    background-color rgba(0,0,0,.4) !important  <span class="hljs-comment">/* 主体 */</span>  <span class="hljs-selector-id">#board</span>     <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>    <span class="hljs-selector-tag">img</span>      <span class="hljs-attribute">filter</span> brightness(<span class="hljs-number">65%</span>) // 图片亮度  p  <span class="hljs-selector-class">.index-info</span> <span class="hljs-selector-tag">a</span>      <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span> !important  .markdown-body    <span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>,s,<span class="hljs-selector-tag">li</span>        <span class="hljs-attribute">color</span>:<span class="hljs-number">#cac4c4</span> !important      <span class="hljs-comment">/* 顶栏 */</span>  .navbar-col-show  <span class="hljs-selector-class">.top-nav-collapse</span>      <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>      <span class="hljs-selector-class">.navbar</span> <span class="hljs-selector-tag">a</span>      <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span> !important      <span class="hljs-selector-class">.animated-icon</span> <span class="hljs-selector-tag">span</span>   <span class="hljs-comment">/* 手机端 */</span>    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#cac4c4</span>  <span class="hljs-comment">/* page-number */</span>  <span class="hljs-selector-class">.pagination</span> <span class="hljs-selector-tag">a</span>:hover  <span class="hljs-selector-class">.pagination</span> <span class="hljs-selector-class">.current</span>      <span class="hljs-attribute">background-color</span> <span class="hljs-number">#6b6b6b</span>  <span class="hljs-comment">/* 打字机 */</span>  #subtitle  <span class="hljs-selector-class">.dark</span>.typed-<span class="hljs-attribute">cursor</span>--blink  .scroll-down-arrow    <span class="hljs-attribute">color</span> <span class="hljs-number">#dfdfdf</span>  <span class="hljs-comment">/* back to top */</span>  #scroll-<span class="hljs-attribute">top</span>-button    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>    i      <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>      <span class="hljs-comment">/* Toc */</span>  <span class="hljs-selector-class">.tocbot-list</span> a    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>  .tocbot-active-link  <span class="hljs-selector-tag">footer</span> <span class="hljs-selector-tag">a</span>:hover    <span class="hljs-attribute">color</span> <span class="hljs-number">#1abc9c</span> !important  <span class="hljs-comment">/* footer */</span>  <span class="hljs-selector-tag">footer</span> a    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>      <span class="hljs-comment">/* 归档页 */</span>  .list-group-item    <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>      <span class="hljs-selector-class">.list-group-item</span>:hover  <span class="hljs-selector-class">.tagcloud</span> <span class="hljs-selector-tag">a</span>:hover    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#46484d</span>  <span class="hljs-comment">/* 友链页 */</span>  .links    <span class="hljs-selector-class">.card</span>        <span class="hljs-attribute">background-color</span> <span class="hljs-number">#282c34</span>            <span class="hljs-selector-class">.card-body</span>:hover        <span class="hljs-attribute">background-color</span> <span class="hljs-number">#46484d</span>            .link-title    <span class="hljs-selector-class">.link-intro</span>        <span class="hljs-attribute">color</span> <span class="hljs-number">#cac4c4</span>      <span class="hljs-comment">/* note标签 配色有点丑 */</span>  .note-info    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#3b5359</span>    <span class="hljs-attribute">border-color</span> <span class="hljs-number">#006d80</span>  .note-danger    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#783f42</span>    <span class="hljs-attribute">border-color</span> <span class="hljs-number">#670009</span>  .note-success    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#2a3e2e</span>    <span class="hljs-attribute">border-color</span> <span class="hljs-number">#005915</span>  .note-warning    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#5b543e</span>    <span class="hljs-attribute">border-color</span> <span class="hljs-number">#846500</span>  .note-primary    <span class="hljs-attribute">background-color</span> <span class="hljs-number">#455a6f</span>    <span class="hljs-attribute">border-color</span> <span class="hljs-number">#004188</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer第二版Java实现</title>
    <link href="/posts/point-to-offer-v2-java/"/>
    <url>/posts/point-to-offer-v2-java/</url>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><code>剑指Offer第二版</code>，全题解，已完结。参考资料为牛客网以及力扣上各大佬的题解分享。</p><a class="btn" href="https://www.nowcoder.com/discuss/198840?type=1"  target="_blank">牛客网：剑指offer全解（Java版）</a><br><a class="btn" href="[https://leetcode-cn.com/problemset/all/?search=%E5%89%91%E6%8C%87offer](https://leetcode-cn.com/problemset/all/?search=剑指offer)"  target="_blank">leetcode：剑指offer</a><br><a class="btn" href="http://product.dangdang.com/24242724.html"  target="_blank">剑指offer第二版</a><h2 id="第二章-面试需要的基础知识"><a class="markdownIt-Anchor" href="#第二章-面试需要的基础知识"></a> 第二章 面试需要的基础知识</h2><h3 id="31-数组中重复的数字"><a class="markdownIt-Anchor" href="#31-数组中重复的数字"></a> 3.1、数组中重复的数字</h3><div class="note note-danger">            <p>题目：<br></p><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><p><a class="btn" href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>第一种思路：将元素排序，再从头到尾扫描排序后的数组。</li><li>第二种思路：借助一个哈希表，头到尾扫描数组，每当扫描到一个数字时，判断哈希表中是否存在该数字，不存在则将该数字加入哈希表中，存在则找到重复数字。</li><li>第三种思路：我们注意到数组中的数字都在 0 到 n-1 的范围内，重排这个数组，数组排序后，若数组中没有重复的元素，则数组中第 i 个元素的值应为 i 。接下来重排数组。当扫描到第 i 个数字后（用 m 表示），判断 i 与 m 是否相等，若相等，扫描下一个数字；若不相等，将该数字与数组中第 m 个数字进行比较，若相等，则找到重复数字，若不相等，则交换这两个数字的位置，让数字m处在它应该处在的位置，接着扫描下一个数字。</li></ol><p>第三种思路的时间复杂度是O(n)，空间复杂度是O(1)。采用第三种思路。</p>          </div><div class="hljs"><pre><code class="hljs java">Input:&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125; Output:<span class="hljs-keyword">true</span> duplication[<span class="hljs-number">0</span>]=<span class="hljs-number">2</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numbers[],<span class="hljs-keyword">int</span> length,<span class="hljs-keyword">int</span> [] duplication)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == numbers || length &lt;= <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;            <span class="hljs-keyword">if</span>(numbers[i] != i)&#123;                <span class="hljs-keyword">if</span>(numbers[numbers[i]] == numbers[i])&#123;                    duplication[<span class="hljs-number">0</span>] = numbers[i];                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">int</span> temp = numbers[i];                    numbers[i] = numbers[numbers[i]];                    numbers[temp] = temp; <span class="hljs-comment">// 注意numbers[i]的值已改变，需要用temp来指代原numbers[i]</span>                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><h3 id="32-不修改数组找出重复数字"><a class="markdownIt-Anchor" href="#32-不修改数组找出重复数字"></a> 3.2、不修改数组找出重复数字</h3><div class="note note-danger">            <p>题目：<br></p><p>在一个长度为 n+1 的数组里的所有数字都在 1 到 n 的范围内。所以数组中至少有一个数组是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>第一种思路：将原数组复制到辅助数组，如果原数组中被复制的数字是 m ，则把它复制到辅助数组下标为 m-1 的位置，这样就很容易发现哪个数字是重复的。</li><li>第二种思路：将 1~n 的数字从中间 m 分为两部分，前面一半为 1~m，后面一半为 m+1~n，如果数组中 1~m 的数字超过 m 个，则在 1~m 中一定有重复的数字，否则，在 m+1~n 中一定有重复数字，这样继续将有重复数字的区间一分为二，直到找到最后的数字。</li></ol><p>第二种思路的时间复杂度是O(nlogn)，空间复杂度是O(1)。相当于以时间换空间，这里演示第二种思路。</p>          </div><div class="hljs"><pre><code class="hljs java">Input:&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125; Output:<span class="hljs-keyword">true</span> duplication[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numbers[],<span class="hljs-keyword">int</span> length,<span class="hljs-keyword">int</span> [] duplication)</span> </span>&#123;        <span class="hljs-keyword">return</span> search(numbers, <span class="hljs-number">1</span>, length - <span class="hljs-number">1</span>, duplication);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] duplication)</span></span>&#123;        <span class="hljs-keyword">while</span>(end &gt;= begin)&#123;            <span class="hljs-keyword">int</span> mid = (begin + end)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">int</span> count = countRange(numbers, begin, mid);            <span class="hljs-keyword">if</span>(begin == mid)&#123;                <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">1</span>)&#123;                    duplication[<span class="hljs-number">0</span>] = begin;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    duplication[<span class="hljs-number">0</span>] = mid+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(count &gt; (mid - begin + <span class="hljs-number">1</span>))&#123;                end = mid;            &#125;<span class="hljs-keyword">else</span>&#123;                begin = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++)&#123;            <span class="hljs-keyword">if</span>(numbers[i] &gt;= begin &amp;&amp; numbers[i] &lt;= end)&#123;                count++;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;</code></pre></div><h3 id="4-二维数组中的查找"><a class="markdownIt-Anchor" href="#4-二维数组中的查找"></a> 4、二维数组中的查找</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><p><a class="btn" href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>设目标数字为 target，该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，可从右上角开始查找，若右上角数字等于 target，则找到；若右上角数字大于 target，则target 不会在该数字当前列以及右边列，将列数减一，下次搜索时右上角元素为当前元素的左边一个位置；若右上角数字小于 target，则target 不会在该数字当前行以及上边列，将行数加一，下次搜索时右上角元素为当前元素的上边一个位置。这样就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。<br></p><p>也可从左下角开始查找，时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p>          </div><div class="hljs"><pre><code class="hljs java">Consider the following matrix:[  [<span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>],  [<span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>],  [<span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>],  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span>],  [<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span>]] Given target = <span class="hljs-number">5</span>, <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>.Given target = <span class="hljs-number">20</span>, <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>.        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> [][] array)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == array)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">int</span> rowBegin = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> colEnd = array[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(rowBegin &lt;= array.length - <span class="hljs-number">1</span> &amp;&amp; colEnd &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(array[rowBegin][colEnd] == target)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[rowBegin][colEnd] &gt; target)&#123;                colEnd--;            &#125;<span class="hljs-keyword">else</span>&#123;                rowBegin++;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;</code></pre></div><h3 id="5-替换空格"><a class="markdownIt-Anchor" href="#5-替换空格"></a> 5、替换空格</h3><div class="note note-danger">            <p>题目：<br></p><p>将一个字符串中的空格替换成 “%20”。</p><p><a class="btn" href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>时间复杂度为O(n^2)：从头到尾扫描字符串，遇到空格字符，把该字符后面的所有字符都向后移动两个字节，并把该字符替换为 %20。</p></li><li><p>时间复杂度为O(n)：先遍历一次字符串，计算出空格字符的数量，根据该数量扩充原字符串（每有一个空格字符，扩充两个字节）。用 p1 指向原字符串尾部，用 p2 指向扩充后的字符串尾部，向前移动 p1 指针，将其指向字符复制到 p2 所指向位置，p2 也随之移动，若该字符为空格，则 p2 处应该插入 %20，直至 p1 和 p2 指向同一位置，表示所有空格已替换完毕。</p></li></ol><p>采用第二种思路。<br></p><p>相关题目：<br></p><p>有两个排序数组 A1 和 A2，内存在 A1 的末尾有足够多的空余空间容纳 A2。把 A2 中所有的数字插入 A1中，并且所有的数字是排序的。这题从后往前复制即可。</p>          </div><div class="hljs"><pre><code class="hljs java">Input:<span class="hljs-string">"A B"</span> Output:<span class="hljs-string">"A%20B"</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == str)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">""</span>))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        &#125;    <span class="hljs-keyword">int</span> p1 = str.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= p1; i++)&#123;            <span class="hljs-keyword">if</span>(str.charAt(i) == <span class="hljs-string">' '</span>)&#123;                str.append(<span class="hljs-string">"  "</span>);            &#125;        &#125;        <span class="hljs-keyword">int</span> p2 = str.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(p1 &lt; p2)&#123;            <span class="hljs-keyword">char</span> temp = str.charAt(p1--);            <span class="hljs-keyword">if</span>(temp == <span class="hljs-string">' '</span>)&#123;                str.setCharAt(p2--, <span class="hljs-string">'0'</span>);                str.setCharAt(p2--, <span class="hljs-string">'2'</span>);                str.setCharAt(p2--, <span class="hljs-string">'%'</span>);            &#125;<span class="hljs-keyword">else</span>&#123;                str.setCharAt(p2--, temp);            &#125;        &#125;        <span class="hljs-keyword">return</span> str.toString();    &#125;</code></pre></div><h3 id="6-从尾到头打印链表"><a class="markdownIt-Anchor" href="#6-从尾到头打印链表"></a> 6、从尾到头打印链表</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p><p><a class="btn" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：</p><ol><li><p>反转链表（头插法），接着从头到尾输出链表的节点值。这样做会改变原链表的结构。</p></li><li><p>从头到尾将链表的节点值压入栈中，再从栈顶弹出节点值。</p></li><li><p>与第二种思路类似，采用递归的方法完成任务。</p></li></ol>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><span class="hljs-comment">*反转链表后再输出</span><span class="hljs-comment">*/</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;       ListNode listNodeHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);       ListNode temp;       <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;           temp = listNode.next;           listNode.next = listNodeHead.next;           listNodeHead.next = listNode;           listNode = temp;       &#125;       listNode = listNodeHead.next;       ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();       <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;           list.add(listNode.val);           listNode = listNode.next;       &#125;       <span class="hljs-keyword">return</span> list;   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*压栈法</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == listNode)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;       &#125;       Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();       <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;           stack.push(listNode.val);           listNode = listNode.next;       &#125;       ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();       <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;           list.add(stack.pop());       &#125;       <span class="hljs-keyword">return</span> list;   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*递归法</span><span class="hljs-comment">*/</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;       ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();       <span class="hljs-keyword">if</span>(listNode != <span class="hljs-keyword">null</span>)&#123;           list = printListFromTailToHead(listNode.next);           list.add(listNode.val);       &#125;       <span class="hljs-keyword">return</span> list;   &#125;</code></pre></div><h3 id="7-重建二叉树"><a class="markdownIt-Anchor" href="#7-重建二叉树"></a> 7、重建二叉树</h3><div class="note note-danger">            <p>题目：<br></p><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>前序遍历的第一个数字就是根节点的值，得到该数字在中序遍历的位置，中序遍历中位于该位置之前的数字都是左子树节点的值；中序遍历中位于该位置之后的数字都是右子树节点的值。再递归从子树中不断按照上述步骤确定各子树根节点。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;        map.put(inorder[i],i);    &#125;    <span class="hljs-keyword">return</span> buildTreeFunction(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTreeFunction</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preBegin, <span class="hljs-keyword">int</span> preEnd, <span class="hljs-keyword">int</span> in)</span></span>&#123;    <span class="hljs-keyword">if</span>(preBegin &gt; preEnd)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    TreeNode treeNode = <span class="hljs-keyword">new</span> TreeNode(preorder[preBegin]);    <span class="hljs-keyword">int</span> place = map.get(preorder[preBegin]);    <span class="hljs-keyword">int</span> leftCount = place - in;    treeNode.left = buildTreeFunction(preorder, preBegin + <span class="hljs-number">1</span>, preBegin + leftCount, in);    treeNode.right = buildTreeFunction(preorder, preBegin + leftCount + <span class="hljs-number">1</span>, preEnd, in + leftCount + <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> treeNode;&#125;</code></pre></div><h3 id="8-二叉树的下一个节点"><a class="markdownIt-Anchor" href="#8-二叉树的下一个节点"></a> 8、二叉树的下一个节点</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p><a class="btn" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>如果一个节点有右子树，那么中序遍历下这个节点的下一个节点为该右子树最左边的节点。</li><li>如果一个节点无右子树，且该节点为其父节点的左子节点，那么中序遍历下这个节点的下一个节点为该节点的父节点。</li><li>如果一个节点无右子树，且该节点为其父节点的右子节点，那么可以沿父节点一直向上遍历，直到找到某个节点为其父节点的左子节点，那么该节点的父节点就为我们要寻找的节点。</li><li>以上都没找到，则该节点为该树中序遍历的最后一个节点。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeLinkNode <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode pNode)</span></span>&#123;    <span class="hljs-keyword">if</span>(pNode == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">if</span>(pNode.right != <span class="hljs-keyword">null</span>)&#123;        pNode = pNode.right;        <span class="hljs-keyword">while</span>(pNode.left != <span class="hljs-keyword">null</span>)&#123;            pNode = pNode.left;        &#125;        <span class="hljs-keyword">return</span> pNode;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(pNode.next != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(pNode.next.left == pNode)&#123;                <span class="hljs-keyword">return</span> pNode.next;            &#125;<span class="hljs-keyword">else</span>&#123;                pNode = pNode.next;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><h3 id="9-用两个栈实现队列"><a class="markdownIt-Anchor" href="#9-用两个栈实现队列"></a> 9、用两个栈实现队列</h3><div class="note note-danger">            <p>题目：<br></p><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作，即在队列尾部插入节点以及在队列头部删除节点。</p><p><a class="btn" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>插入节点可直接将节点压入 stack1 栈中，弹出节点时，判断 stack2 栈是否为空，若为空，则依次将 stack1 栈中数据弹出并压入 stack2 栈中，这样完成数据逆序操作，弹出 stack2 栈顶元素，即弹出了头节点；若不为空，则直接弹出 stack2 栈顶元素，即弹出头节点。</p><p>相关题目：<br></p><p>用两个队列实现一个栈。<br></p><p>压入节点可直接将节点加入 queue1 队列中，弹出节点时，判断 queue1 队列是否为空，若不为空，则依次将 queue1 队列中数据删除并加入 queue2 队列中，直至 queue1 队列只剩一个节点，该节点即为待弹出节点；若为空，依次将 queue2 队列中数据删除并加入 queue1 队列中，直至 queue2 队列只剩一个节点，该节点即为待弹出节点。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;        stack1.push(node);    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;                stack2.push(stack1.pop());            &#125;        &#125;        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Queue is empty!"</span>);        &#125;        <span class="hljs-keyword">return</span> stack2.pop();    &#125;&#125;</code></pre></div><h3 id="10-斐波拉契数列"><a class="markdownIt-Anchor" href="#10-斐波拉契数列"></a> 10、斐波拉契数列</h3><div class="note note-danger">            <p>题目：<br></p><p>写一个函数，输入 n，求斐波那契数列的第 n 项。</p><p><a class="btn" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p><p>斐波拉契数列定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n)=\left\{\begin{array}{ll}0, &amp; \text { if } n=0 \\1, &amp; \text { if } n=1 \\f(n-1)+f(n-2), &amp;\text { if }n&gt;1 \end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.49999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>一般该题最直接的解法是递归法，但是会有大量的重复计算。因此可以从下往上计算，时间复杂度是O(n)。</p></li><li><p>第二种方法是借助下列数学公式，求矩阵的乘方，要求 n 次方，可采用递归实现 n/2 次方，这里时间复杂度是O(logn)。</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><msup><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{bmatrix} f(n) &amp; f(n-1)\\ f(n-1) &amp; f(n-2)\end{bmatrix}=\begin{bmatrix} 1 &amp; 1\\ 1 &amp; 0\end{bmatrix}^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>这里采用第一种思路。</p><p>相关题目：<br></p><ol><li>青蛙跳台阶问题。一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶，问该青蛙跳上一个 n 级的台阶共有多少种跳法。</li></ol><p>若只有 0 级台阶，那只有 0 种跳法；若只有 1 级台阶，那只有 1 种跳法；若只有 2 级台阶，那只有 2 种跳法；若台阶数量大于 2，我们把跳 n 级台阶的跳法定义为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，第一次跳 1 级台阶，此时跳法就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，第一次跳 2 级台阶，此时跳法就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，与斐波拉契数列相似。</p><ol start="2"><li>青蛙跳台阶问题。一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶，…，也可以跳上 n 级台阶，问该青蛙跳上一个 n 级的台阶共有多少种跳法。</li></ol><p>总共有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f(n) = 2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>跳法。</p><ol start="3"><li>用 2x1 的小矩形无重叠的覆盖一个 2x8 的大矩形，总共有多少种方法。</li></ol><p>记方法的种数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>，在最左边竖着覆盖，则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>，在最左边横着覆盖，则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(8)=f(6)+f(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>，也形似斐波拉契数列。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> n;    &#125;    <span class="hljs-keyword">int</span> fb0 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> fb1 = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;        ans = fb0 + fb1;        fb0 = fb1;        fb1 = ans;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre></div><h3 id="11-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#11-旋转数组的最小数字"></a> 11、旋转数组的最小数字</h3><div class="note note-danger">            <p>题目：<br></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><p><a class="btn" href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>一般该题最直接的解法是从头到尾遍历数组，但时间复杂度是O(n)。</p></li><li><p>我们可以发现，旋转数组是由两个排序数组组成的，数组中第一个元素大于等于最后一个元素（一般情况下），两个数组的分界处，第二个数组的开头元素，即为整个数组的最小元素。类似二分法，用两个指针分别指向第一个元素和最后一个元素，第三个指针指向那两个指针中间的一个元素，若该元素大于等于第一个指针指向的元素，则该中间元素还在第一组排序数组中，将第一个指针移至该元素处；若该元素小于等于第二个指针指向的元素，则该中间元素在第二组排序数组中，将第二个指针移至该元素处。重复上述过程，直至那两个指针相邻，找到数组分界处。</p><p>· 特殊情况1：若没有旋转，数组中第一个元素小于最后一个元素，则第一个元素就是要寻找的。这可以在初始化第三个指针时先直接让它指向第一个元素。</p><p>· 特殊情况2：数组中数字重复，三个指针指向元素相等，无法判断第三个指针指向元素属于哪个数组，这时只能用顺序查找法。</p></li></ol><p>这里采用第二种思路。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == array || array.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Invalid array!"</span>);    &#125;    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = array.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> mid = begin; <span class="hljs-comment">//初始化begin，可以在未旋转的这种特殊情况下，直接输出第一个元素，也就是最小的元素</span>    <span class="hljs-keyword">while</span>(array[begin] &gt;= array[end])&#123;        <span class="hljs-keyword">if</span>(end - begin == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> array[end];        &#125;        <span class="hljs-keyword">if</span>(array[begin] == array[end] &amp;&amp; array[begin] == array[mid])&#123;            <span class="hljs-keyword">return</span> minNum(array, begin, end);        &#125;        mid = (begin + end) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(array[mid] &gt;= array[begin])&#123;            begin = mid;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[mid] &lt;= array[end])&#123;            end = mid;        &#125;    &#125;    <span class="hljs-keyword">return</span> array[end];&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> res = array[begin];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin + <span class="hljs-number">1</span>; i &lt;= end; i++)&#123;        <span class="hljs-keyword">if</span>(res &gt; array[i])&#123;            res = array[i];        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="12-矩阵中的路径"><a class="markdownIt-Anchor" href="#12-矩阵中的路径"></a> 12、矩阵中的路径</h3><div class="note note-danger">            <p>题目：<br></p><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如下面的矩阵包含了一条 bfce 路径。</p><p><a class="btn" href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p><p><img src="https://i.loli.net/2020/07/14/SZoIqsjue75Wfnb.png" srcset="/img/loading.gif" alt="示意图" /></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>直接采用回溯法，遍历起点位置，然后按照上下左右的顺序进行递归。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPath</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">char</span>[] str)</span></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == matrix || rows &lt;= <span class="hljs-number">0</span> || cols &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">char</span>[][] buildedMatrix = buildMatrix(matrix, rows, cols);    <span class="hljs-keyword">boolean</span>[][] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)&#123;            <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, i, j, str, marked, <span class="hljs-number">0</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*    回溯法寻找</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findWay</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] buildedMatrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">boolean</span>[][] marked, <span class="hljs-keyword">int</span> point)</span></span>&#123;    <span class="hljs-keyword">if</span>(point == str.length)&#123; <span class="hljs-comment">//先判断这个条件，避免下一个判断出现数组索引异常</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">0</span> || row &gt;= rows || col &lt; <span class="hljs-number">0</span> || col &gt;= cols        || marked[row][col] == <span class="hljs-keyword">true</span> || str[point] != buildedMatrix[row][col])&#123; <span class="hljs-comment">//注意要先判断row和col有没有越界，不然会出现数组索引异常</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    marked[row][col] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row - <span class="hljs-number">1</span>, col, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 上</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row + <span class="hljs-number">1</span>, col, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 下</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row, col - <span class="hljs-number">1</span>, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 左</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row, col + <span class="hljs-number">1</span>, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 右</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    marked[row][col] = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*    将输入的一维数组转换为问题所描述的矩阵</span><span class="hljs-comment">*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[][] buildMatrix(<span class="hljs-keyword">char</span>[] matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)&#123;    <span class="hljs-keyword">char</span>[][] buildedMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[rows][cols];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)&#123;            buildedMatrix[i][j] = matrix[cols * i + j];        &#125;    &#125;    <span class="hljs-keyword">return</span> buildedMatrix;&#125;</code></pre></div><h3 id="13-机器人的运动范围"><a class="markdownIt-Anchor" href="#13-机器人的运动范围"></a> 13、机器人的运动范围</h3><div class="note note-danger">            <p>题目：<br></p><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p><a class="btn" href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>与上题类似，采用回溯法，注意这里没说不能进入曾经进入过的格子，但是由于是计算能走的格子数，每次进入一个新格子，自然就会尝试下一步所有能走的可能，因此不必再进入曾经进入过的格子，减少计算量，避免栈溢出。可以发现，若可以进入曾经进入过的格子，那么下面的代码会陷入死循环，不停的往下走再往上走回来，造成栈溢出。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span></span>&#123;    <span class="hljs-keyword">if</span>(threshold &lt; <span class="hljs-number">0</span> || rows &lt; <span class="hljs-number">0</span> || cols &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">boolean</span>[][] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];    move(marked, threshold, rows, cols, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> cnt;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[][] marked, <span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>&#123;    <span class="hljs-keyword">if</span>(col &lt; <span class="hljs-number">0</span> || col &gt;= cols || row &lt; <span class="hljs-number">0</span> || row &gt;= rows || marked[row][col] == <span class="hljs-keyword">true</span> || calSum(row, col) &gt; threshold)&#123;        <span class="hljs-keyword">return</span>;    &#125;    cnt++;    marked[row][col] = <span class="hljs-keyword">true</span>;    move(marked, threshold, rows, cols, row - <span class="hljs-number">1</span>, col);    move(marked, threshold, rows, cols, row + <span class="hljs-number">1</span>, col);    move(marked, threshold, rows, cols, row, col - <span class="hljs-number">1</span>);    move(marked, threshold, rows, cols, row, col + <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(row % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>)&#123;        sum = sum + row % <span class="hljs-number">10</span>;        row = row / <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">while</span>(col % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>)&#123;        sum = sum + col % <span class="hljs-number">10</span>;        col = col / <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> sum;</code></pre></div><h3 id="14-剪绳子"><a class="markdownIt-Anchor" href="#14-剪绳子"></a> 14、剪绳子</h3><div class="note note-danger">            <p>题目：<br></p><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。注意：绳子也是按照整数进行裁剪的。</p><p><a class="btn" href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>动态规划法。</li><li>贪婪算法。根据数学推导可得，当绳子长度大于等于 5 时，应尽可能剪更多长度为 3 的绳子。当绳子长度小于等于 4 时，剪成两段长度为 2 的绳子。</li></ol>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><span class="hljs-comment">   *动态规划法</span><span class="hljs-comment">   */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;       <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">2</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">3</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;       &#125;       <span class="hljs-keyword">int</span>[] profit = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];       profit[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;       profit[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;       profit[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;       profit[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;       <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= target; i++)&#123;           max = <span class="hljs-number">0</span>;           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)&#123;               <span class="hljs-keyword">if</span>(max &lt; profit[j] * profit[i - j])&#123;                   max = profit[j] * profit[i - j];               &#125;           &#125;           profit[i] = max;       &#125;       <span class="hljs-keyword">return</span> profit[target];   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*贪婪算法</span><span class="hljs-comment">*/</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;       <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">2</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">3</span>)&#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;       &#125;       <span class="hljs-keyword">int</span> num_3 = target / <span class="hljs-number">3</span>;       <span class="hljs-keyword">if</span>(target % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;           num_3--;           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">2</span> * (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, num_3);       &#125;       <span class="hljs-keyword">return</span> ((target % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>) * (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, num_3);   &#125;</code></pre></div><h3 id="15-二进制中-1-的个数"><a class="markdownIt-Anchor" href="#15-二进制中-1-的个数"></a> 15、二进制中 1 的个数</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个整数，输出该数二进制表示中 1 的个数。</p><p><a class="btn" href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>借助初始值为 1 的辅助数字，辅助数字不断左移 1 位，进而从该数字的最低位开始一次判断该位是否为 1。数字有多少位就要循环多少次。</p></li><li><p>把一个数字减去 1 ，它的二进制表达中，最右边的 1 会变为 0，在这之右的 0 会变成 1，在这之左的位不会发生改变。因此，将一个数字与该数字减一的结果进行与操作，会使得原数字最右边的 1 变为 0，其余无变化。不断循环该操作，就能找出数字二进制表达式中 1 的个数。这种方法更快速。</p></li></ol><p>More：除法的效率会比位移操作低很多，在实际当中可以用移位运算符代替乘除法；Integer.bitCount(n)。<br></p><p>相关题目：<br></p><ol><li>用一条语句判断一个整数是不是 2 的整数次方。如果一个数字是 2 的整数次方，那么它的二进制表示中只有一个 1 ，可以用前面的办法：因此，将一个数字与该数字减一的结果进行一次与操作，如果是的话，那么结果为 0。</li><li>输入两个整数 m 和 n，计算需要改变 m 的二进制中几位才能得到 n。将 m 与 n 异或处理，再计算得到的数字中 1 的个数。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*方法1</span><span class="hljs-comment">*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">int</span> helper = <span class="hljs-number">1</span>;       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(helper != <span class="hljs-number">0</span>)&#123;           <span class="hljs-keyword">if</span>((n &amp; helper) != <span class="hljs-number">0</span>)&#123;               count++;           &#125;           helper = helper &lt;&lt; <span class="hljs-number">1</span>;       &#125;       <span class="hljs-keyword">return</span> count;   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*方法2</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;           count++;           n = n &amp; (n - <span class="hljs-number">1</span>);       &#125;       <span class="hljs-keyword">return</span> count;   &#125;</code></pre></div><h2 id="第三章-高质量的代码"><a class="markdownIt-Anchor" href="#第三章-高质量的代码"></a> 第三章 高质量的代码</h2><h3 id="16-数值的整数次方"><a class="markdownIt-Anchor" href="#16-数值的整数次方"></a> 16、数值的整数次方</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。保证base和exponent不同时为0。</p><p><a class="btn" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>该题首要的应该考虑一些特殊情况，如 exponent 是负数，则应将它化为整数后正常求次方，再将最后的结果求导数。但这时如果 base 是 0，那么求倒数会使得程序出错，这些都应考虑在内。再就是优化代码时间复杂度，按照正常的思路，是循环 exponent  - 1 次乘法，但还可以优化。若求一个数的 32 次方，则可以由它的 16 次方平方得到，而 16 次方可以由 8次方平方得到，8 次方可以由 4次方的平方得到…注意，下面的代码中，用右移运算符代替除以 2，用位与运算符代替用 % 判断一个数是否是奇数，以提高程序效率。</p>          </div><div class="hljs"><pre><code class="hljs JAVA">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;      <span class="hljs-keyword">double</span> res;      <span class="hljs-keyword">if</span>(base == <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;      <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / calPower(base, -exponent);      &#125;<span class="hljs-keyword">else</span>&#123;          <span class="hljs-keyword">return</span> calPower(base, exponent);      &#125;&#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calPower</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span></span>&#123;      <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">0</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">1</span>)&#123;          <span class="hljs-keyword">return</span> base;      &#125;      <span class="hljs-keyword">double</span> res = calPower(base, exponent &gt;&gt; <span class="hljs-number">1</span>);      res = res * res;      <span class="hljs-keyword">if</span>((exponent &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123;          res = res * base;      &#125;      <span class="hljs-keyword">return</span> res;  &#125;</code></pre></div><h3 id="17-打印从-1-到最大的-n-位数"><a class="markdownIt-Anchor" href="#17-打印从-1-到最大的-n-位数"></a> 17、打印从 1 到最大的 n 位数</h3><div class="note note-danger">            <p>题目：<br></p><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。本题代码自己测试即可。</p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>首先考虑不正常的输入情况，如输入的数字小于等于 0，是非法输入。再就是输入的数字如果比较大，那么要打印的数字可能超过 int 范围，甚至也可能超过 long 范围，因此可用 char 数组来表示数字。首先考虑打印方法，输入一个 char 数组，打印出数字，但是数字最前面的 0 不应该打出来，如 098 应打印为 98。</p><ol><li><p>不停的在末位加 1，然后做进位处理得到对应的 char 数组，再打印。直至最高位出现了进位，停止循环。这样的代码比较长。</p></li><li><p>该问题实际上是 n 位数字从 0~9 的全排列，因此可用递归方法，全排列出所有可能。</p></li></ol><p>采用第二种思路演示。<br></p><p>相关题目（如果题目是 n 位整数而又没有限定 n 的取值范围，这时应考虑大数问题，可用字符串处理）<br></p><ol><li>本题中用 char 数组未充分利用内存，一位 char 能表示 256 个字符，而我们只用到了 0~9。有没有更高效的方式表示大数。（bitmap）</li><li>定义一个函数，实现任意两个整数的加法。这也是大数问题，还要考虑数字有负数该怎么办。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print1ToMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span></span>&#123;        <span class="hljs-keyword">if</span>(length &lt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;                c[i] = <span class="hljs-string">'0'</span>;            &#125;            print1ToMaxRecursively(c, length, <span class="hljs-number">0</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print1ToMaxRecursively</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] c, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> index)</span></span>&#123;        <span class="hljs-keyword">if</span>(index == length)&#123;            printNum(c);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;            c[index] = (<span class="hljs-keyword">char</span>)(i+<span class="hljs-number">48</span>);            print1ToMaxRecursively(c, length, index + <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] c)</span></span>&#123;        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++)&#123;            <span class="hljs-keyword">if</span>(c[i] != <span class="hljs-string">'0'</span> &amp;&amp; flag == <span class="hljs-keyword">false</span>)&#123;                flag = <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-keyword">if</span>(flag)&#123;                System.out.print(c[i]);            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            System.out.println();        &#125;    &#125;</code></pre></div><h3 id="181-在o1时间内删除链表节点"><a class="markdownIt-Anchor" href="#181-在o1时间内删除链表节点"></a> 18.1、在O(1)时间内删除链表节点</h3><div class="note note-danger">            <p>题目：<br></p><p>给定单向链表的头指针和一个节点指针，删除该节点指针。</p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>正常的思路是从头开始找到这个节点的前一个节点，让该节点的 next 指向待删除节点的下一个节点。但是题目要求时间复杂度为O(n)，可以直接将待删除节点的下一个节点的内容复制到待删除节点上。需要考虑一些特殊情况。注意这里没说被删除节点一定在该链表中，但是判断一个节点是否在链表中，需要O(n)时间复杂度，题目只允许O(1)，因此这里假设输入的被删除节点都在链表中。</p><ol><li>输入为 null；</li><li>链表只有一个节点，删除该节点；</li><li>链表不只有一个节点，删除尾节点，这时还是要循环找到需要的节点。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || tobeDelete == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">if</span>(tobeDelete.next != <span class="hljs-keyword">null</span>)&#123;        tobeDelete.val = tobeDelete.next.val;        tobeDelete.next = tobeDelete.next.next;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;        head = <span class="hljs-keyword">null</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        ListNode temp = head;        <span class="hljs-keyword">while</span>(temp.next != tobeDelete)&#123;            temp = temp.next;        &#125;        temp.next = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">return</span> head;&#125;</code></pre></div><h3 id="182-删除链表中重复的节点"><a class="markdownIt-Anchor" href="#182-删除链表中重复的节点"></a> 18.2、删除链表中重复的节点</h3><div class="note note-danger">            <p>题目：<br></p><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p><p><a class="btn" href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>双指针法。注意需要先把头节点处理完全，再处理头节点之后的节点。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode pHead)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span> || pHead.next == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> pHead;    &#125;    <span class="hljs-keyword">while</span>(pHead.next != <span class="hljs-keyword">null</span> &amp;&amp; pHead.val == pHead.next.val)&#123;        <span class="hljs-keyword">while</span>(pHead.next != <span class="hljs-keyword">null</span> &amp;&amp; pHead.val == pHead.next.val)&#123;            pHead = pHead.next;        &#125;        <span class="hljs-keyword">if</span>(pHead.next == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        pHead = pHead.next;    &#125;    ListNode preNode = pHead;    ListNode temp = pHead.next;    <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; temp.next != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span>(temp.next != <span class="hljs-keyword">null</span> &amp;&amp; temp.val == temp.next.val)&#123;            <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span> &amp;&amp; temp.val == temp.next.val)&#123;                temp = temp.next;            &#125;            preNode.next = temp.next;            temp = temp.next;        &#125;<span class="hljs-keyword">else</span>&#123;            temp = temp.next;            preNode = preNode.next;         &#125;    &#125;    <span class="hljs-keyword">return</span> pHead;&#125;</code></pre></div><h3 id="19-正则表达式匹配"><a class="markdownIt-Anchor" href="#19-正则表达式匹配"></a> 19、正则表达式匹配</h3><div class="note note-danger">            <p>题目：<br></p><p>请实现一个函数用来匹配包括 ‘.’ 和 ‘*’ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而 ’ * ’ 表示它前面的字符可以出现任意次（包含 0 次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab<em>ac</em>a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>本题采用动态规划法。 dp[ i+1 ] [ j+1 ]表示字符串中第 1~i 个字符是否与模式中第 1~j 个字符相匹配。</p><ol><li>若 p.charAt( j ) 为 ‘ . ’ 或者与 s.charAt( i ) 相等，那么dp[ i+1 ] [ j+1 ] = dp[ i ] [ j ]；</li><li>若 p.charAt( j ) 为 ‘ * ’：若p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != ‘.’，则 <code>x*</code>应相当于为空；p 的当前字符的前一个字符能与 s 当前字符匹配上，则有三种情况：1.<code>x*</code>相当于一个字符。2.<code>x*</code>相当于多个字符。3.<code>x*</code>相当于空。</li><li>注意需要初始化以及防止数组索引小于0。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || p == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>][p.length() + <span class="hljs-number">1</span>];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; p.length(); i++)&#123; <span class="hljs-comment">//"aab"  "c*a*b"</span>        <span class="hljs-keyword">if</span>(p.charAt(i) == <span class="hljs-string">'*'</span> &amp;&amp; dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>])&#123;            dp[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p.length(); j++)&#123;            <span class="hljs-keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">'.'</span>)&#123;                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j];            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p.charAt(j) == <span class="hljs-string">'*'</span>)&#123;                <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="hljs-number">1</span>) != <span class="hljs-string">'.'</span>)&#123;                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];                &#125;<span class="hljs-keyword">else</span>&#123;                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = (dp[i + <span class="hljs-number">1</span>][j] || dp[i][j + <span class="hljs-number">1</span>] || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[s.length()][p.length()];&#125;</code></pre></div><h3 id="20-表示数值的字符串"><a class="markdownIt-Anchor" href="#20-表示数值的字符串"></a> 20、表示数值的字符串</h3><div class="note note-danger">            <p>题目：<br></p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</p><p><a class="btn" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>这个情况很复杂，一个一个讨论，看代码的注释即可。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-comment">//跳过字符串最开始的空格</span>    <span class="hljs-keyword">while</span>(index &lt; s.length() &amp;&amp; s.charAt(index) == <span class="hljs-string">' '</span>)&#123;        index++;    &#125;    <span class="hljs-comment">//如果只有空格，false</span>    <span class="hljs-keyword">if</span>(index == s.length())&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">// dot小数的个数，num数字的个数，e指数符号的个数</span>    <span class="hljs-keyword">int</span> dot = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;    <span class="hljs-comment">//出现正负号，它们的后面一个不能再是正负号，不能后面无元素</span>    <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>)&#123;        index++;        <span class="hljs-keyword">if</span>(index == s.length())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span>(index &lt; s.length())&#123;        <span class="hljs-keyword">if</span>(s.charAt(index) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s.charAt(index) &lt;= <span class="hljs-string">'9'</span>)&#123;            num++;            index++;            <span class="hljs-comment">//出现小数点，只能有一个小数点，且在这之前不能有e</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'.'</span>)&#123;            <span class="hljs-keyword">if</span>(dot &gt; <span class="hljs-number">0</span> || e &gt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">//防止“.”这种现象发生</span>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span> &amp;&amp; ((index + <span class="hljs-number">1</span>) == s.length() || s.charAt(index + <span class="hljs-number">1</span>) &lt; <span class="hljs-string">'0'</span> || s.charAt(index + <span class="hljs-number">1</span>) &gt; <span class="hljs-string">'9'</span>))&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            dot++;            index++;            <span class="hljs-comment">//出现e，e的前面不能不出现数字，且只能出现一次e，e的后面如果是正负号，需要像上面一样判断，如果e的后面无元素，即无元素或者是空格，也是不行的</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'e'</span> || s.charAt(index) == <span class="hljs-string">'E'</span>)&#123;            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span> || e &gt; <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            e++;            index++;            <span class="hljs-keyword">if</span>(index &lt; s.length() &amp;&amp; (s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>))&#123;                index++;                <span class="hljs-keyword">if</span>(index == s.length())&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;                <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;            &#125;            <span class="hljs-keyword">if</span>(index == s.length() || s.charAt(index) == <span class="hljs-string">' '</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-comment">//去掉结尾的空格</span>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">' '</span>)&#123;            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">while</span>(index &lt; s.length())&#123;                <span class="hljs-keyword">if</span>(s.charAt(index) != <span class="hljs-string">' '</span>)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                &#125;                index++;            &#125;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></div><h3 id="21-调整数组使奇数在偶数前"><a class="markdownIt-Anchor" href="#21-调整数组使奇数在偶数前"></a> 21、调整数组使奇数在偶数前</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><a class="btn" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>采用双指针，一个指向数组头，一个指向数组尾，向中间递进。若第一个指针发现偶数，第二个指针发现奇数，则调换它们的顺序。还可采用冒泡法，或者复制一个数组，先将数组奇偶个数求出来，再遍历数组将每个数字放到合适的类别中。注意，这里书中提到可以增加程序的扩展性，即未来不只是分开奇偶数，也可以有别的功能，这可以将判断函数加入进形参中，这样就增加了程序的扩展性。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> nums;    &#125;    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(begin &lt; end)&#123;        <span class="hljs-keyword">while</span>(end &gt; begin &amp;&amp; (nums[end] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;            end--;        &#125;        <span class="hljs-keyword">while</span>(end &gt; begin  &amp;&amp; (nums[begin] &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123;            begin++;        &#125;        <span class="hljs-keyword">int</span> temp = nums[begin];        nums[begin] = nums[end];        nums[end] = temp;    &#125;    <span class="hljs-keyword">return</span> nums;&#125;</code></pre></div><h3 id="22-链表中倒数第-k-个节点"><a class="markdownIt-Anchor" href="#22-链表中倒数第-k-个节点"></a> 22、链表中倒数第 k 个节点</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><a class="btn" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>首先需要辨明边界条件， k 小于等于0，k 超过链表个数，输入头节点为 null。</p><ol><li><p>第一种方法是循环链表两次，第一次计算数链表的长度，第二次找到目标节点，这样效率较低。</p></li><li><p>第二种方法更好，先让一个指针从头节点往前走 k - 1 步，再新建一个指针指向头节点，让这两个指针同步再往前走，这样两个指针相距 k - 1，第一个指针走到末尾时，第二个指针指向的就是目标节点。</p></li></ol><p>相关题目：当我们用一个指针遍历链表不能完成任务时，可以尝试用两个指针。<br></p><ol><li>求链表的中间节点。可以定义两个指针，同时从链表头出发，一个指针每次走两步，一个指针每次走一步。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || k &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    ListNode begin  = head;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)&#123;        <span class="hljs-keyword">if</span>(begin != <span class="hljs-keyword">null</span>)&#123;            begin = begin.next;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    ListNode target = head;    <span class="hljs-keyword">while</span>(begin.next != <span class="hljs-keyword">null</span>)&#123;        begin = begin.next;        target = target.next;    &#125;    <span class="hljs-keyword">return</span> target;&#125;</code></pre></div><h3 id="23-链表中环的入口节点"><a class="markdownIt-Anchor" href="#23-链表中环的入口节点"></a> 23、链表中环的入口节点</h3><div class="note note-danger">            <p>题目：<br></p><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><p><a class="btn" href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking"  target="_blank">牛客网：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>双指针，都从头节点出发，一个每次走两步，一个每次走一步。快的指针若遇见 null，则链表中无环，若两指针相遇，则链表中有环。</p><ol><li>相遇节点处，得到相遇节点，通过该节点可以得到环的长度。再初始化两个指针，从头节点开始，一个节点先走环的长度的步数。从这之后，两个指针每次走 1 步，它们的相遇节点即为环入口节点。</li><li>相遇节点处，得到相遇节点。将快的指针重置为头节点，让两个指针每次走一步，两指针相遇节点即为环入口节点。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode pHead)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    ListNode p1 = pHead; <span class="hljs-comment">//快的指针</span>    ListNode p2 = pHead; <span class="hljs-comment">//慢的指针</span>    <span class="hljs-keyword">while</span>(p1 != <span class="hljs-keyword">null</span> &amp;&amp; p1.next !=<span class="hljs-keyword">null</span>)&#123;        p1 = p1.next.next;        p2 = p2.next;        <span class="hljs-keyword">if</span>(p1 == p2)&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(p1 == <span class="hljs-keyword">null</span> || p1.next == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        p1 = pHead;        <span class="hljs-keyword">while</span>(p1 != p2)&#123;            p1 = p1.next;            p2 = p2.next;        &#125;    &#125;    <span class="hljs-keyword">return</span> p1;&#125;</code></pre></div><h3 id="24-反转链表"><a class="markdownIt-Anchor" href="#24-反转链表"></a> 24、反转链表</h3><div class="note note-danger">            <p>题目：<br></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><a class="btn" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>注意边界条件。</p><ol><li>头插法。</li><li>递归法。</li><li>压栈法。</li><li>三指针法。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*递归法</span><span class="hljs-comment">*/</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;       <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> head;       &#125;       ListNode node = head.next;       head.next = <span class="hljs-keyword">null</span>;       ListNode newList = reverseList(node);       node.next = head;       <span class="hljs-keyword">return</span> newList;   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*头插法</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;       <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> head;       &#125;       ListNode newList = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);       ListNode tempOriginal = head;       ListNode temp = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">while</span>(tempOriginal != <span class="hljs-keyword">null</span>)&#123;           temp = tempOriginal.next;           tempOriginal.next = newList.next;           newList.next = tempOriginal;           tempOriginal = temp;       &#125;       <span class="hljs-keyword">return</span> newList.next;   &#125;</code></pre></div><h3 id="25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#25-合并两个排序的链表"></a> 25、合并两个排序的链表</h3><div class="note note-danger">            <p>题目：<br></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><a class="btn" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>递归法。</li><li>迭代法。</li></ol>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><span class="hljs-comment">   *递归法</span><span class="hljs-comment">   */</span><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;       <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> l2;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">return</span> l1;       &#125;       ListNode newHead= <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;           newHead = l1;           newHead.next = mergeTwoLists(l1.next, l2);       &#125;<span class="hljs-keyword">else</span>&#123;           newHead = l2;           newHead.next = mergeTwoLists(l1, l2.next);       &#125;       <span class="hljs-keyword">return</span> newHead;   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*迭代法，注意这里边界条件在后面也做了一次判断，因此不需要在开头进行边界条件的判断</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;       ListNode newHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);       ListNode temp = newHead;       <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;           <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;               temp.next = l1;               l1 = l1.next;           &#125;<span class="hljs-keyword">else</span>&#123;               temp.next = l2;               l2 = l2.next;           &#125;           temp = temp.next;       &#125;       <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;           temp.next = l2;       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;           temp.next = l1;       &#125;       <span class="hljs-keyword">return</span> newHead.next;   &#125;</code></pre></div><h3 id="26-树的子结构"><a class="markdownIt-Anchor" href="#26-树的子结构"></a> 26、树的子结构</h3><div class="note note-danger">            <p>题目：<br></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br /><img src="https://i.loli.net/2020/07/19/IP73Q45seH2YLKD.png" srcset="/img/loading.gif" alt="" /></p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>第一个函数不断递归寻找 A树 中节点是否有能匹配上B树 的根节点。第二个函数不断递归判断是否含有 B树 的结构。注意，B为 null说明找到了，这个要放在前面。A为 null说明有可能找不到了，放在后面。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;    <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || B == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> isSubStructure2(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure2</span><span class="hljs-params">(TreeNode A, TreeNode B)</span></span>&#123;    <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span>(A.val != B.val)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">return</span> isSubStructure2(A.left, B.left) &amp;&amp; isSubStructure2(A.right, B.right);&#125;</code></pre></div><h2 id="第四章-解决面试题的思路"><a class="markdownIt-Anchor" href="#第四章-解决面试题的思路"></a> 第四章 解决面试题的思路</h2><h3 id="27-二叉树的镜像"><a class="markdownIt-Anchor" href="#27-二叉树的镜像"></a> 27、二叉树的镜像</h3><div class="note note-danger">            <p>题目：<br></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>递归即可。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    mirrorTreeRecursively(root);    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mirrorTreeRecursively</span><span class="hljs-params">(TreeNode node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span>;    &#125;    TreeNode temp = node.left;    node.left = node.right;    node.right = temp;    mirrorTreeRecursively(node.left);    mirrorTreeRecursively(node.right);&#125;</code></pre></div><h3 id="28-对称的二叉树"><a class="markdownIt-Anchor" href="#28-对称的二叉树"></a> 28、对称的二叉树</h3><div class="note note-danger">            <p>题目：<br></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><a class="btn" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>一个树是对称的，那么它的 根-左-右 遍历节点应该与它的 根-右-左 遍历节点完全一样，注意也需要把遍历到的 null 考虑进去。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">return</span> isSymmetric(root, root);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode node1, TreeNode node2)</span></span>&#123;    <span class="hljs-keyword">if</span>(node1 == <span class="hljs-keyword">null</span> &amp;&amp; node2 == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span>(node1 == <span class="hljs-keyword">null</span> || node2 == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span>(node1.val == node2.val)&#123;        <span class="hljs-keyword">return</span> isSymmetric(node1.left, node2.right) &amp;&amp; isSymmetric(node1.right, node2.left);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre></div><h3 id="29-顺时针打印矩阵"><a class="markdownIt-Anchor" href="#29-顺时针打印矩阵"></a> 29、顺时针打印矩阵</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>定义四个索引，分别为：起始行，终点行，起始列，终点列。在循环中：</p><ol><li>在起始行，从起点列遍历至终点列，相当于从左到右，完成后起始行加一，若起始行大于终点行，则完成任务；</li><li>在终点列，从起始行遍历至终点行，想当于从上到下，完成后终点列减一，若终点列小于起点列，则完成任务；</li><li>在终点行，从终点列遍历至起点列，相当于从右到左，完成后终点行减一，若终点行小于起点行，则完成任务；</li><li>在起点列，从终点行遍历至起点行，相当于从下到上，完成后起点列加一，若起点列大于终点列，则完成任务。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;    <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">int</span> row = matrix.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(row + <span class="hljs-number">1</span>) * (col + <span class="hljs-number">1</span>)];    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = c; i &lt;= col; i++)&#123;            array[index] = matrix[r][i];            index++;        &#125;        <span class="hljs-keyword">if</span>(++r &gt; row)&#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &lt;= row; i++)&#123;            array[index] = matrix[i][col];            index++;        &#125;        <span class="hljs-keyword">if</span>(--col &lt; c)&#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = col; i &gt;= c; i--)&#123;            array[index] = matrix[row][i];            index++;        &#125;        <span class="hljs-keyword">if</span>(--row &lt; r)&#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row; i &gt;= r; i--)&#123;            array[index] = matrix[i][c];            index++;        &#125;        <span class="hljs-keyword">if</span>(++c &gt; col)&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> array;&#125;</code></pre></div><h3 id="30-包含-min-函数的栈"><a class="markdownIt-Anchor" href="#30-包含-min-函数的栈"></a> 30、包含 min 函数的栈</h3><div class="note note-danger">            <p>题目：<br></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><a class="btn" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>最开始想的是在类中定义一个成员变量，保存栈中最小的元素。但是，如果该元素被弹出，无法更新该成员变量的值，因此这个办法行不通。在该栈中定义两个栈，一个用于保存数据，一个用于保存最小的元素，当压入数据时，判断 min 栈栈顶元素是否小于该压入元素，若小于，则 min 栈再一次压入它的栈顶元素，若大于或者 min 栈为空，则压入该元素。弹出元素时，也要将 min 栈中的元素弹出。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; data = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; min = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    data.push(x);    <span class="hljs-keyword">if</span>(min.isEmpty() || x &lt; min.peek())&#123;        min.push(x);    &#125;<span class="hljs-keyword">else</span>&#123;        min.push(min.peek());    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;    data.pop();    min.pop();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> data.peek();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> min.peek();&#125;</code></pre></div><h3 id="31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#31-栈的压入-弹出序列"></a> 31、栈的压入、弹出序列</h3><div class="note note-danger">            <p>题目：<br></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>定义一个辅助栈，如果下一个要弹出的数字刚好是栈顶元素，那么直接弹出；如果不是，那么把压栈序列剩余的数字依次压入辅助栈中，直至找到需要弹出的数字，若所有数字都压入栈中后仍然未找到该数字，那么该序列不为弹出序列。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;    <span class="hljs-keyword">if</span>(pushed == <span class="hljs-keyword">null</span> || popped == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span>((pushed.length == <span class="hljs-number">0</span> &amp;&amp; popped.length != <span class="hljs-number">0</span>) || (pushed.length != <span class="hljs-number">0</span> &amp;&amp; popped.length == <span class="hljs-number">0</span>))&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">int</span> indexPush = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> indexPop = <span class="hljs-number">0</span>;    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    <span class="hljs-keyword">while</span>(indexPop &lt; popped.length)&#123;        <span class="hljs-keyword">while</span>(stack.isEmpty() || stack.peek() != popped[indexPop])&#123;            <span class="hljs-keyword">if</span>(indexPush &gt;= pushed.length)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            stack.push(pushed[indexPush++]);        &#125;        stack.pop();        indexPop++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre></div><h3 id="321-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#321-从上到下打印二叉树"></a> 32.1、从上到下打印二叉树</h3><div class="note note-danger">            <p>题目：<br></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><a class="btn" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>将节点保存到容器中。每经过一个节点，弹出容器中的该节点，并将该节点的左右子节点保存到该容器尾巴处。遍历该容器。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    queue.add(root);    arrayList.add(root.val);    <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;        TreeNode treeNode = queue.poll();        <span class="hljs-keyword">if</span>(treeNode.left != <span class="hljs-keyword">null</span>)&#123;            queue.add(treeNode.left);            arrayList.add(treeNode.left.val);        &#125;        <span class="hljs-keyword">if</span>(treeNode.right != <span class="hljs-keyword">null</span>)&#123;            queue.add(treeNode.right);            arrayList.add(treeNode.right.val);        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arrayList.size()];    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(Integer i : arrayList)&#123;        res[index++] = i;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="322-分行从上到下打印二叉树"><a class="markdownIt-Anchor" href="#322-分行从上到下打印二叉树"></a> 32.2 分行从上到下打印二叉树</h3><div class="note note-danger">            <p>题目：<br></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><a class="btn" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>将节点保存到容器中。每经过一个节点，弹出容器中的该节点，并将该节点的左右子节点保存到该容器尾巴处。遍历该容器。同时定义两个变量，分别记录本层节点数以及下层节点数。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();    &#125;    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    queue.add(root);    <span class="hljs-keyword">int</span> now = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;    List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;Integer&gt; listTemp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    listTemp.add(root.val);    list.add(listTemp);    <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;        listTemp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">while</span>(now != <span class="hljs-number">0</span>)&#123;            TreeNode node = queue.poll();            now--;            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;                queue.add(node.left);                listTemp.add(node.left.val);                next++;            &#125;            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;                queue.add(node.right);                listTemp.add(node.right.val);                next++;            &#125;        &#125;        <span class="hljs-keyword">if</span>(next != <span class="hljs-number">0</span>)&#123;            list.add(listTemp);            now = next;            next = <span class="hljs-number">0</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><h3 id="323-之字形打印二叉树"><a class="markdownIt-Anchor" href="#323-之字形打印二叉树"></a> 32.3 之字形打印二叉树</h3><div class="note note-danger">            <p>题目：<br></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><a class="btn" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>这里每一行都得从尾部开始寻找它的字节点，因此可用栈结构。</li><li>参考题解，代码更简洁。用 res 中的元素个数能够判断处在奇数行还是偶数行；用双端链表加上反转方法，能够大大化简操作。在 for 循环中，初始化 i 的值为 size，这样虽然在循环中 size 不断在变化，但是这个循环次数还是恒定的。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();    &#125;    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    list.add(root.val);    res.add(list);    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();    stack.push(root);    Stack&lt;TreeNode&gt; stackNext = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">int</span> now = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(stack.size() != <span class="hljs-number">0</span>)&#123;        list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        stackNext = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">while</span>(now != <span class="hljs-number">0</span>)&#123;            TreeNode node = stack.pop();            now--;            <span class="hljs-keyword">if</span>(flag)&#123;                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;                    stackNext.push(node.right);                    list.add(node.right.val);                    next++;                &#125;                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;                    stackNext.push(node.left);                    list.add(node.left.val);                    next++;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;                    stackNext.push(node.left);                    list.add(node.left.val);                    next++;                &#125;                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;                    stackNext.push(node.right);                    list.add(node.right.val);                    next++;                &#125;            &#125;        &#125;        flag = !flag;        <span class="hljs-keyword">if</span>(next != <span class="hljs-number">0</span>)&#123;            now = next;            next = <span class="hljs-number">0</span>;            res.add(list);            stack = stackNext;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#33-二叉搜索树的后序遍历序列"></a> 33、二叉搜索树的后序遍历序列</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>二叉搜索树的后序遍历序列，最后一个元素是根节点，最左边开始，遍历，比根节点小的元素是根节点的左子树，直至遇到一个比根节点大的元素，该元素包括该元素后面的元素应该都比根节点大且是根节点的右子树。这样递归查找是否满足该要求。</p><p>More：<br></p><p>处理一个二叉树的遍历序列，可以找到二叉树的根节点，再基于根节点将序列拆分为左子树和右子树。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;    <span class="hljs-keyword">if</span>(postorder == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span>(postorder.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">return</span> verifyPostorderRecu(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorderRecu</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(begin &gt;= end)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">int</span> temp = begin;    <span class="hljs-keyword">if</span>(postorder[temp] &lt; postorder[end])&#123;        <span class="hljs-keyword">while</span>(postorder[temp] &lt; postorder[end])&#123;            temp++;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = temp; i &lt; end; i++)&#123;            <span class="hljs-keyword">if</span>(postorder[i] &lt; postorder[end])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> verifyPostorderRecu(postorder, begin, temp - <span class="hljs-number">1</span>) &amp;&amp; verifyPostorderRecu(postorder, temp, end - <span class="hljs-number">1</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = temp; i &lt; end; i++)&#123;            <span class="hljs-keyword">if</span>(postorder[i] &lt; postorder[end])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> verifyPostorderRecu(postorder, temp, end - <span class="hljs-number">1</span>);    &#125;&#125;</code></pre></div><h3 id="34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#34-二叉树中和为某一值的路径"></a> 34、二叉树中和为某一值的路径</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>采用递归法。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> res;    &#125;    pathSumRecu(root, sum, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pathSumRecu</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; temp)</span></span>&#123;    sum = sum - node.val;    temp.add(node.val);    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>)&#123;        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(temp));    &#125;    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;        pathSumRecu(node.left, sum, temp);    &#125;    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;        pathSumRecu(node.right, sum, temp);    &#125;    temp.remove(temp.size() - <span class="hljs-number">1</span>);&#125;</code></pre></div><h3 id="35-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#35-二叉搜索树与双向链表"></a> 35、二叉搜索树与双向链表</h3><div class="note note-danger">            <p>题目：<br></p><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p><a class="btn" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>可用空间换时间，利用一个 HashMap，key 为原节点，value 为复制节点，通过<code>get(node).next = get(node.next)</code>以及<code>get(node).random = get(node.random)</code>，可实现复制。</li><li>不牺牲空间，分三步。1. 将原链表 A-B-C-D 变为 A-A‘-B-B’-C-C’-D-D’，即将复制节点插入在原节点后面。2. 那么复制节点的 random 即为原节点的 random 的 next。3. 拆分出原始链表和复制链表。</li></ol>          </div><div class="hljs"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;      <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125;            <span class="hljs-comment">// 第一步 合并</span>      Node temp =head;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>)&#123;          Node tempNext = temp.next;          temp.next = <span class="hljs-keyword">new</span> Node(temp.val);          temp.next.next = tempNext;          temp = tempNext;      &#125;      <span class="hljs-comment">// 第二步 复制random</span>      temp = head;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>)&#123;          <span class="hljs-keyword">if</span>(temp.random != <span class="hljs-keyword">null</span>)&#123;              temp.next.random = temp.random.next;          &#125;<span class="hljs-keyword">else</span>&#123;              temp.next.random = <span class="hljs-keyword">null</span>;          &#125;          temp = temp.next.next;      &#125;<span class="hljs-comment">// 第三步 分离出原始链表和复制链表</span>      temp = head;      Node tempNew = head.next;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; temp.next != <span class="hljs-keyword">null</span>)&#123;          Node tempTemp = temp.next;          temp.next = temp.next.next;          temp = tempTemp;      &#125;      <span class="hljs-keyword">return</span> tempNew;  &#125;</code></pre></div><h3 id="36-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#36-二叉搜索树与双向链表"></a> 36、二叉搜索树与双向链表</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>二叉搜索树的中序遍历为从小到大排序，按照中序遍历，将前一个节点的 right 指向当前节点，将当前节点的 left 指向前一个节点；若无前一个节点，说明当前节点是头节点。最后遍历的那个节点就是最后一个节点，由于要求是循环双向链表，因此将这两个节点也连接起来。</p>          </div><div class="hljs"><pre><code class="hljs java">Node head;Node pre;<span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> root;    &#125;    dfs(root);    head.left = pre;    pre.right = head;    <span class="hljs-keyword">return</span> head;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;    <span class="hljs-keyword">if</span>(cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;    dfs(cur.left);    <span class="hljs-keyword">if</span>(pre == <span class="hljs-keyword">null</span>)&#123;        head = cur;    &#125;<span class="hljs-keyword">else</span>&#123;        pre.right = cur;        cur.left = pre;    &#125;    pre = cur;    dfs(cur.right);&#125;</code></pre></div><h3 id="37-序列化二叉树"><a class="markdownIt-Anchor" href="#37-序列化二叉树"></a> 37、序列化二叉树</h3><div class="note note-danger">            <p>题目：<br></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><a class="btn" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>树的前序遍历，从根节点开始。</p><ol><li>序列化：递归实现。</li><li>反序列化：也可以递归实现。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// Encodes a tree to a single string.</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;    &#125;    <span class="hljs-keyword">return</span> serializeRecu(root, <span class="hljs-string">""</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">serializeRecu</span><span class="hljs-params">(TreeNode node, String s)</span></span>&#123;    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> s + <span class="hljs-string">"None,"</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        s = s + node.val + <span class="hljs-string">","</span>;        s = serializeRecu(node.left, s);        s = serializeRecu(node.right, s);    &#125;    <span class="hljs-keyword">return</span> s;&#125;<span class="hljs-comment">// Decodes your encoded data to tree.</span><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">""</span>.equals(data))&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    String[] dataArray = data.split(<span class="hljs-string">","</span>);    List&lt;String&gt; data_list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(dataArray));    <span class="hljs-keyword">return</span> deserializeRecu(data_list);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">deserializeRecu</span><span class="hljs-params">(List&lt;String&gt; list)</span></span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-string">"None"</span>.equals(list.get(<span class="hljs-number">0</span>)))&#123;        list.remove(<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    TreeNode temp = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(list.get(<span class="hljs-number">0</span>)));    list.remove(<span class="hljs-number">0</span>);    temp.left = deserializeRecu(list);    temp.right = deserializeRecu(list);    <span class="hljs-keyword">return</span> temp;&#125;</code></pre></div><h3 id="38-字符串的排列"><a class="markdownIt-Anchor" href="#38-字符串的排列"></a> 38、字符串的排列</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>考虑 dfs，固定第一位（n 种）、再固定第二位(n-1 种)…。其中，有重复字符需要剪枝。<br></p><p>相关题目：<br></p><ol><li>如果不是字符串的排列，而是字符串的组合，如 “abc&quot; 的组合有 ”a“ “b” “c” “ab” “ac” “bc”。这里方法和该题可以一样，不需要交换顺序，以组合的长度进行循环，第一位从起点到 length - 组合长度 + 0，第 n 位从起点到 length - 组合长度 + n - 1。也需要剪枝。</li><li>输入一个含有 8 个数字的数字，将它们放在正方体的 8 个顶点上，判断能否使得正方体上三组相对面上的 4 个顶点和相等。这题就是得到这 8 个数字的排列情况，判断有没有一个排列满足 a1 + a2 + a3 + a4 = a5 + a6 + a7 + a8 且 a1 + a3 + a5 + a7 = a2 + a4 + a6 + a8 且 a1 + a2 + a5 + a6 = a3 + a4 + a7 + a8。</li><li>八皇后问题。</li><li>如果题目是按照一定要求摆放若干数字，则可以先求出这些数字的所有排列，然后再进一步看是否满足要求。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] c;List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">public</span> String[] permutation(String s) &#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    c = s.toCharArray();    dfs(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> String[list.size()]);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;    <span class="hljs-keyword">if</span>(index == c.length - <span class="hljs-number">1</span>)&#123;        list.add(String.valueOf(c));    &#125;    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index; i &lt; c.length; i++)&#123;        <span class="hljs-keyword">if</span>(set.contains(c[i]))&#123;            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 剪枝</span>        &#125;        set.add(c[i]);        swap(index, i);        dfs(index + <span class="hljs-number">1</span>);        swap(index, i);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">char</span> temp = c[a];    c[a] = c[b];    c[b] = temp;&#125;</code></pre></div><h2 id="第五章-优化时间和空间效率"><a class="markdownIt-Anchor" href="#第五章-优化时间和空间效率"></a> 第五章 优化时间和空间效率</h2><h3 id="39-数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#39-数组中出现次数超过一半的数字"></a> 39、数组中出现次数超过一半的数字</h3><div class="note note-danger">            <p>题目：<br></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>注意，这里假设了数组一定存在一个数字出现次数超过数组长度的一半。</p><ol><li><p>摩尔投票法。众数票加一，非众数票减一。时间复杂度O(N)，空间复杂度O(1)；遍历数组，若当前数字与记录的数字相同，则加一；若不同，则减一。次数到零后，记录数字更换为当前数字。</p></li><li><p>HashMap法。用HashMap统计各数字数量。时间复杂度O(N)，空间复杂度O(N)；</p></li><li><p>数组排序法。排序后，众数一定在数组中间。采用特殊排序算法，时间复杂度O(N)，空间复杂度O(1)。借用快排的思想，选取一个数字，调整数组使得该数字左边的数字都比该数字小，该数字右边的数字都比该数字大。若该数字刚好在 n/2 的位置上，则该数字即为要找到数字。若它的下标小于 n/2，那么递归进入该数字右边进行寻找；若它的下标大于 n/2，那么递归进入该数字左边进行寻找。</p></li></ol><p>给出的示例为摩尔投票法。注意，书上没说数字一定是正常的且一定有这样的数字，因此，对于树上的题目，需要判断异常情况。1. 数组为空。2. 数组中出现最多次数的数字出现的次数不到数组长度的一半，也就是用上面的方法找到数字后，再遍历数字计算这个数字出现的次数，判断是否满足要求。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)  target = num;        count += target == num ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> target;&#125;</code></pre></div><h3 id="40-最小的-k-个数"><a class="markdownIt-Anchor" href="#40-最小的-k-个数"></a> 40、最小的 k 个数</h3><div class="note note-danger">            <p>题目：<br></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>直接排序。时间复杂度O(NlogN)</p></li><li><p>利用最大堆。遍历数组，若最大堆中元素个数不足 k 个，则将该数组数字加入最大堆中；若元素个数已达 k 个，判断最大堆中最大的数字是否小于该数字，若小于，则不处理；若大于，则删除最大堆的这个数字，将数组中的数字插入进去。这个时间复杂度为O(Nlogk)。这个优点是不会改变数组结构。</p></li><li><p>数组排序法。排序后，众数一定在数组中间。采用特殊排序算法，时间复杂度O(N)，空间复杂度O(1)。借用快排的思想，选取一个数字，调整数组使得该数字左边的数字都比该数字小，该数字右边的数字都比该数字大。若该数字刚好在 k - 1 的位置上，则该数字即为要找到数字。若它的下标小于k - 1，那么递归进入该数字右边进行寻找；若它的下标大于 k - 1，那么递归进入该数字左边进行寻找。这个的缺点是会改变数组的结构。</p></li></ol><p>给出的示例为第三种思路。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || k &gt;= arr.length)&#123;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = arr.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> index;    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;        index = quickSortDemo(arr, begin, end);        <span class="hljs-keyword">if</span>(index == k - <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> Arrays.copyOf(arr, k);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &gt; k - <span class="hljs-number">1</span>)&#123;            end = index - <span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            begin = index + <span class="hljs-number">1</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSortDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> beginSave = begin;    <span class="hljs-keyword">int</span> temp = arr[begin];    <span class="hljs-keyword">while</span>(end &gt; begin)&#123;        <span class="hljs-keyword">while</span>(end &gt; begin &amp;&amp; arr[end] &gt; temp)   end--;        <span class="hljs-keyword">while</span>(end &gt; begin &amp;&amp; arr[begin] &lt;= temp)   begin++;        <span class="hljs-keyword">if</span>(end != begin)&#123;            <span class="hljs-keyword">int</span> temp2 = arr[begin];            arr[begin] = arr[end];            arr[end] = temp2;        &#125;    &#125;    arr[beginSave] = arr[begin];    arr[begin] = temp;    <span class="hljs-keyword">return</span> begin;&#125;</code></pre></div><h3 id="41-数据流的中位数"><a class="markdownIt-Anchor" href="#41-数据流的中位数"></a> 41、数据流的中位数</h3><div class="note note-danger">            <p>题目：<br></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ol><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ol><p><a class="btn" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>排好序的数据有这样一个特征，中位数左边的数字都比中位数右边的数字小。因此，建立两个堆。左边为最大堆，右边为最小堆。</p><ol><li>add 数据时，若两个堆中数字个数相同，则最大堆中数据个数应该增加一个。步骤为，先将该数据加入最小堆中，再将最小堆中的根节点（最小元素）弹出并加入到最大堆中；若两个堆中数字个数不相同，这时最大堆中数据个数比最小堆中数据个数多一个，则最小堆中数据个数应该增加一个。步骤为，先将该数据加入最大堆中，再将最大堆中的根节点（最大元素）弹出并加入到最小堆中。</li><li>find 数据时，若两个堆中数据个数不相同，则中位数为最大堆的根节点；若两个堆中数据个数相同，则中位数为两个堆中根节点的平均数。</li></ol>          </div><div class="hljs"><pre><code class="hljs java">Queue&lt;Integer&gt; large,small;<span class="hljs-comment">/** initialize your data structure here. */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;    large = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;( (x, y) -&gt; (y - x) );    small = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">if</span>(large.size() != small.size())&#123;        large.offer(num);        small.offer(large.poll());    &#125;<span class="hljs-keyword">else</span>&#123;        small.offer(num);        large.offer(small.poll());    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> large.size() == small.size() ? (<span class="hljs-keyword">double</span>)(large.peek() + small.peek()) / (<span class="hljs-keyword">double</span>)<span class="hljs-number">2.0</span>                                         : large.peek();&#125;</code></pre></div><h3 id="42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#42-连续子数组的最大和"></a> 42、连续子数组的最大和</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><a class="btn" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>采用动态规划法。设以索引为 i 的元素结尾的子数组的最大和为 dp[i]，那么当 dp[i - 1] &lt;= 0 时，dp[i] = data[i]；当 dp[i - 1] &gt; 0 时，dp[i] = dp[i - 1] + data[i]。最后所需结果就是 dp 中的最大值，而这里由于动态规划时，只需要上一轮的 dp 来得到这一轮的 dp，因此 dp 不需要数组来存放，空间复杂度为O(1)。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);    &#125;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> dp = res;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;        dp = dp &lt;= <span class="hljs-number">0</span> ? nums[i] : dp + nums[i];        res = dp &lt;= res ? res : dp;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="43-1~n-整数中-1-出现的次数"><a class="markdownIt-Anchor" href="#43-1~n-整数中-1-出现的次数"></a> 43、1~n 整数中 1 出现的次数</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p><a class="btn" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>将 1~n  的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</li><li>设数字是 x 位数，记第 i 位为 n(i)，那么输入的数字为 n(x) n(x-1) n(x-2) … n1。</li><li>称 n(i) 为当前位，记为 cur；</li><li>称 n(i-1) n(i-2) … n(1) 为低位，记为 low；</li><li>称 n(x) n(x-1) … n(i+1) 为高位，记为 high；</li><li>称 10^(i-1) 为位因子，记为 digit；</li><li>当 cur = 0 时，当前位为 1 的次数为 high * digit；当 cur = 1时，当前位为 1 的次数为 high * digit + low + 1；其他情况时，当前位为 1 的次数为 (high + 1) * digit。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> cur = n % <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> high = n / <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur !=<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)        res += (high * digit);        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)   res +=  (high * digit + low + <span class="hljs-number">1</span>);        <span class="hljs-keyword">else</span>                res += ((high + <span class="hljs-number">1</span>) * digit);        low += (cur * digit);        cur = high % <span class="hljs-number">10</span>;        high /= <span class="hljs-number">10</span>;        digit *= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="44-数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#44-数字序列中某一位的数字"></a> 44、数字序列中某一位的数字</h3><div class="note note-danger">            <p>题目：<br></p><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>数字为 1 位数，1 位数的数字共有 9 个，这些数字所占位数有 9 位；</li><li>数字为 2 位数，2 位数的数字共有 90 个，这些数字所占位数有 180 位；</li><li>数字为 3 位数，3 位数的数字共有 900 个，这些数字所占位数有 2700 位；</li><li>得出结论，n 位数的数字共有 9 * 10^(n - 1)，这些数字所占位数有  9 * 10^(n - 1) * n。</li><li>第一步，确定该数位所属的数字为几位数；第二步，确定出该数字；第三步，确定出该数位。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常！"</span>);    &#125;    <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;    <span class="hljs-keyword">long</span> count = <span class="hljs-number">9</span>;    <span class="hljs-keyword">while</span>(n &gt; count)&#123;        n -= count;        start *= <span class="hljs-number">10</span>;        digit++;        count = start * digit * <span class="hljs-number">9</span>;    &#125;    <span class="hljs-keyword">long</span> num = start + (n - <span class="hljs-number">1</span>) / digit;    <span class="hljs-keyword">return</span> Integer.valueOf(String.valueOf(num).charAt((n - <span class="hljs-number">1</span>) % digit) - <span class="hljs-string">'0'</span>);  <span class="hljs-comment">//注意，字符这里会转换为ASCII码，因此要 减'0'</span>&#125;</code></pre></div><h3 id="45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#45-把数组排成最小的数"></a> 45、把数组排成最小的数</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>该题需要一些证明为算法提供支撑。</p><ol><li>定义一个排序规则：设两个以字符串形式表示的数字分别为 x 和 y，这里的加号表示字符串拼接，将两个数字拼接在一起。若 x + y &gt; y + x，那么 x &gt; y；若 x + y &lt; y + x，那么 x &lt; y。这样的排序规则需要满足三个条件：自反性、对称性和传递性。这三个证明略。</li><li>将数字数组转为对应的字符串数组，然后对字符串数组按照上述的排序规则从小到大进行排序（这里演示的是快排）。将排序好的数组中的字符串从左到右拼接起来即可得到答案。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);    &#125;    String[] strs = <span class="hljs-keyword">new</span> String[nums.length];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;        strs[i] = String.valueOf(nums[i]);    &#125;    quickSort(strs, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span>(String s : strs)&#123;        res.append(s);    &#125;    <span class="hljs-keyword">return</span> res.toString();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(begin &gt;= end)&#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> i = begin;    <span class="hljs-keyword">int</span> j = end;    String tempVal = strs[begin];    <span class="hljs-keyword">while</span>(i &lt; j)&#123;        <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; (strs[j] + tempVal).compareTo(tempVal + strs[j]) &gt; <span class="hljs-number">0</span>)&#123;            j--;        &#125;        <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; (strs[i] + tempVal).compareTo(tempVal + strs[i]) &lt;=<span class="hljs-number">0</span>)&#123;            i++;        &#125;        <span class="hljs-keyword">if</span>(j != i)&#123;            String temp = strs[i];            strs[i] = strs[j];            strs[j] = temp;        &#125;    &#125;    strs[begin] = strs[i];    strs[i] = tempVal;    quickSort(strs, begin, i - <span class="hljs-number">1</span>);    quickSort(strs, i + <span class="hljs-number">1</span>, end);&#125;</code></pre></div><h3 id="46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#46-把数字翻译成字符串"></a> 46、把数字翻译成字符串</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划法。dp[i] 表示以第 i 个数字结尾的字符串的翻译方法种数。这里第一个数字不是 i = 0 而是 i = 1。从左往右和从右往左是一样的。这里用从左往右进行讲解，但代码采用从右往左的方式，以实现低空间复杂度的方法。</p><ol><li>当前数字和前一位数字组成的数，若在 10~25 之间，那么以当前数字结尾的数字，有 dp[i-1] + dp[i-2] 种翻译方式；若不在那个区间内，则有 dp[i-1] 种翻译方式。</li><li>注意到 dp 只用存两位的数据，因此 dp 只用两个整数变量存放即可，降低空间复杂度。初始化 dp[0] = dp[1] = 1。</li><li>接下来就是如何遍历数字，第一种方式是，转为字符串，顺序遍历，这样需要O(n)的空间复杂度以存放字符串。第二种方式是利用数字的求余求模运算，从右往左遍历数字。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <span class="hljs-keyword">int</span> dpNew = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> dpOld = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> tempA = num % <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> tempB = -<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;        num /= <span class="hljs-number">10</span>;        tempB = num % <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> temp = tempB * <span class="hljs-number">10</span> + tempA;        <span class="hljs-keyword">int</span> c = (temp &gt;= <span class="hljs-number">10</span> &amp;&amp; temp &lt;= <span class="hljs-number">25</span>) ? dpNew + dpOld : dpNew;        dpOld = dpNew;        dpNew = c;        tempA = tempB;    &#125;    <span class="hljs-keyword">return</span> dpNew;&#125;</code></pre></div><h3 id="47-礼物的最大价值"><a class="markdownIt-Anchor" href="#47-礼物的最大价值"></a> 47、礼物的最大价值</h3><div class="note note-danger">            <p>题目：<br></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><a class="btn" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划法。dp[i] [j] 表示到达行索引为 i、列索引为 j的格子能拿到礼物的最大价值。显然，一般情况下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><p>为降低空间复杂度，可将 dp 直接建立在输入数组中。第 0 行和第 0 列为特殊情况，需要判断，为了不在循环中进行大量的判断，可在初始化时先对第 0 行和第 0 列进行处理。<br></p><p>若不想改变原数组，也不必建立 M x N 的 dp 矩阵。注意到我们不需要当前行的前两行及之前的数据，因此只需要建立一个一维数组，长度为 N 。不断更新该数组即可。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;    <span class="hljs-keyword">if</span>(grid == <span class="hljs-keyword">null</span> || grid.length &lt;= <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常！"</span>);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;        grid[i][<span class="hljs-number">0</span>] += grid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;        grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;grid.length; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;            grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j], grid[i][j-<span class="hljs-number">1</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> grid[grid.length - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>];&#125;</code></pre></div><h3 id="48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#48-最长不含重复字符的子字符串"></a> 48、最长不含重复字符的子字符串</h3><div class="note note-danger">            <p>题目：<br></p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划法。dp[i] 表示以索引为 i 的元素为子字符串的结尾的最大长度</p><ol><li>初始化 dp[0] = 1；</li><li>若索引为 i 的元素与之前的元素没有重复，则 dp[i] = dp[i-1] + 1;若有重复，则进一步判断；</li><li>重复后，判断上一次重复的元素是否在当前得到的最大子字符串之前，也就是当前元素与它的最近重复的那个元素的距离 d 是否大于 dp[i-1]，若大于，则该重复元素不对本次规划造成影响，它在该子字符串的前面，则 dp[i] = dp[i-1] + 1；若不大于，则该重复元素就在该子字符串之中，dp[i] = d。</li><li>采用一个HashMap记录每个元素最新的索引，由于是字符，HashMap键值对数量有上限，因此空间复杂度为O(1)，时间复杂度为O(1)。因此可以用长度固定的数组带替，数组操作比hashmap快。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    HashMap&lt;Character,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-keyword">int</span> dp = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> res = dp;    hashmap.put(s.charAt(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;        <span class="hljs-keyword">char</span> temp = s.charAt(i);        <span class="hljs-keyword">if</span>(hashmap.get(temp) == <span class="hljs-keyword">null</span>)&#123;            dp++;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(i - hashmap.get(temp) &gt; dp)&#123;                dp++;            &#125;<span class="hljs-keyword">else</span>&#123;                dp = i - hashmap.get(temp);            &#125;        &#125;        res = dp &gt; res? dp : res;        hashmap.put(temp, i);    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="49-丑数"><a class="markdownIt-Anchor" href="#49-丑数"></a> 49、丑数</h3><div class="note note-danger">            <p>题目：<br></p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><a class="btn" href="https://leetcode-cn.com/problems/chou-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划。</p><ol><li>我们将前面求得的丑数记录下来，后面的丑数就是前面的丑数 2，3，5倍；</li><li>已知前面k-1个丑数，需要确定第k个丑数；</li><li>采取用三个指针的方法，p2,p3,p5</li><li>p2指向的数字下一次乘上2，p3指向的数字下一次乘上3，p5指向的数字乘上5</li><li>我们从 2p2 3p3 5p5 选取最小的一个数字，作为第k个丑数</li><li>如果  第K个丑数 == 2p2，也就是说前面0-p2个丑数*2不可能产生比第K个丑数更大的丑数了，所以p2++</li><li>p3,p5同理</li><li>返回第n个丑数</li><li>第一个丑数是 1，以 1 初始化丑数表。注意第6、7步需要用 if 而不能是 if else，因为某些丑数能有多种情况被得到，</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常！"</span>);    &#125;    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p3 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> p5 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        dp[i] = Math.min(dp[p2] * <span class="hljs-number">2</span>, Math.min(dp[p3] * <span class="hljs-number">3</span>, dp[p5] * <span class="hljs-number">5</span>));        <span class="hljs-keyword">if</span>(dp[p2] * <span class="hljs-number">2</span> == dp[i]) p2++;        <span class="hljs-keyword">if</span>(dp[p3] * <span class="hljs-number">3</span> == dp[i]) p3++;        <span class="hljs-keyword">if</span>(dp[p5] * <span class="hljs-number">5</span> == dp[i]) p5++;    &#125;    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];&#125;</code></pre></div><h3 id="501-第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#501-第一个只出现一次的字符"></a> 50.1、第一个只出现一次的字符</h3><div class="note note-danger">            <p>题目：<br></p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><a class="btn" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>第一次遍历时存放字符出现的次数，第二次遍历寻找第一次出现次数为 1  的字符。由于 s 只包含小写字母，可以用长度固定的数组来存放信息，数组操作比HashMap快。<br></p><p>More：<br></p><p>若没附加 s 只包含小写字母，则可能有中文字符等。这是可以用HashMap来存放信息。进一步的，可以采用有序哈希表 LinkedHashMap，第二轮遍历时不需要遍历原字符串，这样会有大量重复字符的遍历，而只用遍历有序哈希表，因为有序哈希表是按插入顺序排序的。<br></p><ol><li><p>输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。用数组当作哈希表，将第二个字符串的字符出现信息存入数组中。再遍历第一个字符串，每次判断该字符是否出现再第二个字符串中，时间复杂度为O(1) * O(N)。</p></li><li><p>删除字符串中重复出现的字符。如 “google” 被删除为 “gole”。这也可以用一个数组存放字符是否出现过的信息。</p></li><li><p>判断两个单词是否互为变位词，即单词字母出现的一样，每个字母出现的次数也一样。用数组实现一个哈希表，存放第一个单词每个字母出现的次数；再遍历第二个单词，每遍历一个字母就将数组对应位置的元素减一，遍历完毕后，判断数组是否全为0。</p></li></ol><p>总的来说，在一些情况下，可以用数组代替哈希表，提高时间效率。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;    <span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;        num[s.charAt(i)]++;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;        <span class="hljs-keyword">char</span> temp = s.charAt(i);        <span class="hljs-keyword">if</span>(num[temp] == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> temp;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;&#125;</code></pre></div><h3 id="502-字符流中第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#502-字符流中第一个只出现一次的字符"></a> 50.2 字符流中第一个只出现一次的字符</h3><div class="note note-danger">            <p>题目：<br></p><p>请实现一个函数，用来找出字符流中第一个只出现一次的字符。</p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>用一个数组，元素初始化为 -1，索引为字符的ASCII码，每当加入一个字符时，判断该字符位置对应的元素是否为 -1，若是，则将该字符出现的索引放入该数组对应位置中；若大于等于 0，则已出现过，将数组中该位置元素置为 -2，则不需要操作。</p>          </div><h3 id="51-数组中的逆序对"><a class="markdownIt-Anchor" href="#51-数组中的逆序对"></a> 51、数组中的逆序对</h3><div class="note note-danger">            <p>题目：<br></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>采用分治的思想，结合归并排序，若右边的数字插入原数组中，则当时左边还剩余多少个数字，就是这时的逆序对个数。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> length = nums.length;    <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]; <span class="hljs-comment">//不修改原数组</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;        copy[i] = nums[i];    &#125;    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];    <span class="hljs-keyword">return</span> mergeSort(copy, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, temp);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;    <span class="hljs-keyword">if</span>(begin == end)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> mid = begin + (end - begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">//避免出现二分法经典溢出bug</span>    <span class="hljs-keyword">int</span> count1 = mergeSort(nums, begin, mid, temp);    <span class="hljs-keyword">int</span> count2 = mergeSort(nums, mid + <span class="hljs-number">1</span>, end, temp);    <span class="hljs-keyword">int</span> count3 = merge(nums, begin, mid, end, temp);    <span class="hljs-keyword">return</span> count1 + count2 + count3;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)&#123;        temp[i] = nums[i];    &#125;    <span class="hljs-keyword">int</span> i = begin;    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = begin; k &lt;= end; k++)&#123;        <span class="hljs-keyword">if</span>(i == mid + <span class="hljs-number">1</span>)    nums[k] = temp[j++];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == end + <span class="hljs-number">1</span>)   nums[k] = temp[i++];        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i] &lt;= temp[j])   nums[k] = temp[i++];        <span class="hljs-keyword">else</span>&#123;            nums[k] = temp[j++];            count += (mid - i + <span class="hljs-number">1</span>);         &#125;    &#125;    <span class="hljs-keyword">return</span> count;&#125;</code></pre></div><h3 id="52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#52-两个链表的第一个公共节点"></a> 52、两个链表的第一个公共节点</h3><div class="note note-danger">            <p>题目：<br></p><p>输入两个链表，找出它们的第一个公共节点。</p><p><img src="https://i.loli.net/2020/07/27/rzNUm9Vw1x8McuT.png" srcset="/img/loading.gif" alt="" /></p><p><a class="btn" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>从第一个相同节点后，两个链表相同。</p><ol><li><p>将两个链表分别压入两个栈中。再从栈中同时弹出节点，直到找到最后一个相同的节点。</p></li><li><p>先分别遍历两个链表，求出两个链表长度。将较长的那个链表先往前走两个链表长度之差`的长度。之后，再同时让两个链表往前走，第一个相同节点即为要寻找的节点。</p></li><li><p>双指针法，浪漫相遇！使用两个指针，分别从两个链表头开始，向前遍历，若节点为null，则转到另一个链表头重新开始，直到两个链表节点相同。这个解法很秀。摘一些有趣的评论~</p></li></ol><div class="hljs"><pre><code class="hljs erlang">两个链表长度分别为L1+C、L2+C，C为公共部分的长度。第一个人走了L1+C步后，回到第二个人起点走L2步；第二个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了。你变成我，走过我走过的路。我变成你，走过你走过的路。然后我们便相遇了...</code></pre></div>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法2</span><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;           <span class="hljs-keyword">int</span> countA = <span class="hljs-number">0</span>;           <span class="hljs-keyword">int</span> countB = <span class="hljs-number">0</span>;           ListNode tempA = headA;           ListNode tempB = headB;           <span class="hljs-keyword">while</span>(tempA != <span class="hljs-keyword">null</span>)&#123;               tempA = tempA.next;               countA++;           &#125;           <span class="hljs-keyword">while</span>(tempB != <span class="hljs-keyword">null</span>)&#123;               tempB = tempB.next;               countB++;           &#125;           <span class="hljs-keyword">while</span>(countA &gt; countB)&#123;               headA = headA.next;               countA--;           &#125;           <span class="hljs-keyword">while</span>(countA &lt; countB)&#123;               headB = headB.next;               countB--;           &#125;           <span class="hljs-keyword">while</span>(headA != headB)&#123;               headA = headA.next;               headB = headB.next;           &#125;           <span class="hljs-keyword">return</span> headA;     &#125;<span class="hljs-comment">// 方法3</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;       ListNode tempA = headA;       ListNode tempB = headB;       <span class="hljs-keyword">while</span>(tempA != tempB)&#123;           tempA = tempA == <span class="hljs-keyword">null</span> ? headB : tempA.next;           tempB = tempB == <span class="hljs-keyword">null</span> ? headA : tempB.next;       &#125;       <span class="hljs-keyword">return</span> tempA;   &#125;</code></pre></div><h2 id="第六章-面试中的各项能力"><a class="markdownIt-Anchor" href="#第六章-面试中的各项能力"></a> 第六章 面试中的各项能力</h2><h3 id="531-数字在排序数组中出现的次数"><a class="markdownIt-Anchor" href="#531-数字在排序数组中出现的次数"></a> 53.1、数字在排序数组中出现的次数</h3><div class="note note-danger">            <p>题目：<br></p><p>统计一个数字在排序数组中出现的次数。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>利用二分法，寻找 target + 0.5 和 target - 0.5 的位置，也就是想找到 taget 的左右边界。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> i = find(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, target + <span class="hljs-number">0.5</span>);    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] != target)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> j = find(nums, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>, target - <span class="hljs-number">0.5</span>);    <span class="hljs-keyword">return</span> i - j;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">double</span> target)</span></span>&#123;    <span class="hljs-keyword">int</span> i = begin;    <span class="hljs-keyword">int</span> j = end;    <span class="hljs-keyword">while</span>(i &lt;= j)&#123;        <span class="hljs-keyword">int</span> mid = i + (j - i) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(nums[mid] &lt; target)  i = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)    j = mid - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><h3 id="532-0~n-1-中缺失的数字"><a class="markdownIt-Anchor" href="#532-0~n-1-中缺失的数字"></a> 53.2 0~n-1 中缺失的数字</h3><div class="note note-danger">            <p>题目：<br></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>利用二分法。左子数组一定没有缺失，右子数组中包含缺失的数字。那么，我们需要找到右子数组的起点。若 nums[mid] != mid，则说明有缺失，则 j = mid - 1。反之，也可分析。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常"</span>);    &#125;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(i &lt;= j)&#123;        <span class="hljs-keyword">int</span> mid = i + (j - i) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(nums[mid] != mid)    j = mid - <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>    i = mid + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> i;&#125;</code></pre></div><h3 id="533-数组中数值和下标相等的元素"><a class="markdownIt-Anchor" href="#533-数组中数值和下标相等的元素"></a> 53.3 数组中数值和下标相等的元素</h3><div class="note note-danger">            <p>题目：<br></p><p>假设一个单调递增的数组里每个元素都是整数并且是唯一的，请编写程序实现一个函数，找出数组中任意一个数值等于其下标的元素。</p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>典型二分法。</p>          </div><h3 id="54-二叉搜索树中的第-k-大节点"><a class="markdownIt-Anchor" href="#54-二叉搜索树中的第-k-大节点"></a> 54、二叉搜索树中的第  k 大节点</h3> <div class="note note-danger">            <p>题目：<br></p><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>二叉搜索树的中序遍历是升序，则其中序遍历的倒序为降序，遍历顺序为 右-根-左，遍历到第 k 个节点，停止遍历，保存其值，用成员变量来保存数据。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || k &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);    &#125;    num = k;    midOrder(root);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(TreeNode node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;        midOrder(node.right);    &#125;    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span>;    &#125;    num--;    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;        res = node.val;    &#125;    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;        midOrder(node.left);    &#125;&#125;</code></pre></div><h3 id="551-二叉树的深度"><a class="markdownIt-Anchor" href="#551-二叉树的深度"></a> 55.1、二叉树的深度</h3> <div class="note note-danger">            <p>题目：<br></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>一个树的深度等于其左子树和右子树深度的更大值加一。因此用递归实现。</li><li>层序遍历。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 方法1</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;   &#125;<span class="hljs-comment">// 方法2</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;       Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();       queue.add(root);       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;           res++;           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--)&#123;               TreeNode temp = queue.poll();               <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-keyword">null</span>)   queue.add(temp.left);               <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-keyword">null</span>)  queue.add(temp.right);           &#125;       &#125;       <span class="hljs-keyword">return</span> res;   &#125;</code></pre></div><h3 id="552-平衡二叉树"><a class="markdownIt-Anchor" href="#552-平衡二叉树"></a> 55.2 平衡二叉树</h3> <div class="note note-danger">            <p>题目：<br></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>沿用上一题的思想，若一个节点的左子树右子树深度之差大于 1，则不是平衡树，这里用 -1 表示。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <span class="hljs-keyword">return</span> recur(root) == -<span class="hljs-number">1</span> ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode node)</span></span>&#123;    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> left = recur(node.left);    <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> right = recur(node.right);    <span class="hljs-keyword">if</span>(right == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> Math.abs(right - left) &gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : Math.max(right,left) + <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="561-数组中只出现一次的两个数字"><a class="markdownIt-Anchor" href="#561-数组中只出现一次的两个数字"></a> 56.1 数组中只出现一次的两个数字</h3><div class="note note-danger">            <p>题目：<br></p><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>相同的数字异或为 0，如果把数组中所有元素进行异或，那么就相当于只有那两个出现次数为 1 且不相同的数字进行了异或（其它成对数字异或为 0 ）。如果只有一个数字出现一次，则所有元素异或完毕，得到的结果就是那个只出现一次的数字。那么，可以想到，如果将这个数组分为两类，其中一类包含待寻找的一个数字，且包含的其它数字都成对；另一类包含待寻找的另一个数字，且包含的其它数字都成对。那么，分别对这两类数字进行异或，就能得到两个最终的数字，即为该题的解。接下来就是对该数组进行分类。</p><ol><li>对原数组进行异或，得到一个数字，这个数字是那两个目标数字进行异或得到的，这个数字中 位为 1，表示这两个数字该位不相同。那么，我们可以找到该数字中第一个位为 1 的位置。假如得到的数字为 01100100，第一个为 1 的位置为从右到左的第三个，那么建立一个数 00000100 ，原数组和该数相与结果不为 1为一类，结果为 1 为另一类。这样就能够得到目标分类。</li><li>分别对两类进行异或，则可以得到解。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;    <span class="hljs-keyword">int</span> res = xor(nums);    <span class="hljs-keyword">int</span> help = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>((res &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>)&#123;        res = res &gt;&gt; <span class="hljs-number">1</span>;        help = help &lt;&lt; <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;        <span class="hljs-keyword">if</span>((num &amp; help) == <span class="hljs-number">0</span>)  a ^= num;        <span class="hljs-keyword">else</span>    b ^= num;    &#125;    <span class="hljs-keyword">int</span>[] target = &#123;a,b&#125;;    <span class="hljs-keyword">return</span> target;&#125;<span class="hljs-comment">// 对一个数组中所有元素进行异或</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">xor</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;        res ^= nums[i];    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="562-数组中唯一出现一次的数字"><a class="markdownIt-Anchor" href="#562-数组中唯一出现一次的数字"></a> 56.2 数组中唯一出现一次的数字</h3><div class="note note-danger">            <p>题目：<br></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>其它数字都出现了三次，那么，这些数字二进制每一位出现的 1 的次数相加，都能够被 3 整除。因此，将数组中所有元素的二进制位出现的 1 的次数相加，再对 3 求余，得到的结果就是那个只出现一次的数字在那一位上的值。</p><ol><li>利用一个长度为 32 的数组，存放每一位 1 出现的次数。具体操作为：每次取数组中的一个数字，进行 32 次循环，将这个数字最右边一位取出并与 1 相与，判断该位是否为 1，将信息存入新建数组中，再将数字右移一位，循环操作，将该数字的 32 位的情况都进行判断；然后再对下一个数字进行相同的操作。最后，将新建数组恢复成待寻找的数字。</li><li>有限状态机：因为要被 3 整除，那么 1 出现的次数为 0—&gt;1----&gt;2-----&gt;0…，状态有 3 个，因此得用两位的 0 和 1表示，ones 表示低位，twos 表示高位。列出状态转换表。可总结出规律。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">int</span> ones = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> twos = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;        ones = ones ^ num &amp; ~twos;        twos = twos ^ num &amp; ~ones;    &#125;    <span class="hljs-keyword">return</span> ones;&#125;</code></pre></div><h3 id="571-和为-s-的两个数字"><a class="markdownIt-Anchor" href="#571-和为-s-的两个数字"></a> 57.1 和为 s 的两个数字</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><a class="btn" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>对撞双指针。初始化 begin = 0 以及 end = length - 1，若这两个指针上对应元素相加小于目标元素，则 begin++；若大于，则 end–。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);    &#125;    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> end = nums.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(begin &lt; end &amp;&amp; (nums[begin] + nums[end] != target))&#123;        <span class="hljs-keyword">while</span>(begin &lt; end &amp;&amp; (nums[begin] + nums[end] &lt; target))&#123;            begin++;        &#125;        <span class="hljs-keyword">while</span>(begin &lt; end &amp;&amp; (nums[begin] + nums[end] &gt; target))&#123;            end--;        &#125;    &#125;    <span class="hljs-keyword">int</span>[] res = &#123;nums[begin], nums[end]&#125;;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="572-和为-s-的连续正数序列"><a class="markdownIt-Anchor" href="#572-和为-s-的连续正数序列"></a> 57.2 和为 s 的连续正数序列</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><a class="btn" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>类似上题，双指针，滑动窗口。设定一个窗口，若窗口内数字和小于目标数字，则窗口右边界向右扩张；若窗口内数字和大于目标数字，则窗口左边界向右缩小；若等于，则保存结果，将窗口整体向右平移一格，进行下个解的寻找。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;    <span class="hljs-keyword">if</span>(target &lt;= <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);    &#125;    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> end = <span class="hljs-number">2</span>;    List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">while</span>(begin &lt;= target / <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">while</span>(((begin + end) * (end - begin + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> &lt; target)&#123;            end++;        &#125;        <span class="hljs-keyword">while</span>(begin &lt;= target / <span class="hljs-number">2</span> &amp;&amp; ((begin + end) * (end - begin + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> &gt; target)&#123;            begin++;        &#125;        <span class="hljs-keyword">if</span>(((begin + end) * (end - begin + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> == target)&#123;            <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - begin + <span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)&#123;                temp[j++] = i;            &#125;            list.add(temp);            begin++;            end++;        &#125;    &#125;    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()][]);&#125;</code></pre></div><h3 id="581-翻转单词顺序"><a class="markdownIt-Anchor" href="#581-翻转单词顺序"></a> 58.1 翻转单词顺序</h3><div class="note note-danger">            <p>题目：<br></p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。注意，输入的原单词中间可能有连续多个空格，输出时每个单词间隔只能是一个空格。</p><p><a class="btn" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>书上给出的解法：定义一个函数，翻转输入的字符串。那么可以分为两步：1. 将原字符串翻转。2. 再将每个单词分别翻转回来。</li><li>直接调转单词的顺序，定义一个StringBuffer，定义两个指针，从原数组最后面开始往左检索，直到遇到空格或者到头，检索到一段单词，substring这一段，添加到StringBuffer中</li></ol>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法1</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;       s = s.trim();       StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(s);       sb = reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);       <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;       <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span>(begin &lt; sb.length())&#123;           <span class="hljs-keyword">while</span>(end &lt;= sb.length() -<span class="hljs-number">1</span> &amp;&amp; sb.charAt(end) != <span class="hljs-string">' '</span>)&#123;               end++;           &#125;           sb = reverse(sb, begin, end - <span class="hljs-number">1</span>);           begin = end;           <span class="hljs-keyword">while</span>(end &lt;= sb.length() -<span class="hljs-number">1</span> &amp;&amp; sb.charAt(end) == <span class="hljs-string">' '</span>)&#123;               end++;           &#125;           <span class="hljs-keyword">if</span>(begin &lt;= sb.length() -<span class="hljs-number">1</span>)&#123;               sb.replace(begin, end, String.valueOf(<span class="hljs-string">' '</span>));               begin = end - (end - begin - <span class="hljs-number">1</span>);               end = begin;           &#125;       &#125;       <span class="hljs-keyword">return</span> sb.toString();   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> StringBuffer <span class="hljs-title">reverse</span><span class="hljs-params">(StringBuffer s, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;       <span class="hljs-keyword">while</span>(begin &lt; end)&#123;           <span class="hljs-keyword">char</span> temp = s.charAt(begin);           s.replace(begin,begin + <span class="hljs-number">1</span>, String.valueOf(s.charAt(end)));           s.replace(end,end + <span class="hljs-number">1</span>, String.valueOf(temp));           begin++;           end--;       &#125;       <span class="hljs-keyword">return</span> s;   &#125;</code></pre></div><h3 id="582-左旋转字符串"><a class="markdownIt-Anchor" href="#582-左旋转字符串"></a> 58.2 左旋转字符串</h3><div class="note note-danger">            <p>题目：<br></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>书上给出的解法：类似上题，我们把前 n 个数字看做一组，后面的剩余数字看作一组。分别翻转这两组中的内容，再将翻转后的整体内容进行一次翻转。</li><li>利用substring切片函数，直接切片。</li><li>字符串拼接，StringBuffer减少内存消耗。还可利用求余运算简化操作。</li></ol>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法2</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;           <span class="hljs-keyword">return</span> s;       &#125;       <span class="hljs-keyword">if</span>(n &gt; s.length())&#123;           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();       &#125;       String res = <span class="hljs-string">""</span>;       <span class="hljs-keyword">int</span> length = s.length();       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &lt; n + s.length(); i++)&#123;           res += s.charAt(i % length);       &#125;       <span class="hljs-keyword">return</span> res;   &#125;</code></pre></div><h3 id="591-滑动窗口的最大值"><a class="markdownIt-Anchor" href="#591-滑动窗口的最大值"></a> 59.1 滑动窗口的最大值</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><a class="btn" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/submissions/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>暴力解法。</li><li>建立一个单调队列，存放窗口中可能存在的最大值，里面的元素顺序为非单调递减。向右滑动窗口，若当前新进入窗口的元素大于单调队列尾部元素，则需要删除队列尾部元素，这个过程需要循环，直至队列为空或者进入窗口的元素不大于单调队列尾部元素；将新加的元素存放在队列尾部。注意，还需要判断窗口滑动后，失去的那个元素是否是最大的元素，若是，则需要删除队列头部中的该元素。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">int</span>[] resExcep = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];        <span class="hljs-keyword">return</span> resExcep;    &#125;    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123; <span class="hljs-comment">//第一个窗口，不用考虑剔除窗口滑动失去的元素</span>        <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span> &amp;&amp; queue.peekLast() &lt; nums[i])&#123;            queue.removeLast();        &#125;        queue.addLast(nums[i]);    &#125;    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];    res[<span class="hljs-number">0</span>] = queue.peekFirst();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++)&#123;        <span class="hljs-keyword">if</span>(queue.peekFirst() == nums[i - k])&#123;            queue.removeFirst();        &#125;        <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span> &amp;&amp; queue.peekLast() &lt; nums[i])&#123;            queue.removeLast();        &#125;        queue.addLast(nums[i]);        res[i -k + <span class="hljs-number">1</span>] = queue.peekFirst();    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="592-队列的最大值"><a class="markdownIt-Anchor" href="#592-队列的最大值"></a> 59.2 队列的最大值</h3><div class="note note-danger">            <p>题目：<br></p><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1。</p><p><a class="btn" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>类似上题，建立一个单调队列，存放可能存在的最大值。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; max;<span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; list;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;    max = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();    list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> max.size() == <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : max.getFirst();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;    list.addLast(value);    <span class="hljs-keyword">while</span>(max.size() != <span class="hljs-number">0</span> &amp;&amp; max.getLast() &lt; value)&#123;        max.removeLast();    &#125;    max.addLast(value);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span>(list.size() == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> res = list.getFirst();    <span class="hljs-keyword">if</span>(max.getFirst() == res)&#123;        max.removeFirst();    &#125;    list.removeFirst();    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="60-n-个骰子的点数"><a class="markdownIt-Anchor" href="#60-n-个骰子的点数"></a> 60、n 个骰子的点数</h3><div class="note note-danger">            <p>题目：<br></p><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><a class="btn" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划。 n 个骰子可以分为 n - 1 个骰子和 1 个骰子组合。首先，n 个骰子，可能的点数个数为 5 * n + 1。n - 1个骰子和 1 个骰子组合中的 1 个骰子，概率是固定的，6个元素概率均为 1 / 6；n - 1 个骰子和 1 个骰子组合，就是他们的元素两两相乘。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();    &#125;    <span class="hljs-keyword">double</span>[] pre = &#123;<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d&#125;; <span class="hljs-comment">// n - 1 个骰子</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;        <span class="hljs-keyword">double</span>[] later = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">5</span> * i + <span class="hljs-number">1</span>];  <span class="hljs-comment">// n 个骰子</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pre.length; j++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++)&#123;                later[k + j] += pre[j] / <span class="hljs-number">6</span>d;  <span class="hljs-comment">// n - 1 个骰子和 1 个骰子组合得到 n 个骰子结果</span>            &#125;        &#125;        pre = later;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;</code></pre></div><h3 id="61-扑克牌中的顺子"><a class="markdownIt-Anchor" href="#61-扑克牌中的顺子"></a> 61、扑克牌中的顺子</h3><div class="note note-danger">            <p>题目：<br></p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><a class="btn" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>大王小王为 0，其余牌为 1~13。同时满足以下两个条件，5张扑克牌构成顺子。</p><ol><li>除 0 外，无重复牌；</li><li>牌中最大的数字减去最小的数字 &lt; 5。</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> min = <span class="hljs-number">20</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">if</span>(set.contains(num))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        max = Math.max(max,num);        min = Math.min(min,num);        set.add(num);    &#125;    <span class="hljs-keyword">return</span> max - min &lt; <span class="hljs-number">5</span>;&#125;</code></pre></div><h3 id="62-圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#62-圆圈中最后剩下的数字"></a> 62、圆圈中最后剩下的数字</h3><div class="note note-danger">            <p>题目：<br></p><p>0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。每次删除一个数字后，从该数字后面一个数字重新开始数数，求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><a class="btn" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>Josephu问题。</p><ol><li><p>将数字构成一个环形链表，双指针法。初始时，helper 指针指向尾部，target指针指向头部，每次将两个指针往前移动 m-1 下，利用helper 指针删除target指针，循环 n - 1次，最后两个指针重合得到解。</p></li><li><p><a class="btn" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/"  target="_blank">数学分析</a></p></li></ol><p>首先，对于N=8，m=3的情况，我们知道最后删除的元素为G，观察每次G所在的索引，如下图。最后只有一个元素，G的索引肯定为0。</p><p><img src="https://i.loli.net/2020/08/03/1TK758tNCRIyOnG.png" srcset="/img/loading.gif" alt="" /></p><p>接下来倒推一下，如果从N=7倒推N=8时G的索引，将N=8删除的C补进来，并且将整体向右移动 m 下，再把溢出的部分补到前端。我们可以得到N=8时，G的索引。因此，总结可得，由这一次G的索引可以得到上一次G的索引位置，则由 0 倒推至初始数组，得到最初的索引，得到被删除的元素。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">f(n,m) = [f(n-1,m) + m] \% n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault">n</span></span></span></span></span></p><p><img src="https://i.loli.net/2020/08/03/p9U2A7je1iCG36n.png" srcset="/img/loading.gif" alt="" /></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span> || m &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();    &#125;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;        res = (res + m) % i;    &#125;    <span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="63-股票的最大利润"><a class="markdownIt-Anchor" href="#63-股票的最大利润"></a> 63、股票的最大利润</h3><div class="note note-danger">            <p>题目：<br></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]输出: <span class="hljs-number">5</span>解释: 在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span><span class="hljs-number">-1</span> = <span class="hljs-number">5</span> 。     注意利润不能是 <span class="hljs-number">7</span><span class="hljs-number">-1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>动态规划。dp[i] 为以索引 i 元素结尾的日子的最大利润。那么以今天结尾的利润：为以  昨天结尾的利润  和  今天的股票价格与今天之前的股票最低价之差  更大的那一个： dp[i] = dp[i-1] + prices[i] - min(prices[0:i])。初始为 0。由于每次只需要上次的信息，因此可以节省空间。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;    <span class="hljs-keyword">if</span>(prices == <span class="hljs-keyword">null</span> || prices.length &lt;= <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> later = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> min = prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;        pre = later;        min = Math.min(min, prices[i]);        later = Math.max(pre, prices[i] - min);    &#125;    <span class="hljs-keyword">return</span> later;&#125;</code></pre></div><h3 id="64-求-1-2-n"><a class="markdownIt-Anchor" href="#64-求-1-2-n"></a> 64、求 1 + 2 + … + n</h3><div class="note note-danger">            <p>题目：<br></p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><a class="btn" href="https://leetcode-cn.com/problems/qiu-12n-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li>利用短路与，前一个不满足不执行后一个。</li><li>利用 try catch。消耗时间较长。</li></ol>          </div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法1</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">boolean</span> b = n &gt; <span class="hljs-number">0</span> &amp;&amp; (n += sumNums(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>;       <span class="hljs-keyword">return</span> n;   &#125;<span class="hljs-comment">// 方法2</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] temp = &#123;<span class="hljs-number">0</span>&#125;;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;       <span class="hljs-keyword">try</span>&#123;           <span class="hljs-keyword">return</span> temp[n];       &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;           <span class="hljs-keyword">return</span> n + sumNums(n - <span class="hljs-number">1</span>);       &#125;   &#125;</code></pre></div><h3 id="65-不用加减乘除做加法"><a class="markdownIt-Anchor" href="#65-不用加减乘除做加法"></a> 65、不用加减乘除做加法</h3><div class="note note-danger">            <p>题目：<br></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p><a class="btn" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>两数相加，分别得到不做进位的结果  A（两数位异或，相同为0不同为1）  以及进位信息  C（两数位相与，只有全为 1 才进位）（即在哪一位相加发生了进位）。那么将 C 整体左移一位加上 A 就是结果。但是由于不能用加法，我们可以对 A C 再次进行上面的操作，那么我们需要不断循环以上操作直至 C为 0，也就是没有进位了。<br></p><p>More:<br></p><p>交换两个数字：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a + b<span class="hljs-comment">;</span><span class="hljs-attr">b</span> = a - b<span class="hljs-comment">;</span><span class="hljs-attr">a</span> = a - b<span class="hljs-comment">;</span><span class="hljs-attr">a</span> = a ^ b<span class="hljs-comment">;</span><span class="hljs-attr">b</span> = a ^ b<span class="hljs-comment">;</span><span class="hljs-attr">a</span> = a ^ b<span class="hljs-comment">;</span></code></pre></div>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 进位信息</span>    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;        c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;        a = a ^ b;  <span class="hljs-comment">// 不做进位的结果</span>        b = c;    &#125;    <span class="hljs-keyword">return</span> a;&#125;</code></pre></div><h3 id="66-构建乘积数组"><a class="markdownIt-Anchor" href="#66-构建乘积数组"></a> 66、构建乘积数组</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p><a class="btn" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>暴力解法。</p></li><li><p>时间复杂度O(N)。将原数组构成一张表，对角线处改为 1。那么，第一个循环是将左下部分元素相乘，第二个循环是再乘上右上部分的值。</p></li></ol><p><img src="https://i.loli.net/2020/08/05/yfUVrzdXv7nqgFB.png" srcset="/img/loading.gif" alt="" /></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;    <span class="hljs-keyword">if</span>(a == <span class="hljs-keyword">null</span> || a.length &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++)&#123;        b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;=<span class="hljs-number">0</span>; i--)&#123;        temp *= a[i + <span class="hljs-number">1</span>];        b[i] *= temp;    &#125;    <span class="hljs-keyword">return</span> b;&#125;</code></pre></div><h2 id="第七章-两个面试案例"><a class="markdownIt-Anchor" href="#第七章-两个面试案例"></a> 第七章 两个面试案例</h2><h3 id="67-把字符串转换为整数"><a class="markdownIt-Anchor" href="#67-把字符串转换为整数"></a> 67、把字符串转换为整数</h3><div class="note note-danger">            <p>题目：<br></p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>按要求匹配即可，需要注意的有：</p><ol><li>去除字符串开头的空格；</li><li>检索正负号；</li><li>当遇到非数字时停止扫描；</li><li>注意字符串数字不能超过 int 类型的最大值。这里要当心的是，若简单的将数字与 int 类型范围进行比较来判断是否溢出，会出错，因为在计算时，res 为 int 类型，溢出时会自动转换，因此，我们需要在每次计算 res 之前，就提前判断这一次计算 res 后，它是否会溢出，具体方法为：将其与 max（<em>2147483647</em>） / 10比较，若大于，此次计算后必溢出，若等于，则判断此次字符是否大于 ‘7’，若大于，则溢出。（这里很巧妙，将负数时的 8 也能囊括进去。）</li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;    <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span> || str.length() &lt;= <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正负号</span>    <span class="hljs-keyword">int</span> max = Integer.MAX_VALUE;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(str.charAt(index) == <span class="hljs-string">' '</span>)&#123;        <span class="hljs-keyword">if</span>(++index == str.length())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125; <span class="hljs-comment">// 去除头部空格</span>    <span class="hljs-keyword">if</span>(str.charAt(index) == <span class="hljs-string">'-'</span>)&#123;        sign = -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span>(str.charAt(index) == <span class="hljs-string">'+'</span> || str.charAt(index) == <span class="hljs-string">'-'</span>)&#123;        index++;    &#125; <span class="hljs-comment">// 检索正负号</span>    <span class="hljs-keyword">for</span>(; index &lt; str.length(); index++)&#123;        <span class="hljs-keyword">if</span>(str.charAt(index) &lt; <span class="hljs-string">'0'</span> || str.charAt(index) &gt; <span class="hljs-string">'9'</span>)&#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span>(res &gt; max / <span class="hljs-number">10</span> || (res == max / <span class="hljs-number">10</span> &amp;&amp; str.charAt(index) &gt; <span class="hljs-string">'7'</span>))&#123;            <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? max : Integer.MIN_VALUE;        &#125;        res = res * <span class="hljs-number">10</span> + (str.charAt(index) - <span class="hljs-string">'0'</span>);    &#125;    <span class="hljs-keyword">return</span> sign * res;&#125;</code></pre></div><h3 id="681-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#681-二叉搜索树的最近公共祖先"></a> 68.1 二叉搜索树的最近公共祖先</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><p>二叉搜索树，一个节点的左子树中所有节点的值它的值小，右子树中所有节点的值它的值大。对于输入的两个节点，若找到一个节点的值，介于这两个之间，则找到目标节点。若一个节点的值大于这两个节点的值，则需要在该节点的左子节点继续寻找；若一个节点的值小于这两个节点的值，则需要在该节点的右子节点继续寻找.</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;    <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;            root = root.left;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;            root = root.right;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> root;&#125;</code></pre></div><h3 id="682-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#682-二叉树的最近公共祖先"></a> 68.2 二叉树的最近公共祖先</h3><div class="note note-danger">            <p>题目：<br></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/"  target="_blank">力扣：用例测试</a></p>          </div><div class="note note-primary">            <p>思路分析：<br></p><ol><li><p>p 和 q 在 root 的子树中，且分列 rootroot 的 异侧（即分别在左、右子树中）；</p></li><li><p>p = root ，且 q 在 root 的左或右子树中；</p></li><li><p>q = root ，且 p 在 root 的左或右子树中。</p></li></ol><p>不断递归。</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q)&#123;        <span class="hljs-keyword">return</span> root;    &#125;    TreeNode left = lowestCommonAncestor(root.left, p, q);    TreeNode right = lowestCommonAncestor(root.right, p, q);    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> right;    &#125;    <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>)&#123;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-keyword">return</span> root;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机(JVM)</title>
    <link href="/posts/jvm-v1/"/>
    <url>/posts/jvm-v1/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容~"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="诶，这篇文章被加密啦，请输入密码~" /><label>诶，这篇文章被加密啦，请输入密码~</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="edceda5c2e2e214c060230701b9e6b52871b98ec6d8471fab6161bae1bd5a4ee">60195987a3c6988de013a280458cba783741a67b6b12803382069cde8bc24f5bc1e3c6850fb09c5db8fb125aafb076c014ea9a6f352d49f2b866d70fb00953af882c3ce19e3c1399f02cd627d4d054eb7f2f1d99672a7e6528955322a0e5b4cda41e926201fabc17bdbdf9568616ba13fdde2eccb87ca88b5b543ce6ef5ba4a01003ab6b7ddb7ece20a48c8b8f6962bae4740d69ff2c80ccd41943bfde13a31492f88e53a7286494dcfa48da91180454285ee749c466b21172a1f96fcc846a847b34a2fbcfbc4c99602c104d4542b0e29b981f815cf1fdfb9fb700e5089a4b486cf2d562ec237d6a1790853d316d59dd9f34f40984181487aae417713ae9cabe4b4209974320bcb2192df9d781a453ee0f04c60a375f362b550c6374cbc988a88696ab9cf7f3d822ab9caca4ac88d6c2ae80800111e729d3bc8d6c2748d495065cbd21c1457f14ffa6105100f88d77f2</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo框架</title>
    <link href="/posts/dubbo-v1/"/>
    <url>/posts/dubbo-v1/</url>
    
    <content type="html"><![CDATA[<p>Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。本文展示的是Maven+SpringMVC+Dubbo。</p><p>需要在服务消费者和提供者的pom文件中导入远程接口项目的依赖。</p><a class="btn" href="http://dubbo.apache.org/zh-cn/"  target="_blank">Dubbo中文官网</a><h2 id="无注册中心"><a class="markdownIt-Anchor" href="#无注册中心"></a> 无注册中心</h2><h3 id="服务提供者配置文件xml"><a class="markdownIt-Anchor" href="#服务提供者配置文件xml"></a> 服务提供者配置文件xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-userservice-provider.xml--&gt;</span><span class="hljs-comment">&lt;!--服务提供者声明名称:必须保证服务名称的唯一性,它的名称是dubbo内部使用的唯一标识--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"001-link-userservice-provider"</span>/&gt;</span><span class="hljs-comment">&lt;!--访问服务协议的名称及端口号,dubbo官方推荐使用的是dubbo协议,端口号默认为20880--&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        name:指定协议的名称</span><span class="hljs-comment">        port:指定协议的端口号(默认为20880)</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"20880"</span>/&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">暴露服务接口-&gt;dubbo:service</span><span class="hljs-comment">    interface:暴露服务接口的全限定类名</span><span class="hljs-comment">    ref:接口引用的实现类在spring容器中的标识</span><span class="hljs-comment">    registry:如果不使用注册中心,则值为:N/A</span><span class="hljs-comment">--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xxx.dubbo.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userServiceImpl"</span> <span class="hljs-attr">registry</span>=<span class="hljs-string">"N/A"</span>/&gt;</span><span class="hljs-comment">&lt;!--将接口的实现类加载到spring容器中--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.xxx.dubbo.service.impl.UserServiceImpl"</span>/&gt;</span></code></pre></div><h3 id="服务提供者webxml"><a class="markdownIt-Anchor" href="#服务提供者webxml"></a> 服务提供者web.xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--监听器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:dubbo-userservice-provider.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></code></pre></div><h3 id="服务消费者配置文件xml"><a class="markdownIt-Anchor" href="#服务消费者配置文件xml"></a> 服务消费者配置文件xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-consumer.xml--&gt;</span><span class="hljs-comment">&lt;!--声明服务消费者的名称:保证唯一性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"002-link-consumer"</span>/&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    引用远程服务接口:</span><span class="hljs-comment">    id:远程服务接口对象名称</span><span class="hljs-comment">    interface:调用远程接口的全限定类名</span><span class="hljs-comment">    url:访问服务接口的地址</span><span class="hljs-comment">registry:不使用注册中心,值为:N/A</span><span class="hljs-comment">--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span></span><span class="hljs-tag">                     <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xxx.dubbo.service.UserService"</span></span><span class="hljs-tag">                     <span class="hljs-attr">url</span>=<span class="hljs-string">"dubbo://localhost:20880"</span></span><span class="hljs-tag">                     <span class="hljs-attr">registry</span>=<span class="hljs-string">"N/A"</span>/&gt;</span></code></pre></div><h3 id="服务消费者springmvc配置文件xml"><a class="markdownIt-Anchor" href="#服务消费者springmvc配置文件xml"></a> 服务消费者SpringMVC配置文件xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--application.xml--&gt;</span><span class="hljs-comment">&lt;!--组件扫描器，扫描Controller--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.xxx.dubbo.web"</span>/&gt;</span><span class="hljs-comment">&lt;!--配置注解驱动--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><span class="hljs-comment">&lt;!--视图解析器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre></div><h3 id="服务消费者webxml"><a class="markdownIt-Anchor" href="#服务消费者webxml"></a> 服务消费者web.xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--中央调度器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:application.xml,classpath:dubbo-consumer.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre></div><h2 id="zookeeper注册中心"><a class="markdownIt-Anchor" href="#zookeeper注册中心"></a> ZooKeeper注册中心</h2><h3 id="服务提供者配置文件xml-2"><a class="markdownIt-Anchor" href="#服务提供者配置文件xml-2"></a> 服务提供者配置文件xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-zk-userservice-provider.xml--&gt;</span><span class="hljs-comment">&lt;!--声明dubbo服务提供者的名称:保证唯一性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"007-zk-userservice-provider"</span>/&gt;</span><span class="hljs-comment">&lt;!--声明dubbo使用的协议名称和端口号--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"20880"</span>/&gt;</span><span class="hljs-comment">&lt;!--现在要使用zookeeper注册中心--&gt;</span>    <span class="hljs-comment">&lt;!--指定注册中心地址和端口号--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"zookeeper://localhost:2181"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--使用linux系统中的zookeeper服务--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;dubbo:registry address="zookeeper://192.168.154.128:2181"/&gt;--&gt;</span><span class="hljs-comment">&lt;!--暴露服务接口--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xxx.dubbo.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userServiceImpl"</span>/&gt;</span><span class="hljs-comment">&lt;!--加载接口实现类--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.xxx.dubbo.service.impl.UserServiceImpl"</span>/&gt;</span></code></pre></div><h3 id="服务消费者配置文件xml-2"><a class="markdownIt-Anchor" href="#服务消费者配置文件xml-2"></a> 服务消费者配置文件xml</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--dubbo-zk-consumer.xml--&gt;</span><span class="hljs-comment">&lt;!--声明dubbo服务消费者名称:保证唯一性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"008-zk-consumer"</span>/&gt;</span><span class="hljs-comment">&lt;!--指定注册中心--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"zookeeper://localhost:2181"</span>/&gt;</span>    <span class="hljs-comment">&lt;!--使用linux系统中的zookeeper服务--&gt;</span>    <span class="hljs-comment">&lt;!--&lt;dubbo:registry address="zookeeper://192.168.154.128:2181"/&gt;--&gt;</span><span class="hljs-comment">&lt;!--引用远程接口服务--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xxx.dubbo.service.UserService"</span>/&gt;</span></code></pre></div><p>​    可以通过版本号选择接口的不同实现类。在服务消费者中注入不同的对象：</p><p><code>&lt;dubbo:service interface=&quot;com.xxx.dubbo.service.UserService&quot; ref=&quot;userServiceImpl1&quot; version=&quot;1.0.0&quot;/&gt;</code></p><p><code>&lt;dubbo:service interface=&quot;com.xxx.dubbo.service.UserService&quot; ref=&quot;userServiceImpl2&quot; version=&quot;2.0.0&quot;/&gt;</code></p><p>​    在服务消费者中选择对应的版本号：</p><p><code>&lt;dubbo:reference id=&quot;userService1&quot; interface=&quot;com.xxx.dubbo.service.UserService&quot; version=&quot;1.0.0&quot; /&gt;</code></p><p><code>&lt;dubbo:reference id=&quot;userService2&quot; interface=&quot;com.xxx.dubbo.service.UserService&quot; version=&quot;2.0.0&quot; /&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八大排序算法Java实现</title>
    <link href="/posts/sort-alogrithms-v1/"/>
    <url>/posts/sort-alogrithms-v1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>排序算法，本文示例均为升序排序。</p><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><p>快速排序思想基本思想是将数据分割为独立的两部分，其中一部分的所有数据都比另外一部分所有数据都要小，然后不断的递归分割数据，得到最终结果。</p><ul><li>本例初始以最左端数据为基准。</li><li>分割完成后，记数组中第<code>i</code>个元素为temp，数组中<code>i</code>左边的元素都比temp小（可等于），数组中<code>i</code>右边的元素都比temp大（可等于）。</li><li>递归调用。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;        <span class="hljs-keyword">if</span>(left &gt;= right)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//以最左端数据为基准，所以要从最末尾的数据开始检查</span>        <span class="hljs-keyword">int</span> temp = arr[left];        <span class="hljs-keyword">int</span> i = left;        <span class="hljs-keyword">int</span> j = right;        <span class="hljs-keyword">int</span> temp2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(i != j)&#123;            <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; arr[j] &gt;= temp)&#123;                j--;            &#125;            <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; arr[i] &lt;=temp)&#123;                i++;            &#125;            <span class="hljs-keyword">if</span>(i != j)&#123;                temp2 = arr[i];                arr[i] = arr[j];                arr[j] = temp2;            &#125;        &#125;        arr[left] = arr[i];        arr[i] = temp;        quickSort(arr, left, i-<span class="hljs-number">1</span>);        quickSort(arr, i+<span class="hljs-number">1</span>, right);    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>排序</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法-快速入门</title>
    <link href="/posts/markdown-v1/"/>
    <url>/posts/markdown-v1/</url>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0、前言</h1><p>推荐使用Typora编辑器，免费、轻便、简洁。</p><hr /><h1 id="1-标题"><a class="markdownIt-Anchor" href="#1-标题"></a> 1、标题</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//总共有六级标题，语法为# 你的标题内容（注意空格，n个#号代表n级标题，1≤n≤6）</span># 一级标题 //快捷键：ctrl+1## 二级标题 //快捷键：ctrl+2### 三级标题 //快捷键：ctrl+3#### 四级标题 //快捷键：ctrl+4##### 五级标题 //快捷键：ctrl+5###### 六级标题 //快捷键：ctrl+6<span class="hljs-comment">//效果如下所示：</span></code></pre></div><h1 id="一级标题"><a class="markdownIt-Anchor" href="#一级标题"></a> 一级标题</h1><h2 id="二级标题"><a class="markdownIt-Anchor" href="#二级标题"></a> 二级标题</h2><h3 id="三级标题"><a class="markdownIt-Anchor" href="#三级标题"></a> 三级标题</h3><h4 id="四级标题"><a class="markdownIt-Anchor" href="#四级标题"></a> 四级标题</h4><h5 id="五级标题"><a class="markdownIt-Anchor" href="#五级标题"></a> 五级标题</h5><h6 id="六级标题"><a class="markdownIt-Anchor" href="#六级标题"></a> 六级标题</h6><hr /><h1 id="2-分割线"><a class="markdownIt-Anchor" href="#2-分割线"></a> 2、分割线</h1><div class="hljs"><pre><code class="hljs java">--- <span class="hljs-comment">//视内容定长度</span>*** <span class="hljs-comment">//全屏</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><hr /><hr /><h1 id="3-代码块"><a class="markdownIt-Anchor" href="#3-代码块"></a> 3、代码块</h1><div class="hljs"><pre><code class="hljs java">​```java <span class="hljs-comment">//代表java代码块，可按需求替换java，快捷键：ctrl+shift+k</span><span class="hljs-comment">//效果如下所示</span></code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> hello;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Homework7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">boolean</span> judge = <span class="hljs-keyword">true</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">2</span>;k&lt;i;k++)&#123;<span class="hljs-keyword">if</span>(i%k==<span class="hljs-number">0</span>)&#123;judge = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> judge;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isperfect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">boolean</span> judge = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">2</span>;k&lt;=i/<span class="hljs-number">2</span>;k++)&#123;<span class="hljs-keyword">if</span>(i%k==<span class="hljs-number">0</span>)sum += k;&#125;<span class="hljs-keyword">if</span>(sum==i&amp;&amp;i!=<span class="hljs-number">1</span>)judge = <span class="hljs-keyword">true</span>;<span class="hljs-keyword">return</span> judge;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-comment">//Scanner in = new Scanner(System.in);</span><span class="hljs-comment">//int number = in.nextInt();</span><span class="hljs-comment">//isprime(9);</span><span class="hljs-comment">//System.out.print(number + "=");</span><span class="hljs-comment">//while(!isprime(number))</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//for(int i=2;i&lt;number;i++)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//if(number%i==0&amp;&amp;isprime(i))</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//System.out.print(i+"x");</span><span class="hljs-comment">//number /= i;</span><span class="hljs-comment">//break;</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//System.out.print(number);</span>Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);<span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> i=in.nextInt();<span class="hljs-keyword">int</span> m=in.nextInt();<span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m-i+<span class="hljs-number">1</span>];<span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;i&lt;=m;i++)&#123;<span class="hljs-keyword">if</span>(isperfect(i))&#123;temp[number] = i;flag = <span class="hljs-number">1</span>;number += <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)System.out.print(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kk=<span class="hljs-number">0</span>;kk&lt;=number-<span class="hljs-number">2</span>;kk++)&#123;System.out.print(temp[kk]+<span class="hljs-string">" "</span>);&#125;System.out.print(temp[number-<span class="hljs-number">1</span>]);&#125;&#125;&#125;</code></pre></div><hr /><h1 id="4-代码及命令"><a class="markdownIt-Anchor" href="#4-代码及命令"></a> 4、代码及命令</h1><div class="hljs"><pre><code class="hljs java">`你的代码` <span class="hljs-comment">//可用于文中插入代码及命令，快捷键：ctrl+shift+`</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><p><code>cd G:</code> <code>for(int i = 0; i &lt; 10; i++)</code></p><hr /><h1 id="5-字体编辑"><a class="markdownIt-Anchor" href="#5-字体编辑"></a> 5、字体编辑</h1><div class="hljs"><pre><code class="hljs java">**你的内容** <span class="hljs-comment">//粗体，快捷键：ctrl+B</span>*你的内容* <span class="hljs-comment">//斜体，快捷键：ctrl+I</span>~~你的内容~~ <span class="hljs-comment">//删除线，快捷键：alt+shift+5</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><p><strong>你的内容</strong></p><p><em>你的内容</em></p><p><s>你的内容</s></p><hr /><h1 id="6-图片"><a class="markdownIt-Anchor" href="#6-图片"></a> 6、图片</h1><div class="hljs"><pre><code class="hljs java">![图片名称](图片地址) <span class="hljs-comment">//地址可为本地地址也可为网络地址，快捷键：ctrl+shift+I</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><p><img src="/img/avatar.png" srcset="/img/loading.gif" alt="名字" /></p><hr /><h1 id="7-超链接"><a class="markdownIt-Anchor" href="#7-超链接"></a> 7、超链接</h1><div class="hljs"><pre><code class="hljs java">[链接名字](链接地址)<span class="hljs-comment">//快捷键：ctrl+K</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><p><a href="https://www.rooftopj.cn/">rooftopj的博客主页</a></p><hr /><h1 id="8-列表"><a class="markdownIt-Anchor" href="#8-列表"></a> 8、列表</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//有序列表，序号+.+空格，快捷键：ctrl+shift+[</span><span class="hljs-number">1</span>. 第一点<span class="hljs-number">2</span>. 第二点<span class="hljs-number">3</span>. 第三点<span class="hljs-comment">//无序列表，-+空格，快捷键：ctrl+shift+]</span>- 实例<span class="hljs-number">1</span>- 实例<span class="hljs-number">2</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol><ul><li>实例1</li><li>实例2</li></ul><hr /><h1 id="9-表格"><a class="markdownIt-Anchor" href="#9-表格"></a> 9、表格</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//建议直接使用快捷键生成表格，快捷键：ctrl+T</span><span class="hljs-comment">//效果如下所示：</span></code></pre></div><table><thead><tr><th style="text-align:center">课程</th><th style="text-align:center">学分</th><th style="text-align:center">分数</th></tr></thead><tbody><tr><td style="text-align:center">高等数学（上）</td><td style="text-align:center">6</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">线性代数</td><td style="text-align:center">4</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">概率论与数理统计</td><td style="text-align:center">4</td><td style="text-align:center">100</td></tr></tbody></table><hr /><h1 id="10-引用"><a class="markdownIt-Anchor" href="#10-引用"></a> 10、引用</h1><div class="hljs"><pre><code class="hljs java">&gt;此教程来自rooftopj<span class="hljs-comment">//快捷键：ctrl+shift+Q</span>&gt;&gt;此教程来自rooftopj&gt;&gt;&gt;此教程来自rooftopj<span class="hljs-comment">//效果如下所示：</span></code></pre></div><blockquote><p>此教程来自rooftopj</p><blockquote><p>此教程来自rooftopj</p><blockquote><p>此教程来自rooftopj</p></blockquote></blockquote></blockquote><hr /><h1 id="11-公式块"><a class="markdownIt-Anchor" href="#11-公式块"></a> 11、公式块</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//快捷键：ctrl+shift+M</span>$$你的公式    $$<span class="hljs-comment">//效果如下所示：</span></code></pre></div><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi mathvariant="normal">∞</mi></msubsup><mfrac><mn>1</mn><mi>x</mi></mfrac><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">f(x) = \int_0^{\infty} \frac{1}{x}dx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span></span></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语法</tag>
      
      <tag>Tyoora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot框架</title>
    <link href="/posts/springboot-v1/"/>
    <url>/posts/springboot-v1/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容~"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="诶，这篇文章被加密啦，请输入密码~" /><label>诶，这篇文章被加密啦，请输入密码~</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="def4c6e040e3d500c747520dafbe6394abd576828c0309b2767234a19c99b01e">77b83cd8be1f24f2fa79465f7652a4cbe617a7ee9bae5b75710778e7b4a4761c</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全写出来的能叫心里话吗？</title>
    <link href="/posts/diary-v1/"/>
    <url>/posts/diary-v1/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试~" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容~"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="诶，这篇文章被加密啦，请输入密码~" /><label>诶，这篇文章被加密啦，请输入密码~</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="8a14dd6cea13809ffb323d6b72a7d97afc68e28f2fa357b6585c0d9843b2e277">981d0f7307c90f8499cb7e8b986bfa7de527cbf30d533d4cdadfde986458ffd7018ae4b45c7a8b2760f2274fc746a821ef977530c01290965fcf6c72b89571e106fe6549dad95052c9c15e3ce4596f7e909d199195a8bf877df9ea3d9fc96fd06b4614814766e3ddbfec246f1104ca4108a388c4f175736f6f518e468a1714dfe997a909431fe86b5f5a46599842b95c7bb2c9049aefee50a7bc71bbdc0a287bebe77b613c4035b99864e042f52ca5a9720d97196eb41e8ce66befd0c27a77442cd38f0939be2e7c7de4b58852eaa88d46efc464215c2285320cac1de52fd55ce1bacd41416710516cbaebb26b1c159286bcaf1e0a2ff2aeaff9abfa9aa3bb8a4b0b38633debbe1aa982f5899d20ae9793ba92f0eeab0d4de4d89aa972b68643bbe38383c33b87f320a8c61e9892493d3b85de48ff83f04380ad823e927219ed5a17f3e7e8f9d79984f9c8981591b745fb8589edbe61f3181929a95dd1c8f7e6ec8c64a172324ef0083c2ce2bca6a83047b8ee56b2c61ed9ccc049663397170047bb939b481fefbfead9390dff01f2f0115c6cf3ecf752d2f2a14f1e9cb4ce522eb6e7028060b9910001bcc82ccf5c020d2e58e106680f7362ec10297228efa9418d310a21117a6e659be8aa3018677b5242739762b044b9fd296b4ebecf9724e6f58fbbbfea4e2b54cca0226af02feb15eb5c2c0857aacf2000c0b608df9cc4caeb74d9ce76a9caf695b6c85ecaab4ca6985c6bd08e857ad6dc3f24915177b5fc849a212331874ab5de786c4b75fb4dd873e5e99d1b04e5bc52a5dbe72ba0e53a4419f87952bcb86b034c22c1f381596de11a9b8b8dca4d1dbc710c942c3d6ba4001c9e8e925fd2054f074b4b7040ceb0e05d64100c96660a9d0d2d3d614db7574a05b74cb762890196e8c041d55b0f956cf8e8194a56365fdc783d2344f65523dd0dae73823adec00046eacde69a13555e2517ffd4f244b0271128cbaead24129a681954af86b7c7596f749825ea3eb82fcd6ceb572ca7ff2c7b110bd5934e1fbeb94f0f7af25edb3bf9fd84e2535fa00bd4675592383437afe464178509b5eb8e02c25638fa5d568da228741c425417277040a996178316e0c660d91314fae4fdb1c442bdc2419795955b9c35a745b7c573913ea90e1194dac8791233fa64e6b511b4ee7e83237953cf4baa347b6f5403ded7e66f1838b20ae8fd46cef2e81f1367e4fef6d395a201ccba6ea0ee27f34e72b779d912fac55c4205a94a3eb5eb7a30a8756c66fc214a55966b9570711cab3583700dd8db3eebc262c70da1400ba0348b469a78b682a6479d13d9c401a3a6203af073a2b7b93e948a6d42b521569c31050738000c822e42e9142a4ff5f7a03860a0079ba3a70884506699c3894ee09a8442ba8753a794ad2a82038fee9ecf81d2c0c61d2222c7f4e1826186fa368e1e2e76661c49f64abcb33fe83d2f034b5280c0ea008b868222a8a33bac34b64ec0ec5786bbfbac48f2e60a90f5cbc858de27ecccb7935b665aeb4cb5212a9e7dd309c977484409f8ac0dc87f0e2d6317ebe07cdd77373dc12e5bc6fe28ca60b2ffd0e79b7101a35219ac64487ef9d7d535545055578a11cab5568094ce06de3ddf78a2bae3561bf58d2135a3da1b703bcfa89ae1e435969792edec78b066ca0d39038d54e8ae34597993b0e8ada1c45bcb4328e56fef3698154a318282a5d40a6109e55f26916e16dc651f2b332c51426a56836321a8431da3539fbeee473aeee1599e95c40f4f24aa6f718baf8bf6e7eff6109e65b5337404ef7b1e8813f1c91368eb7b5de38146c45c9bc3d1cdb83eb3aabe538a56319ee2c3fa3ecbf9590113d8f1c638a668f9c68fb0557b2bcaf17bc072ce7131d01d4d7d046ca093564bcb1acdfbd7a31c8f247581ea367d9ffba53283fb359a64cc11055197f2d7940c5a1a517074b8c7c1b2f8620c2cece934ed5f1e0407580e07bbe3aa09c7f071a875ca1beef61dbe4b1a3c5ad8b89ee9819e5cc10a29e831c1ca437daab0bc1f1662208652f8341c905e73fc64634621a4d6bc5e6b691b33fb79fa5e7d367f10ee128e50d2eb8d53d82dba0cfcc506a4326f6ba9d700165b9c10e158578576fa83bb7c3875a5e2d7f32cea5425ad131bb3fc6aa7402dd9ffd994953070f415c5098f4bd6155c5d8c94a627c8a56cd3dac4ed48474351424281f07bde01e35d1d3618c0caf75f664aa145778f17a49191e5125e29792243cac16a842babf9612a8d7cfc67dd567b150ed714bc2308da</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>心情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心情</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
