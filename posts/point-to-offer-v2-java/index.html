<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="rooftopj"><meta name="keywords" content=""><title>剑指Offer第二版Java实现 - rooftopj</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/srcery.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/card.css"><link rel="stylesheet" href="/css/icon.css"><script src="/js/utils.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div id="dark" onclick="switchDarkMode()"></div><script>var isNight=23<=(new Date).getHours()||(new Date).getHours()<6;(matchMedia("(prefers-color-scheme: dark)").matches||isNight||"1"===localStorage.getItem("dark"))&&(isNight&&"1"===localStorage.getItem("noDark")||document.body.classList.add("dark")),document.getElementById("dark").innerHTML=document.querySelector("body").classList.contains("dark")?"🌙":"🌞"</script><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>rooftopj</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-07-12 15:32">2020年7月12日 下午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 27.1k 字</span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 362 分钟</span><span id="leancloud-post-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> 访问<span id="leancloud-post-views"></span> 次</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><p class="note note-info">本文最后更新于：2020年8月26日 上午</p><article class="markdown-body"><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><code>剑指Offer第二版</code>，全题解，已完结。参考资料为牛客网以及力扣上各大佬的题解分享。</p><a class="btn" href="https://www.nowcoder.com/discuss/198840?type=1" target="_blank">牛客网：剑指offer全解（Java版）</a><br><a class="btn" href="[https://leetcode-cn.com/problemset/all/?search=%E5%89%91%E6%8C%87offer](https://leetcode-cn.com/problemset/all/?search=剑指offer)" target="_blank">leetcode：剑指offer</a><br><a class="btn" href="http://product.dangdang.com/24242724.html" target="_blank">剑指offer第二版</a><h2 id="第二章-面试需要的基础知识"><a class="markdownIt-Anchor" href="#第二章-面试需要的基础知识"></a> 第二章 面试需要的基础知识</h2><h3 id="31-数组中重复的数字"><a class="markdownIt-Anchor" href="#31-数组中重复的数字"></a> 3.1、数组中重复的数字</h3><div class="note note-danger"><p>题目：<br></p><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><p><a class="btn" href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>第一种思路：将元素排序，再从头到尾扫描排序后的数组。</li><li>第二种思路：借助一个哈希表，头到尾扫描数组，每当扫描到一个数字时，判断哈希表中是否存在该数字，不存在则将该数字加入哈希表中，存在则找到重复数字。</li><li>第三种思路：我们注意到数组中的数字都在 0 到 n-1 的范围内，重排这个数组，数组排序后，若数组中没有重复的元素，则数组中第 i 个元素的值应为 i 。接下来重排数组。当扫描到第 i 个数字后（用 m 表示），判断 i 与 m 是否相等，若相等，扫描下一个数字；若不相等，将该数字与数组中第 m 个数字进行比较，若相等，则找到重复数字，若不相等，则交换这两个数字的位置，让数字m处在它应该处在的位置，接着扫描下一个数字。</li></ol><p>第三种思路的时间复杂度是O(n)，空间复杂度是O(1)。采用第三种思路。</p></div><div class="hljs"><pre><code class="hljs java">Input:
&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;
 
Output:
<span class="hljs-keyword">true</span> duplication[<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numbers[],<span class="hljs-keyword">int</span> length,<span class="hljs-keyword">int</span> [] duplication)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == numbers || length &lt;= <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;
            <span class="hljs-keyword">if</span>(numbers[i] != i)&#123;
                <span class="hljs-keyword">if</span>(numbers[numbers[i]] == numbers[i])&#123;
                    duplication[<span class="hljs-number">0</span>] = numbers[i];
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                &#125;<span class="hljs-keyword">else</span>&#123;
                    <span class="hljs-keyword">int</span> temp = numbers[i];
                    numbers[i] = numbers[numbers[i]];
                    numbers[temp] = temp; <span class="hljs-comment">// 注意numbers[i]的值已改变，需要用temp来指代原numbers[i]</span>
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
	&#125;</code></pre></div><h3 id="32-不修改数组找出重复数字"><a class="markdownIt-Anchor" href="#32-不修改数组找出重复数字"></a> 3.2、不修改数组找出重复数字</h3><div class="note note-danger"><p>题目：<br></p><p>在一个长度为 n+1 的数组里的所有数字都在 1 到 n 的范围内。所以数组中至少有一个数组是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>第一种思路：将原数组复制到辅助数组，如果原数组中被复制的数字是 m ，则把它复制到辅助数组下标为 m-1 的位置，这样就很容易发现哪个数字是重复的。</li><li>第二种思路：将 1~n 的数字从中间 m 分为两部分，前面一半为 1~m，后面一半为 m+1~n，如果数组中 1~m 的数字超过 m 个，则在 1~m 中一定有重复的数字，否则，在 m+1~n 中一定有重复数字，这样继续将有重复数字的区间一分为二，直到找到最后的数字。</li></ol><p>第二种思路的时间复杂度是O(nlogn)，空间复杂度是O(1)。相当于以时间换空间，这里演示第二种思路。</p></div><div class="hljs"><pre><code class="hljs java">Input:
&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;
 
Output:
<span class="hljs-keyword">true</span> duplication[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>
    
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numbers[],<span class="hljs-keyword">int</span> length,<span class="hljs-keyword">int</span> [] duplication)</span> </span>&#123;
        <span class="hljs-keyword">return</span> search(numbers, <span class="hljs-number">1</span>, length - <span class="hljs-number">1</span>, duplication);
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] duplication)</span></span>&#123;
        <span class="hljs-keyword">while</span>(end &gt;= begin)&#123;
            <span class="hljs-keyword">int</span> mid = (begin + end)/<span class="hljs-number">2</span>;
            <span class="hljs-keyword">int</span> count = countRange(numbers, begin, mid);
            <span class="hljs-keyword">if</span>(begin == mid)&#123;
                <span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">1</span>)&#123;
                    duplication[<span class="hljs-number">0</span>] = begin;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                &#125;<span class="hljs-keyword">else</span>&#123;
                    duplication[<span class="hljs-number">0</span>] = mid+<span class="hljs-number">1</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(count &gt; (mid - begin + <span class="hljs-number">1</span>))&#123;
                end = mid;
            &#125;<span class="hljs-keyword">else</span>&#123;
                begin = mid + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++)&#123;
            <span class="hljs-keyword">if</span>(numbers[i] &gt;= begin &amp;&amp; numbers[i] &lt;= end)&#123;
                count++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> count;
    &#125;</code></pre></div><h3 id="4-二维数组中的查找"><a class="markdownIt-Anchor" href="#4-二维数组中的查找"></a> 4、二维数组中的查找</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><p><a class="btn" href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>设目标数字为 target，该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，可从右上角开始查找，若右上角数字等于 target，则找到；若右上角数字大于 target，则target 不会在该数字当前列以及右边列，将列数减一，下次搜索时右上角元素为当前元素的左边一个位置；若右上角数字小于 target，则target 不会在该数字当前行以及上边列，将行数加一，下次搜索时右上角元素为当前元素的上边一个位置。这样就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。<br></p><p>也可从左下角开始查找，时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p></div><div class="hljs"><pre><code class="hljs java">Consider the following matrix:
[
  [<span class="hljs-number">1</span>,   <span class="hljs-number">4</span>,  <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>],
  [<span class="hljs-number">2</span>,   <span class="hljs-number">5</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>],
  [<span class="hljs-number">3</span>,   <span class="hljs-number">6</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">22</span>],
  [<span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">17</span>, <span class="hljs-number">24</span>],
  [<span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">26</span>, <span class="hljs-number">30</span>]
]
 
Given target = <span class="hljs-number">5</span>, <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>.
Given target = <span class="hljs-number">20</span>, <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>.    
    
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> [][] array)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == array)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-keyword">int</span> rowBegin = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> colEnd = array[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(rowBegin &lt;= array.length - <span class="hljs-number">1</span> &amp;&amp; colEnd &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span>(array[rowBegin][colEnd] == target)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[rowBegin][colEnd] &gt; target)&#123;
                colEnd--;
            &#125;<span class="hljs-keyword">else</span>&#123;
                rowBegin++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;</code></pre></div><h3 id="5-替换空格"><a class="markdownIt-Anchor" href="#5-替换空格"></a> 5、替换空格</h3><div class="note note-danger"><p>题目：<br></p><p>将一个字符串中的空格替换成 “%20”。</p><p><a class="btn" href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>时间复杂度为O(n^2)：从头到尾扫描字符串，遇到空格字符，把该字符后面的所有字符都向后移动两个字节，并把该字符替换为 %20。</p></li><li><p>时间复杂度为O(n)：先遍历一次字符串，计算出空格字符的数量，根据该数量扩充原字符串（每有一个空格字符，扩充两个字节）。用 p1 指向原字符串尾部，用 p2 指向扩充后的字符串尾部，向前移动 p1 指针，将其指向字符复制到 p2 所指向位置，p2 也随之移动，若该字符为空格，则 p2 处应该插入 %20，直至 p1 和 p2 指向同一位置，表示所有空格已替换完毕。</p></li></ol><p>采用第二种思路。<br></p><p>相关题目：<br></p><p>有两个排序数组 A1 和 A2，内存在 A1 的末尾有足够多的空余空间容纳 A2。把 A2 中所有的数字插入 A1中，并且所有的数字是排序的。这题从后往前复制即可。</p></div><div class="hljs"><pre><code class="hljs java">Input:
<span class="hljs-string">"A B"</span>
 
Output:
<span class="hljs-string">"A%20B"</span>

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == str)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">""</span>))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
        &#125;
    	<span class="hljs-keyword">int</span> p1 = str.length() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= p1; i++)&#123;
            <span class="hljs-keyword">if</span>(str.charAt(i) == <span class="hljs-string">' '</span>)&#123;
                str.append(<span class="hljs-string">"  "</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">int</span> p2 = str.length() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(p1 &lt; p2)&#123;
            <span class="hljs-keyword">char</span> temp = str.charAt(p1--);
            <span class="hljs-keyword">if</span>(temp == <span class="hljs-string">' '</span>)&#123;
                str.setCharAt(p2--, <span class="hljs-string">'0'</span>);
                str.setCharAt(p2--, <span class="hljs-string">'2'</span>);
                str.setCharAt(p2--, <span class="hljs-string">'%'</span>);
            &#125;<span class="hljs-keyword">else</span>&#123;
                str.setCharAt(p2--, temp);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> str.toString();
    &#125;</code></pre></div><h3 id="6-从尾到头打印链表"><a class="markdownIt-Anchor" href="#6-从尾到头打印链表"></a> 6、从尾到头打印链表</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p><p><a class="btn" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：</p><ol><li><p>反转链表（头插法），接着从头到尾输出链表的节点值。这样做会改变原链表的结构。</p></li><li><p>从头到尾将链表的节点值压入栈中，再从栈顶弹出节点值。</p></li><li><p>与第二种思路类似，采用递归的方法完成任务。</p></li></ol></div><div class="hljs"><pre><code class="hljs java">   
<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	反转链表后再输出</span>
<span class="hljs-comment">*/</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;
       ListNode listNodeHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);
       ListNode temp;
       <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;
           temp = listNode.next;
           listNode.next = listNodeHead.next;
           listNodeHead.next = listNode;
           listNode = temp;
       &#125;
       listNode = listNodeHead.next;
       ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
       <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;
           list.add(listNode.val);
           listNode = listNode.next;
       &#125;
       <span class="hljs-keyword">return</span> list;
   &#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	压栈法</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == listNode)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
       &#125;
       Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
       <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;
           stack.push(listNode.val);
           listNode = listNode.next;
       &#125;
       ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
       <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;
           list.add(stack.pop());
       &#125;
       <span class="hljs-keyword">return</span> list;
   &#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	递归法</span>
<span class="hljs-comment">*/</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;
       ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
       <span class="hljs-keyword">if</span>(listNode != <span class="hljs-keyword">null</span>)&#123;
           list = printListFromTailToHead(listNode.next);
           list.add(listNode.val);
       &#125;
       <span class="hljs-keyword">return</span> list;
   &#125;</code></pre></div><h3 id="7-重建二叉树"><a class="markdownIt-Anchor" href="#7-重建二叉树"></a> 7、重建二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>前序遍历的第一个数字就是根节点的值，得到该数字在中序遍历的位置，中序遍历中位于该位置之前的数字都是左子树节点的值；中序遍历中位于该位置之后的数字都是右子树节点的值。再递归从子树中不断按照上述步骤确定各子树根节点。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

<span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++)&#123;
        map.put(inorder[i],i);
    &#125;
    <span class="hljs-keyword">return</span> buildTreeFunction(preorder, <span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTreeFunction</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preBegin, <span class="hljs-keyword">int</span> preEnd, <span class="hljs-keyword">int</span> in)</span></span>&#123;
    <span class="hljs-keyword">if</span>(preBegin &gt; preEnd)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    TreeNode treeNode = <span class="hljs-keyword">new</span> TreeNode(preorder[preBegin]);
    <span class="hljs-keyword">int</span> place = map.get(preorder[preBegin]);
    <span class="hljs-keyword">int</span> leftCount = place - in;
    treeNode.left = buildTreeFunction(preorder, preBegin + <span class="hljs-number">1</span>, preBegin + leftCount, in);
    treeNode.right = buildTreeFunction(preorder, preBegin + leftCount + <span class="hljs-number">1</span>, preEnd, in + leftCount + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> treeNode;
&#125;</code></pre></div><h3 id="8-二叉树的下一个节点"><a class="markdownIt-Anchor" href="#8-二叉树的下一个节点"></a> 8、二叉树的下一个节点</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p><a class="btn" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>如果一个节点有右子树，那么中序遍历下这个节点的下一个节点为该右子树最左边的节点。</li><li>如果一个节点无右子树，且该节点为其父节点的左子节点，那么中序遍历下这个节点的下一个节点为该节点的父节点。</li><li>如果一个节点无右子树，且该节点为其父节点的右子节点，那么可以沿父节点一直向上遍历，直到找到某个节点为其父节点的左子节点，那么该节点的父节点就为我们要寻找的节点。</li><li>以上都没找到，则该节点为该树中序遍历的最后一个节点。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeLinkNode <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode pNode)</span></span>&#123;
    <span class="hljs-keyword">if</span>(pNode == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">if</span>(pNode.right != <span class="hljs-keyword">null</span>)&#123;
        pNode = pNode.right;
        <span class="hljs-keyword">while</span>(pNode.left != <span class="hljs-keyword">null</span>)&#123;
            pNode = pNode.left;
        &#125;
        <span class="hljs-keyword">return</span> pNode;
    &#125;<span class="hljs-keyword">else</span>&#123;
        <span class="hljs-keyword">while</span>(pNode.next != <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">if</span>(pNode.next.left == pNode)&#123;
                <span class="hljs-keyword">return</span> pNode.next;
            &#125;<span class="hljs-keyword">else</span>&#123;
                pNode = pNode.next;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre></div><h3 id="9-用两个栈实现队列"><a class="markdownIt-Anchor" href="#9-用两个栈实现队列"></a> 9、用两个栈实现队列</h3><div class="note note-danger"><p>题目：<br></p><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作，即在队列尾部插入节点以及在队列头部删除节点。</p><p><a class="btn" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>插入节点可直接将节点压入 stack1 栈中，弹出节点时，判断 stack2 栈是否为空，若为空，则依次将 stack1 栈中数据弹出并压入 stack2 栈中，这样完成数据逆序操作，弹出 stack2 栈顶元素，即弹出了头节点；若不为空，则直接弹出 stack2 栈顶元素，即弹出头节点。</p><p>相关题目：<br></p><p>用两个队列实现一个栈。<br></p><p>压入节点可直接将节点加入 queue1 队列中，弹出节点时，判断 queue1 队列是否为空，若不为空，则依次将 queue1 队列中数据删除并加入 queue2 队列中，直至 queue1 队列只剩一个节点，该节点即为待弹出节点；若为空，依次将 queue2 队列中数据删除并加入 queue1 队列中，直至 queue2 队列只剩一个节点，该节点即为待弹出节点。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;
    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;
        stack1.push(node);
    &#125;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;
            <span class="hljs-keyword">while</span>(!stack1.isEmpty())&#123;
                stack2.push(stack1.pop());
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(stack2.isEmpty())&#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Queue is empty!"</span>);
        &#125;
        <span class="hljs-keyword">return</span> stack2.pop();
    &#125;
&#125;</code></pre></div><h3 id="10-斐波拉契数列"><a class="markdownIt-Anchor" href="#10-斐波拉契数列"></a> 10、斐波拉契数列</h3><div class="note note-danger"><p>题目：<br></p><p>写一个函数，输入 n，求斐波那契数列的第 n 项。</p><p><a class="btn" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p><p>斐波拉契数列定义如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>n</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>n</mi><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> if </mtext><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f(n)=\left\{\begin{array}{ll}0, &amp; \text { if } n=0 \\1, &amp; \text { if } n=1 \\f(n-1)+f(n-2), &amp;\text { if }n&gt;1 \end{array}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em"><span style="top:-2.49999em"><span class="pstrut" style="height:3.15em"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-3.15001em"><span class="pstrut" style="height:3.15em"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30002em"><span class="pstrut" style="height:3.15em"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:.5em"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em"><span style="top:-4.21em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord text"><span class="mord"> if </span></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>一般该题最直接的解法是递归法，但是会有大量的重复计算。因此可以从下往上计算，时间复杂度是O(n)。</p></li><li><p>第二种方法是借助下列数学公式，求矩阵的乘方，要求 n 次方，可采用递归实现 n/2 次方，这里时间复杂度是O(logn)。</p></li></ol><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><msup><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{bmatrix} f(n) &amp; f(n-1)\\ f(n-1) &amp; f(n-2)\end{bmatrix}=\begin{bmatrix} 1 &amp; 1\\ 1 &amp; 0\end{bmatrix}^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-.95003em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-.95003em"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span><span class="arraycolsep" style="width:.5em"></span><span class="arraycolsep" style="width:.5em"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em"><span style="top:-3.61em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9500000000000004em"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em"><span style="top:-3.9029000000000003em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>这里采用第一种思路。</p><p>相关题目：<br></p><ol><li>青蛙跳台阶问题。一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶，问该青蛙跳上一个 n 级的台阶共有多少种跳法。</li></ol><p>若只有 0 级台阶，那只有 0 种跳法；若只有 1 级台阶，那只有 1 种跳法；若只有 2 级台阶，那只有 2 种跳法；若台阶数量大于 2，我们把跳 n 级台阶的跳法定义为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，第一次跳 1 级台阶，此时跳法就为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，第一次跳 2 级台阶，此时跳法就为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = f(n-1) + f(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，与斐波拉契数列相似。</p><ol start="2"><li>青蛙跳台阶问题。一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶，…，也可以跳上 n 级台阶，问该青蛙跳上一个 n 级的台阶共有多少种跳法。</li></ol><p>总共有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">f(n) = 2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>跳法。</p><ol start="3"><li>用 2x1 的小矩形无重叠的覆盖一个 2x8 的大矩形，总共有多少种方法。</li></ol><p>记方法的种数为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(8)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span></span></span></span>，在最左边竖着覆盖，则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>，在最左边横着覆盖，则为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span></span></span></span>，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>8</mn><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(8)=f(6)+f(7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord">7</span><span class="mclose">)</span></span></span></span>，也形似斐波拉契数列。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;
        <span class="hljs-keyword">return</span> n;
    &#125;
    <span class="hljs-keyword">int</span> fb0 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> fb1 = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;
        ans = fb0 + fb1;
        fb0 = fb1;
        fb1 = ans;
    &#125;
    <span class="hljs-keyword">return</span> ans;
&#125;</code></pre></div><h3 id="11-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#11-旋转数组的最小数字"></a> 11、旋转数组的最小数字</h3><div class="note note-danger"><p>题目：<br></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><p><a class="btn" href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>一般该题最直接的解法是从头到尾遍历数组，但时间复杂度是O(n)。</p></li><li><p>我们可以发现，旋转数组是由两个排序数组组成的，数组中第一个元素大于等于最后一个元素（一般情况下），两个数组的分界处，第二个数组的开头元素，即为整个数组的最小元素。类似二分法，用两个指针分别指向第一个元素和最后一个元素，第三个指针指向那两个指针中间的一个元素，若该元素大于等于第一个指针指向的元素，则该中间元素还在第一组排序数组中，将第一个指针移至该元素处；若该元素小于等于第二个指针指向的元素，则该中间元素在第二组排序数组中，将第二个指针移至该元素处。重复上述过程，直至那两个指针相邻，找到数组分界处。</p><p>· 特殊情况1：若没有旋转，数组中第一个元素小于最后一个元素，则第一个元素就是要寻找的。这可以在初始化第三个指针时先直接让它指向第一个元素。</p><p>· 特殊情况2：数组中数字重复，三个指针指向元素相等，无法判断第三个指针指向元素属于哪个数组，这时只能用顺序查找法。</p></li></ol><p>这里采用第二种思路。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == array || array.length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Invalid array!"</span>);
    &#125;
    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> end = array.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> mid = begin; <span class="hljs-comment">//初始化begin，可以在未旋转的这种特殊情况下，直接输出第一个元素，也就是最小的元素</span>
    <span class="hljs-keyword">while</span>(array[begin] &gt;= array[end])&#123;
        <span class="hljs-keyword">if</span>(end - begin == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> array[end];
        &#125;
        <span class="hljs-keyword">if</span>(array[begin] == array[end] &amp;&amp; array[begin] == array[mid])&#123;
            <span class="hljs-keyword">return</span> minNum(array, begin, end);
        &#125;
        mid = (begin + end) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(array[mid] &gt;= array[begin])&#123;
            begin = mid;
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[mid] &lt;= array[end])&#123;
            end = mid;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> array[end];
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;
    <span class="hljs-keyword">int</span> res = array[begin];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin + <span class="hljs-number">1</span>; i &lt;= end; i++)&#123;
        <span class="hljs-keyword">if</span>(res &gt; array[i])&#123;
            res = array[i];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="12-矩阵中的路径"><a class="markdownIt-Anchor" href="#12-矩阵中的路径"></a> 12、矩阵中的路径</h3><div class="note note-danger"><p>题目：<br></p><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如下面的矩阵包含了一条 bfce 路径。</p><p><a class="btn" href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p><p><img src="https://i.loli.net/2020/07/14/SZoIqsjue75Wfnb.png" srcset="/img/loading.gif" alt="示意图"></p></div><div class="note note-primary"><p>思路分析：<br></p><p>直接采用回溯法，遍历起点位置，然后按照上下左右的顺序进行递归。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPath</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">char</span>[] str)</span></span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == matrix || rows &lt;= <span class="hljs-number">0</span> || cols &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">char</span>[][] buildedMatrix = buildMatrix(matrix, rows, cols);
    <span class="hljs-keyword">boolean</span>[][] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)&#123;
            <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, i, j, str, marked, <span class="hljs-number">0</span>))&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*    回溯法寻找</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findWay</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] buildedMatrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">boolean</span>[][] marked, <span class="hljs-keyword">int</span> point)</span></span>&#123;
    <span class="hljs-keyword">if</span>(point == str.length)&#123; <span class="hljs-comment">//先判断这个条件，避免下一个判断出现数组索引异常</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(row &lt; <span class="hljs-number">0</span> || row &gt;= rows || col &lt; <span class="hljs-number">0</span> || col &gt;= cols 
       || marked[row][col] == <span class="hljs-keyword">true</span> || str[point] != buildedMatrix[row][col])&#123; <span class="hljs-comment">//注意要先判断row和col有没有越界，不然会出现数组索引异常</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    marked[row][col] = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row - <span class="hljs-number">1</span>, col, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 上</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row + <span class="hljs-number">1</span>, col, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 下</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row, col - <span class="hljs-number">1</span>, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 左</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(findWay(buildedMatrix, rows, cols, row, col + <span class="hljs-number">1</span>, str, marked, point + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 右</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    marked[row][col] = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*    将输入的一维数组转换为问题所描述的矩阵</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[][] buildMatrix(<span class="hljs-keyword">char</span>[] matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)&#123;
    <span class="hljs-keyword">char</span>[][] buildedMatrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[rows][cols];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++)&#123;
            buildedMatrix[i][j] = matrix[cols * i + j];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> buildedMatrix;
&#125;</code></pre></div><h3 id="13-机器人的运动范围"><a class="markdownIt-Anchor" href="#13-机器人的运动范围"></a> 13、机器人的运动范围</h3><div class="note note-danger"><p>题目：<br></p><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p><a class="btn" href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>与上题类似，采用回溯法，注意这里没说不能进入曾经进入过的格子，但是由于是计算能走的格子数，每次进入一个新格子，自然就会尝试下一步所有能走的可能，因此不必再进入曾经进入过的格子，减少计算量，避免栈溢出。可以发现，若可以进入曾经进入过的格子，那么下面的代码会陷入死循环，不停的往下走再往上走回来，造成栈溢出。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span></span>&#123;
    <span class="hljs-keyword">if</span>(threshold &lt; <span class="hljs-number">0</span> || rows &lt; <span class="hljs-number">0</span> || cols &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">boolean</span>[][] marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];
    move(marked, threshold, rows, cols, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> cnt;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[][] marked, <span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>&#123;
    <span class="hljs-keyword">if</span>(col &lt; <span class="hljs-number">0</span> || col &gt;= cols || row &lt; <span class="hljs-number">0</span> || row &gt;= rows || marked[row][col] == <span class="hljs-keyword">true</span> || calSum(row, col) &gt; threshold)&#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    cnt++;
    marked[row][col] = <span class="hljs-keyword">true</span>;
    move(marked, threshold, rows, cols, row - <span class="hljs-number">1</span>, col);
    move(marked, threshold, rows, cols, row + <span class="hljs-number">1</span>, col);
    move(marked, threshold, rows, cols, row, col - <span class="hljs-number">1</span>);
    move(marked, threshold, rows, cols, row, col + <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span></span>&#123;
    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(row % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>)&#123;
        sum = sum + row % <span class="hljs-number">10</span>;
        row = row / <span class="hljs-number">10</span>;
    &#125;
    <span class="hljs-keyword">while</span>(col % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>)&#123;
        sum = sum + col % <span class="hljs-number">10</span>;
        col = col / <span class="hljs-number">10</span>;
    &#125;
    <span class="hljs-keyword">return</span> sum;</code></pre></div><h3 id="14-剪绳子"><a class="markdownIt-Anchor" href="#14-剪绳子"></a> 14、剪绳子</h3><div class="note note-danger"><p>题目：<br></p><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。注意：绳子也是按照整数进行裁剪的。</p><p><a class="btn" href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>动态规划法。</li><li>贪婪算法。根据数学推导可得，当绳子长度大于等于 5 时，应尽可能剪更多长度为 3 的绳子。当绳子长度小于等于 4 时，剪成两段长度为 2 的绳子。</li></ol></div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">/**</span>
<span class="hljs-comment">   *	动态规划法</span>
<span class="hljs-comment">   */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">2</span>)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">3</span>)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
       &#125;
       <span class="hljs-keyword">int</span>[] profit = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];
       profit[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
       profit[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
       profit[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
       profit[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;
       <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &lt;= target; i++)&#123;
           max = <span class="hljs-number">0</span>;
           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; j++)&#123;
               <span class="hljs-keyword">if</span>(max &lt; profit[j] * profit[i - j])&#123;
                   max = profit[j] * profit[i - j];
               &#125;
           &#125;
           profit[i] = max;
       &#125;
       <span class="hljs-keyword">return</span> profit[target];
   &#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	贪婪算法</span>
<span class="hljs-comment">*/</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(target &lt; <span class="hljs-number">2</span>)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target == <span class="hljs-number">3</span>)&#123;
           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
       &#125;
       <span class="hljs-keyword">int</span> num_3 = target / <span class="hljs-number">3</span>;
       <span class="hljs-keyword">if</span>(target % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;
           num_3--;
           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">2</span> * (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, num_3);
       &#125;
       <span class="hljs-keyword">return</span> ((target % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>) * (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, num_3);
   &#125;</code></pre></div><h3 id="15-二进制中-1-的个数"><a class="markdownIt-Anchor" href="#15-二进制中-1-的个数"></a> 15、二进制中 1 的个数</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个整数，输出该数二进制表示中 1 的个数。</p><p><a class="btn" href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>借助初始值为 1 的辅助数字，辅助数字不断左移 1 位，进而从该数字的最低位开始一次判断该位是否为 1。数字有多少位就要循环多少次。</p></li><li><p>把一个数字减去 1 ，它的二进制表达中，最右边的 1 会变为 0，在这之右的 0 会变成 1，在这之左的位不会发生改变。因此，将一个数字与该数字减一的结果进行与操作，会使得原数字最右边的 1 变为 0，其余无变化。不断循环该操作，就能找出数字二进制表达式中 1 的个数。这种方法更快速。</p></li></ol><p>More：除法的效率会比位移操作低很多，在实际当中可以用移位运算符代替乘除法；Integer.bitCount(n)。<br></p><p>相关题目：<br></p><ol><li>用一条语句判断一个整数是不是 2 的整数次方。如果一个数字是 2 的整数次方，那么它的二进制表示中只有一个 1 ，可以用前面的办法：因此，将一个数字与该数字减一的结果进行一次与操作，如果是的话，那么结果为 0。</li><li>输入两个整数 m 和 n，计算需要改变 m 的二进制中几位才能得到 n。将 m 与 n 异或处理，再计算得到的数字中 1 的个数。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">*	方法1</span>
<span class="hljs-comment">*/</span>    
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
       <span class="hljs-keyword">int</span> helper = <span class="hljs-number">1</span>;
       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">while</span>(helper != <span class="hljs-number">0</span>)&#123;
           <span class="hljs-keyword">if</span>((n &amp; helper) != <span class="hljs-number">0</span>)&#123;
               count++;
           &#125;
           helper = helper &lt;&lt; <span class="hljs-number">1</span>;
       &#125;
       <span class="hljs-keyword">return</span> count;
   &#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	方法2</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
       <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;
           count++;
           n = n &amp; (n - <span class="hljs-number">1</span>);
       &#125;
       <span class="hljs-keyword">return</span> count;
   &#125;</code></pre></div><h2 id="第三章-高质量的代码"><a class="markdownIt-Anchor" href="#第三章-高质量的代码"></a> 第三章 高质量的代码</h2><h3 id="16-数值的整数次方"><a class="markdownIt-Anchor" href="#16-数值的整数次方"></a> 16、数值的整数次方</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。保证base和exponent不同时为0。</p><p><a class="btn" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>该题首要的应该考虑一些特殊情况，如 exponent 是负数，则应将它化为整数后正常求次方，再将最后的结果求导数。但这时如果 base 是 0，那么求倒数会使得程序出错，这些都应考虑在内。再就是优化代码时间复杂度，按照正常的思路，是循环 exponent - 1 次乘法，但还可以优化。若求一个数的 32 次方，则可以由它的 16 次方平方得到，而 16 次方可以由 8次方平方得到，8 次方可以由 4次方的平方得到…注意，下面的代码中，用右移运算符代替除以 2，用位与运算符代替用 % 判断一个数是否是奇数，以提高程序效率。</p></div><div class="hljs"><pre><code class="hljs JAVA">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;
      <span class="hljs-keyword">double</span> res;
      <span class="hljs-keyword">if</span>(base == <span class="hljs-number">0</span>)&#123;
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      &#125;
      <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">0</span>)&#123;
          <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / calPower(base, -exponent);
      &#125;<span class="hljs-keyword">else</span>&#123;
          <span class="hljs-keyword">return</span> calPower(base, exponent);
      &#125;
&#125;
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calPower</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span></span>&#123;
      <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">0</span>)&#123;
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
      &#125;
      <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">1</span>)&#123;
          <span class="hljs-keyword">return</span> base;
      &#125;
      <span class="hljs-keyword">double</span> res = calPower(base, exponent &gt;&gt; <span class="hljs-number">1</span>);
      res = res * res;
      <span class="hljs-keyword">if</span>((exponent &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123;
          res = res * base;
      &#125;
      <span class="hljs-keyword">return</span> res;
  &#125;</code></pre></div><h3 id="17-打印从-1-到最大的-n-位数"><a class="markdownIt-Anchor" href="#17-打印从-1-到最大的-n-位数"></a> 17、打印从 1 到最大的 n 位数</h3><div class="note note-danger"><p>题目：<br></p><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。本题代码自己测试即可。</p></div><div class="note note-primary"><p>思路分析：<br></p><p>首先考虑不正常的输入情况，如输入的数字小于等于 0，是非法输入。再就是输入的数字如果比较大，那么要打印的数字可能超过 int 范围，甚至也可能超过 long 范围，因此可用 char 数组来表示数字。首先考虑打印方法，输入一个 char 数组，打印出数字，但是数字最前面的 0 不应该打出来，如 098 应打印为 98。</p><ol><li><p>不停的在末位加 1，然后做进位处理得到对应的 char 数组，再打印。直至最高位出现了进位，停止循环。这样的代码比较长。</p></li><li><p>该问题实际上是 n 位数字从 0~9 的全排列，因此可用递归方法，全排列出所有可能。</p></li></ol><p>采用第二种思路演示。<br></p><p>相关题目（如果题目是 n 位整数而又没有限定 n 的取值范围，这时应考虑大数问题，可用字符串处理）<br></p><ol><li>本题中用 char 数组未充分利用内存，一位 char 能表示 256 个字符，而我们只用到了 0~9。有没有更高效的方式表示大数。（bitmap）</li><li>定义一个函数，实现任意两个整数的加法。这也是大数问题，还要考虑数字有负数该怎么办。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print1ToMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span></span>&#123;
        <span class="hljs-keyword">if</span>(length &lt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;<span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[length];
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;
                c[i] = <span class="hljs-string">'0'</span>;
            &#125;
            print1ToMaxRecursively(c, length, <span class="hljs-number">0</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print1ToMaxRecursively</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] c, <span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> index)</span></span>&#123;
        <span class="hljs-keyword">if</span>(index == length)&#123;
            printNum(c);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)&#123;
            c[index] = (<span class="hljs-keyword">char</span>)(i+<span class="hljs-number">48</span>);
            print1ToMaxRecursively(c, length, index + <span class="hljs-number">1</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNum</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] c)</span></span>&#123;
        <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c.length; i++)&#123;
            <span class="hljs-keyword">if</span>(c[i] != <span class="hljs-string">'0'</span> &amp;&amp; flag == <span class="hljs-keyword">false</span>)&#123;
                flag = <span class="hljs-keyword">true</span>;
            &#125;
            <span class="hljs-keyword">if</span>(flag)&#123;
                System.out.print(c[i]);
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(flag)&#123;
            System.out.println();
        &#125;
    &#125;</code></pre></div><h3 id="181-在o1时间内删除链表节点"><a class="markdownIt-Anchor" href="#181-在o1时间内删除链表节点"></a> 18.1、在O(1)时间内删除链表节点</h3><div class="note note-danger"><p>题目：<br></p><p>给定单向链表的头指针和一个节点指针，删除该节点指针。</p></div><div class="note note-primary"><p>思路分析：<br></p><p>正常的思路是从头开始找到这个节点的前一个节点，让该节点的 next 指向待删除节点的下一个节点。但是题目要求时间复杂度为O(n)，可以直接将待删除节点的下一个节点的内容复制到待删除节点上。需要考虑一些特殊情况。注意这里没说被删除节点一定在该链表中，但是判断一个节点是否在链表中，需要O(n)时间复杂度，题目只允许O(1)，因此这里假设输入的被删除节点都在链表中。</p><ol><li>输入为 null；</li><li>链表只有一个节点，删除该节点；</li><li>链表不只有一个节点，删除尾节点，这时还是要循环找到需要的节点。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || tobeDelete == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">if</span>(tobeDelete.next != <span class="hljs-keyword">null</span>)&#123;
        tobeDelete.val = tobeDelete.next.val;
        tobeDelete.next = tobeDelete.next.next;
    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>)&#123;
        head = <span class="hljs-keyword">null</span>;
    &#125;<span class="hljs-keyword">else</span>&#123;
        ListNode temp = head;
        <span class="hljs-keyword">while</span>(temp.next != tobeDelete)&#123;
            temp = temp.next;
        &#125;
        temp.next = <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">return</span> head;
&#125;</code></pre></div><h3 id="182-删除链表中重复的节点"><a class="markdownIt-Anchor" href="#182-删除链表中重复的节点"></a> 18.2、删除链表中重复的节点</h3><div class="note note-danger"><p>题目：<br></p><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p><p><a class="btn" href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>双指针法。注意需要先把头节点处理完全，再处理头节点之后的节点。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode pHead)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span> || pHead.next == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> pHead;
    &#125;
    <span class="hljs-keyword">while</span>(pHead.next != <span class="hljs-keyword">null</span> &amp;&amp; pHead.val == pHead.next.val)&#123;
        <span class="hljs-keyword">while</span>(pHead.next != <span class="hljs-keyword">null</span> &amp;&amp; pHead.val == pHead.next.val)&#123;
            pHead = pHead.next;
        &#125;
        <span class="hljs-keyword">if</span>(pHead.next == <span class="hljs-keyword">null</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
        pHead = pHead.next;
    &#125;
    ListNode preNode = pHead;
    ListNode temp = pHead.next;
    <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; temp.next != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span>(temp.next != <span class="hljs-keyword">null</span> &amp;&amp; temp.val == temp.next.val)&#123;
            <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span> &amp;&amp; temp.val == temp.next.val)&#123;
                temp = temp.next;
            &#125;
            preNode.next = temp.next;
            temp = temp.next;
        &#125;<span class="hljs-keyword">else</span>&#123;
            temp = temp.next;
            preNode = preNode.next; 
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> pHead;
&#125;</code></pre></div><h3 id="19-正则表达式匹配"><a class="markdownIt-Anchor" href="#19-正则表达式匹配"></a> 19、正则表达式匹配</h3><div class="note note-danger"><p>题目：<br></p><p>请实现一个函数用来匹配包括 ‘.’ 和 ‘*’ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而 ’ * ’ 表示它前面的字符可以出现任意次（包含 0 次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab<em>ac</em>a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>本题采用动态规划法。 dp[ i+1 ] [ j+1 ]表示字符串中第 1~i 个字符是否与模式中第 1~j 个字符相匹配。</p><ol><li>若 p.charAt( j ) 为 ‘ . ’ 或者与 s.charAt( i ) 相等，那么dp[ i+1 ] [ j+1 ] = dp[ i ] [ j ]；</li><li>若 p.charAt( j ) 为 ‘ * ’：若p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != ‘.’，则 <code>x*</code>应相当于为空；p 的当前字符的前一个字符能与 s 当前字符匹配上，则有三种情况：1.<code>x*</code>相当于一个字符。2.<code>x*</code>相当于多个字符。3.<code>x*</code>相当于空。</li><li>注意需要初始化以及防止数组索引小于0。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || p == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length() + <span class="hljs-number">1</span>][p.length() + <span class="hljs-number">1</span>];
    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; p.length(); i++)&#123; <span class="hljs-comment">//"aab"  "c*a*b"</span>
        <span class="hljs-keyword">if</span>(p.charAt(i) == <span class="hljs-string">'*'</span> &amp;&amp; dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>])&#123;
            dp[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = <span class="hljs-keyword">true</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p.length(); j++)&#123;
            <span class="hljs-keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="hljs-string">'.'</span>)&#123;
                dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i][j];
            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; p.charAt(j) == <span class="hljs-string">'*'</span>)&#123;
                <span class="hljs-keyword">if</span>(p.charAt(j - <span class="hljs-number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j - <span class="hljs-number">1</span>) != <span class="hljs-string">'.'</span>)&#123;
                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
                &#125;<span class="hljs-keyword">else</span>&#123;
                    dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = (dp[i + <span class="hljs-number">1</span>][j] || dp[i][j + <span class="hljs-number">1</span>] || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dp[s.length()][p.length()];
&#125;</code></pre></div><h3 id="20-表示数值的字符串"><a class="markdownIt-Anchor" href="#20-表示数值的字符串"></a> 20、表示数值的字符串</h3><div class="note note-danger"><p>题目：<br></p><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</p><p><a class="btn" href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>这个情况很复杂，一个一个讨论，看代码的注释即可。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(String s)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//跳过字符串最开始的空格</span>
    <span class="hljs-keyword">while</span>(index &lt; s.length() &amp;&amp; s.charAt(index) == <span class="hljs-string">' '</span>)&#123;
        index++;
    &#125;
    <span class="hljs-comment">//如果只有空格，false</span>
    <span class="hljs-keyword">if</span>(index == s.length())&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-comment">// dot小数的个数，num数字的个数，e指数符号的个数</span>
    <span class="hljs-keyword">int</span> dot = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//出现正负号，它们的后面一个不能再是正负号，不能后面无元素</span>
    <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>)&#123;
        index++;
        <span class="hljs-keyword">if</span>(index == s.length())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">while</span>(index &lt; s.length())&#123;
        <span class="hljs-keyword">if</span>(s.charAt(index) &gt;= <span class="hljs-string">'0'</span> &amp;&amp; s.charAt(index) &lt;= <span class="hljs-string">'9'</span>)&#123;
            num++;
            index++;
            <span class="hljs-comment">//出现小数点，只能有一个小数点，且在这之前不能有e</span>
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'.'</span>)&#123;
            <span class="hljs-keyword">if</span>(dot &gt; <span class="hljs-number">0</span> || e &gt; <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            <span class="hljs-comment">//防止“.”这种现象发生</span>
            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span> &amp;&amp; ((index + <span class="hljs-number">1</span>) == s.length() || s.charAt(index + <span class="hljs-number">1</span>) &lt; <span class="hljs-string">'0'</span> || s.charAt(index + <span class="hljs-number">1</span>) &gt; <span class="hljs-string">'9'</span>))&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            dot++;
            index++;
            <span class="hljs-comment">//出现e，e的前面不能不出现数字，且只能出现一次e，e的后面如果是正负号，需要像上面一样判断，如果e的后面无元素，即无元素或者是空格，也是不行的</span>
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'e'</span> || s.charAt(index) == <span class="hljs-string">'E'</span>)&#123;
            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span> || e &gt; <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            e++;
            index++;
            <span class="hljs-keyword">if</span>(index &lt; s.length() &amp;&amp; (s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>))&#123;
                index++;
                <span class="hljs-keyword">if</span>(index == s.length())&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                &#125;
                <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">'-'</span> || s.charAt(index) == <span class="hljs-string">'+'</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(index == s.length() || s.charAt(index) == <span class="hljs-string">' '</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            <span class="hljs-comment">//去掉结尾的空格</span>
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s.charAt(index) == <span class="hljs-string">' '</span>)&#123;
            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            <span class="hljs-keyword">while</span>(index &lt; s.length())&#123;
                <span class="hljs-keyword">if</span>(s.charAt(index) != <span class="hljs-string">' '</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                &#125;
                index++;
            &#125;
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div><h3 id="21-调整数组使奇数在偶数前"><a class="markdownIt-Anchor" href="#21-调整数组使奇数在偶数前"></a> 21、调整数组使奇数在偶数前</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p><a class="btn" href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>采用双指针，一个指向数组头，一个指向数组尾，向中间递进。若第一个指针发现偶数，第二个指针发现奇数，则调换它们的顺序。还可采用冒泡法，或者复制一个数组，先将数组奇偶个数求出来，再遍历数组将每个数字放到合适的类别中。注意，这里书中提到可以增加程序的扩展性，即未来不只是分开奇偶数，也可以有别的功能，这可以将判断函数加入进形参中，这样就增加了程序的扩展性。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">1</span>)&#123;
        <span class="hljs-keyword">return</span> nums;
    &#125;
    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> end = nums.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(begin &lt; end)&#123;
        <span class="hljs-keyword">while</span>(end &gt; begin &amp;&amp; (nums[end] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)&#123;
            end--;
        &#125;
        <span class="hljs-keyword">while</span>(end &gt; begin  &amp;&amp; (nums[begin] &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)&#123;
            begin++;
        &#125;
        <span class="hljs-keyword">int</span> temp = nums[begin];
        nums[begin] = nums[end];
        nums[end] = temp;
    &#125;
    <span class="hljs-keyword">return</span> nums;
&#125;</code></pre></div><h3 id="22-链表中倒数第-k-个节点"><a class="markdownIt-Anchor" href="#22-链表中倒数第-k-个节点"></a> 22、链表中倒数第 k 个节点</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><a class="btn" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>首先需要辨明边界条件， k 小于等于0，k 超过链表个数，输入头节点为 null。</p><ol><li><p>第一种方法是循环链表两次，第一次计算数链表的长度，第二次找到目标节点，这样效率较低。</p></li><li><p>第二种方法更好，先让一个指针从头节点往前走 k - 1 步，再新建一个指针指向头节点，让这两个指针同步再往前走，这样两个指针相距 k - 1，第一个指针走到末尾时，第二个指针指向的就是目标节点。</p></li></ol><p>相关题目：当我们用一个指针遍历链表不能完成任务时，可以尝试用两个指针。<br></p><ol><li>求链表的中间节点。可以定义两个指针，同时从链表头出发，一个指针每次走两步，一个指针每次走一步。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || k &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    ListNode begin  = head;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k - <span class="hljs-number">1</span>; i++)&#123;
        <span class="hljs-keyword">if</span>(begin != <span class="hljs-keyword">null</span>)&#123;
            begin = begin.next;
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        &#125;
    &#125;
    ListNode target = head;
    <span class="hljs-keyword">while</span>(begin.next != <span class="hljs-keyword">null</span>)&#123;
        begin = begin.next;
        target = target.next;
    &#125;
    <span class="hljs-keyword">return</span> target;
&#125;</code></pre></div><h3 id="23-链表中环的入口节点"><a class="markdownIt-Anchor" href="#23-链表中环的入口节点"></a> 23、链表中环的入口节点</h3><div class="note note-danger"><p>题目：<br></p><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><p><a class="btn" href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank">牛客网：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>双指针，都从头节点出发，一个每次走两步，一个每次走一步。快的指针若遇见 null，则链表中无环，若两指针相遇，则链表中有环。</p><ol><li>相遇节点处，得到相遇节点，通过该节点可以得到环的长度。再初始化两个指针，从头节点开始，一个节点先走环的长度的步数。从这之后，两个指针每次走 1 步，它们的相遇节点即为环入口节点。</li><li>相遇节点处，得到相遇节点。将快的指针重置为头节点，让两个指针每次走一步，两指针相遇节点即为环入口节点。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode pHead)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    ListNode p1 = pHead; <span class="hljs-comment">//快的指针</span>
    ListNode p2 = pHead; <span class="hljs-comment">//慢的指针</span>
    <span class="hljs-keyword">while</span>(p1 != <span class="hljs-keyword">null</span> &amp;&amp; p1.next !=<span class="hljs-keyword">null</span>)&#123;
        p1 = p1.next.next;
        p2 = p2.next;
        <span class="hljs-keyword">if</span>(p1 == p2)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(p1 == <span class="hljs-keyword">null</span> || p1.next == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;<span class="hljs-keyword">else</span>&#123;
        p1 = pHead;
        <span class="hljs-keyword">while</span>(p1 != p2)&#123;
            p1 = p1.next;
            p2 = p2.next;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> p1;
&#125;</code></pre></div><h3 id="24-反转链表"><a class="markdownIt-Anchor" href="#24-反转链表"></a> 24、反转链表</h3><div class="note note-danger"><p>题目：<br></p><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p><a class="btn" href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>注意边界条件。</p><ol><li>头插法。</li><li>递归法。</li><li>压栈法。</li><li>三指针法。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">*	递归法</span>
<span class="hljs-comment">*/</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;
           <span class="hljs-keyword">return</span> head;
       &#125;
       ListNode node = head.next;
       head.next = <span class="hljs-keyword">null</span>;
       ListNode newList = reverseList(node);
       node.next = head;
       <span class="hljs-keyword">return</span> newList;
   &#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	头插法</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;
           <span class="hljs-keyword">return</span> head;
       &#125;
       ListNode newList = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);
       ListNode tempOriginal = head;
       ListNode temp = <span class="hljs-keyword">null</span>;
       <span class="hljs-keyword">while</span>(tempOriginal != <span class="hljs-keyword">null</span>)&#123;
           temp = tempOriginal.next;
           tempOriginal.next = newList.next;
           newList.next = tempOriginal;
           tempOriginal = temp;
       &#125;
       <span class="hljs-keyword">return</span> newList.next;
   &#125;</code></pre></div><h3 id="25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#25-合并两个排序的链表"></a> 25、合并两个排序的链表</h3><div class="note note-danger"><p>题目：<br></p><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p><a class="btn" href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>递归法。</li><li>迭代法。</li></ol></div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">/**</span>
<span class="hljs-comment">   *	递归法</span>
<span class="hljs-comment">   */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;
           <span class="hljs-keyword">return</span> l2;
       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;
           <span class="hljs-keyword">return</span> l1;
       &#125;
       ListNode newHead= <span class="hljs-keyword">null</span>;
       <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;
           newHead = l1;
           newHead.next = mergeTwoLists(l1.next, l2);
       &#125;<span class="hljs-keyword">else</span>&#123;
           newHead = l2;
           newHead.next = mergeTwoLists(l1, l2.next);
       &#125;
       <span class="hljs-keyword">return</span> newHead;
   &#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	迭代法，注意这里边界条件在后面也做了一次判断，因此不需要在开头进行边界条件的判断</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;
       ListNode newHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);
       ListNode temp = newHead;
       <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>)&#123;
           <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;
               temp.next = l1;
               l1 = l1.next;
           &#125;<span class="hljs-keyword">else</span>&#123;
               temp.next = l2;
               l2 = l2.next;
           &#125;
           temp = temp.next;
       &#125;
       <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;
           temp.next = l2;
       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;
           temp.next = l1;
       &#125;
       <span class="hljs-keyword">return</span> newHead.next;

   &#125;</code></pre></div><h3 id="26-树的子结构"><a class="markdownIt-Anchor" href="#26-树的子结构"></a> 26、树的子结构</h3><div class="note note-danger"><p>题目：<br></p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br><img src="https://i.loli.net/2020/07/19/IP73Q45seH2YLKD.png" srcset="/img/loading.gif" alt=""></p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>第一个函数不断递归寻找 A树 中节点是否有能匹配上B树 的根节点。第二个函数不断递归判断是否含有 B树 的结构。注意，B为 null说明找到了，这个要放在前面。A为 null说明有可能找不到了，放在后面。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span> || B == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> isSubStructure2(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure2</span><span class="hljs-params">(TreeNode A, TreeNode B)</span></span>&#123;
    <span class="hljs-keyword">if</span>(B == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(A == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">if</span>(A.val != B.val)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> isSubStructure2(A.left, B.left) &amp;&amp; isSubStructure2(A.right, B.right);
&#125;</code></pre></div><h2 id="第四章-解决面试题的思路"><a class="markdownIt-Anchor" href="#第四章-解决面试题的思路"></a> 第四章 解决面试题的思路</h2><h3 id="27-二叉树的镜像"><a class="markdownIt-Anchor" href="#27-二叉树的镜像"></a> 27、二叉树的镜像</h3><div class="note note-danger"><p>题目：<br></p><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>递归即可。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
    mirrorTreeRecursively(root);
    <span class="hljs-keyword">return</span> root;
&#125;


<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mirrorTreeRecursively</span><span class="hljs-params">(TreeNode node)</span></span>&#123;
    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    TreeNode temp = node.left;
    node.left = node.right;
    node.right = temp;
    mirrorTreeRecursively(node.left);
    mirrorTreeRecursively(node.right);
&#125;</code></pre></div><h3 id="28-对称的二叉树"><a class="markdownIt-Anchor" href="#28-对称的二叉树"></a> 28、对称的二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><a class="btn" href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>一个树是对称的，那么它的 根-左-右 遍历节点应该与它的 根-右-左 遍历节点完全一样，注意也需要把遍历到的 null 考虑进去。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
    <span class="hljs-keyword">return</span> isSymmetric(root, root);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode node1, TreeNode node2)</span></span>&#123;
    <span class="hljs-keyword">if</span>(node1 == <span class="hljs-keyword">null</span> &amp;&amp; node2 == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(node1 == <span class="hljs-keyword">null</span> || node2 == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">if</span>(node1.val == node2.val)&#123;
        <span class="hljs-keyword">return</span> isSymmetric(node1.left, node2.right) &amp;&amp; isSymmetric(node1.right, node2.left);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre></div><h3 id="29-顺时针打印矩阵"><a class="markdownIt-Anchor" href="#29-顺时针打印矩阵"></a> 29、顺时针打印矩阵</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>定义四个索引，分别为：起始行，终点行，起始列，终点列。在循环中：</p><ol><li>在起始行，从起点列遍历至终点列，相当于从左到右，完成后起始行加一，若起始行大于终点行，则完成任务；</li><li>在终点列，从起始行遍历至终点行，想当于从上到下，完成后终点列减一，若终点列小于起点列，则完成任务；</li><li>在终点行，从终点列遍历至起点列，相当于从右到左，完成后终点行减一，若终点行小于起点行，则完成任务；</li><li>在起点列，从终点行遍历至起点行，相当于从下到上，完成后起点列加一，若起点列大于终点列，则完成任务。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;
    <span class="hljs-keyword">if</span>(matrix == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
    &#125;
    <span class="hljs-keyword">int</span> row = matrix.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(row + <span class="hljs-number">1</span>) * (col + <span class="hljs-number">1</span>)];
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = c; i &lt;= col; i++)&#123;
            array[index] = matrix[r][i];
            index++;
        &#125;
        <span class="hljs-keyword">if</span>(++r &gt; row)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r; i &lt;= row; i++)&#123;
            array[index] = matrix[i][col];
            index++;
        &#125;
        <span class="hljs-keyword">if</span>(--col &lt; c)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = col; i &gt;= c; i--)&#123;
            array[index] = matrix[row][i];
            index++;
        &#125;
        <span class="hljs-keyword">if</span>(--row &lt; r)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = row; i &gt;= r; i--)&#123;
            array[index] = matrix[i][c];
            index++;
        &#125;
        <span class="hljs-keyword">if</span>(++c &gt; col)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> array;
&#125;</code></pre></div><h3 id="30-包含-min-函数的栈"><a class="markdownIt-Anchor" href="#30-包含-min-函数的栈"></a> 30、包含 min 函数的栈</h3><div class="note note-danger"><p>题目：<br></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p><a class="btn" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>最开始想的是在类中定义一个成员变量，保存栈中最小的元素。但是，如果该元素被弹出，无法更新该成员变量的值，因此这个办法行不通。在该栈中定义两个栈，一个用于保存数据，一个用于保存最小的元素，当压入数据时，判断 min 栈栈顶元素是否小于该压入元素，若小于，则 min 栈再一次压入它的栈顶元素，若大于或者 min 栈为空，则压入该元素。弹出元素时，也要将 min 栈中的元素弹出。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; data = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; min = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;

&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;
    data.push(x);
    <span class="hljs-keyword">if</span>(min.isEmpty() || x &lt; min.peek())&#123;
        min.push(x);
    &#125;<span class="hljs-keyword">else</span>&#123;
        min.push(min.peek());
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
    data.pop();
    min.pop();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> data.peek();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> min.peek();
&#125;</code></pre></div><h3 id="31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#31-栈的压入-弹出序列"></a> 31、栈的压入、弹出序列</h3><div class="note note-danger"><p>题目：<br></p><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>定义一个辅助栈，如果下一个要弹出的数字刚好是栈顶元素，那么直接弹出；如果不是，那么把压栈序列剩余的数字依次压入辅助栈中，直至找到需要弹出的数字，若所有数字都压入栈中后仍然未找到该数字，那么该序列不为弹出序列。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(pushed == <span class="hljs-keyword">null</span> || popped == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">if</span>((pushed.length == <span class="hljs-number">0</span> &amp;&amp; popped.length != <span class="hljs-number">0</span>) || (pushed.length != <span class="hljs-number">0</span> &amp;&amp; popped.length == <span class="hljs-number">0</span>))&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">int</span> indexPush = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> indexPop = <span class="hljs-number">0</span>;
    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    <span class="hljs-keyword">while</span>(indexPop &lt; popped.length)&#123;
        <span class="hljs-keyword">while</span>(stack.isEmpty() || stack.peek() != popped[indexPop])&#123;
            <span class="hljs-keyword">if</span>(indexPush &gt;= pushed.length)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
            stack.push(pushed[indexPush++]);
        &#125;
        stack.pop();
        indexPop++;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;</code></pre></div><h3 id="321-从上到下打印二叉树"><a class="markdownIt-Anchor" href="#321-从上到下打印二叉树"></a> 32.1、从上到下打印二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p><a class="btn" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>将节点保存到容器中。每经过一个节点，弹出容器中的该节点，并将该节点的左右子节点保存到该容器尾巴处。遍历该容器。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
    &#125;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    queue.add(root);
    arrayList.add(root.val);
    <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;
        TreeNode treeNode = queue.poll();
        <span class="hljs-keyword">if</span>(treeNode.left != <span class="hljs-keyword">null</span>)&#123;
            queue.add(treeNode.left);
            arrayList.add(treeNode.left.val);
        &#125;
        <span class="hljs-keyword">if</span>(treeNode.right != <span class="hljs-keyword">null</span>)&#123;
            queue.add(treeNode.right);
            arrayList.add(treeNode.right.val);
        &#125;
    &#125;
    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arrayList.size()];
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(Integer i : arrayList)&#123;
        res[index++] = i;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="322-分行从上到下打印二叉树"><a class="markdownIt-Anchor" href="#322-分行从上到下打印二叉树"></a> 32.2 分行从上到下打印二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p><a class="btn" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>将节点保存到容器中。每经过一个节点，弹出容器中的该节点，并将该节点的左右子节点保存到该容器尾巴处。遍历该容器。同时定义两个变量，分别记录本层节点数以及下层节点数。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();
    &#125;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    queue.add(root);
    <span class="hljs-keyword">int</span> now = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;
    List&lt;List&lt;Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;Integer&gt; listTemp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    listTemp.add(root.val);
    list.add(listTemp);
    <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;
        listTemp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">while</span>(now != <span class="hljs-number">0</span>)&#123;
            TreeNode node = queue.poll();
            now--;
            <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;
                queue.add(node.left);
                listTemp.add(node.left.val);
                next++;
            &#125;
            <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;
                queue.add(node.right);
                listTemp.add(node.right.val);
                next++;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(next != <span class="hljs-number">0</span>)&#123;
            list.add(listTemp);
            now = next;
            next = <span class="hljs-number">0</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> list;
&#125;</code></pre></div><h3 id="323-之字形打印二叉树"><a class="markdownIt-Anchor" href="#323-之字形打印二叉树"></a> 32.3 之字形打印二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p><a class="btn" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>这里每一行都得从尾部开始寻找它的字节点，因此可用栈结构。</li><li>参考题解，代码更简洁。用 res 中的元素个数能够判断处在奇数行还是偶数行；用双端链表加上反转方法，能够大大化简操作。在 for 循环中，初始化 i 的值为 size，这样虽然在循环中 size 不断在变化，但是这个循环次数还是恒定的。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList();
    &#125;
    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;
    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    list.add(root.val);
    res.add(list);
    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    stack.push(root);
    Stack&lt;TreeNode&gt; stackNext = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">int</span> now = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> next = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(stack.size() != <span class="hljs-number">0</span>)&#123;
        list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        stackNext = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
        <span class="hljs-keyword">while</span>(now != <span class="hljs-number">0</span>)&#123;
            TreeNode node = stack.pop();
            now--;
            <span class="hljs-keyword">if</span>(flag)&#123;
                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;
                    stackNext.push(node.right);
                    list.add(node.right.val);
                    next++;
                &#125;
                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;
                    stackNext.push(node.left);
                    list.add(node.left.val);
                    next++;
                &#125;
            &#125;<span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;
                    stackNext.push(node.left);
                    list.add(node.left.val);
                    next++;
                &#125;
                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;
                    stackNext.push(node.right);
                    list.add(node.right.val);
                    next++;
                &#125;
            &#125;
        &#125;
        flag = !flag;
        <span class="hljs-keyword">if</span>(next != <span class="hljs-number">0</span>)&#123;
            now = next;
            next = <span class="hljs-number">0</span>;
            res.add(list);
            stack = stackNext;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#33-二叉搜索树的后序遍历序列"></a> 33、二叉搜索树的后序遍历序列</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>二叉搜索树的后序遍历序列，最后一个元素是根节点，最左边开始，遍历，比根节点小的元素是根节点的左子树，直至遇到一个比根节点大的元素，该元素包括该元素后面的元素应该都比根节点大且是根节点的右子树。这样递归查找是否满足该要求。</p><p>More：<br></p><p>处理一个二叉树的遍历序列，可以找到二叉树的根节点，再基于根节点将序列拆分为左子树和右子树。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(postorder == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    <span class="hljs-keyword">if</span>(postorder.length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">return</span> verifyPostorderRecu(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorderRecu</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;
    <span class="hljs-keyword">if</span>(begin &gt;= end)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;
    <span class="hljs-keyword">int</span> temp = begin;
    <span class="hljs-keyword">if</span>(postorder[temp] &lt; postorder[end])&#123;
        <span class="hljs-keyword">while</span>(postorder[temp] &lt; postorder[end])&#123;
            temp++;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = temp; i &lt; end; i++)&#123;
            <span class="hljs-keyword">if</span>(postorder[i] &lt; postorder[end])&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> verifyPostorderRecu(postorder, begin, temp - <span class="hljs-number">1</span>) &amp;&amp; verifyPostorderRecu(postorder, temp, end - <span class="hljs-number">1</span>);
    &#125;<span class="hljs-keyword">else</span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = temp; i &lt; end; i++)&#123;
            <span class="hljs-keyword">if</span>(postorder[i] &lt; postorder[end])&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> verifyPostorderRecu(postorder, temp, end - <span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre></div><h3 id="34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#34-二叉树中和为某一值的路径"></a> 34、二叉树中和为某一值的路径</h3><div class="note note-danger"><p>题目：<br></p><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>采用递归法。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

<span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> res;
    &#125;
    pathSumRecu(root, sum, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pathSumRecu</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> sum, List&lt;Integer&gt; temp)</span></span>&#123;
    sum = sum - node.val;
    temp.add(node.val);
    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span> &amp;&amp; sum == <span class="hljs-number">0</span>)&#123;
        res.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(temp));
    &#125;
    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;
        pathSumRecu(node.left, sum, temp);
    &#125;
    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;
        pathSumRecu(node.right, sum, temp);
    &#125;
    temp.remove(temp.size() - <span class="hljs-number">1</span>);
&#125;</code></pre></div><h3 id="35-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#35-二叉搜索树与双向链表"></a> 35、二叉搜索树与双向链表</h3><div class="note note-danger"><p>题目：<br></p><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p><a class="btn" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>可用空间换时间，利用一个 HashMap，key 为原节点，value 为复制节点，通过<code>get(node).next = get(node.next)</code>以及<code>get(node).random = get(node.random)</code>，可实现复制。</li><li>不牺牲空间，分三步。1. 将原链表 A-B-C-D 变为 A-A‘-B-B’-C-C’-D-D’，即将复制节点插入在原节点后面。2. 那么复制节点的 random 即为原节点的 random 的 next。3. 拆分出原始链表和复制链表。</li></ol></div><div class="hljs"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;
      <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
      &#125;
      
      <span class="hljs-comment">// 第一步 合并</span>
      Node temp =head;
      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>)&#123;
          Node tempNext = temp.next;
          temp.next = <span class="hljs-keyword">new</span> Node(temp.val);
          temp.next.next = tempNext;
          temp = tempNext;
      &#125;

      <span class="hljs-comment">// 第二步 复制random</span>
      temp = head;
      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>)&#123;
          <span class="hljs-keyword">if</span>(temp.random != <span class="hljs-keyword">null</span>)&#123;
              temp.next.random = temp.random.next;
          &#125;<span class="hljs-keyword">else</span>&#123;
              temp.next.random = <span class="hljs-keyword">null</span>;
          &#125;
          temp = temp.next.next;
      &#125;

<span class="hljs-comment">// 第三步 分离出原始链表和复制链表</span>
      temp = head;
      Node tempNew = head.next;
      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> &amp;&amp; temp.next != <span class="hljs-keyword">null</span>)&#123;
          Node tempTemp = temp.next;
          temp.next = temp.next.next;
          temp = tempTemp;
      &#125;
      <span class="hljs-keyword">return</span> tempNew;
  &#125;</code></pre></div><h3 id="36-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#36-二叉搜索树与双向链表"></a> 36、二叉搜索树与双向链表</h3><div class="note note-danger"><p>题目：<br></p><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>二叉搜索树的中序遍历为从小到大排序，按照中序遍历，将前一个节点的 right 指向当前节点，将当前节点的 left 指向前一个节点；若无前一个节点，说明当前节点是头节点。最后遍历的那个节点就是最后一个节点，由于要求是循环双向链表，因此将这两个节点也连接起来。</p></div><div class="hljs"><pre><code class="hljs java">Node head;
Node pre;
<span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> root;
    &#125;
    dfs(root);
    head.left = pre;
    pre.right = head;
    <span class="hljs-keyword">return</span> head;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;
    <span class="hljs-keyword">if</span>(cur == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;
    dfs(cur.left);
    <span class="hljs-keyword">if</span>(pre == <span class="hljs-keyword">null</span>)&#123;
        head = cur;
    &#125;<span class="hljs-keyword">else</span>&#123;
        pre.right = cur;
        cur.left = pre;
    &#125;
    pre = cur;
    dfs(cur.right);
&#125;</code></pre></div><h3 id="37-序列化二叉树"><a class="markdownIt-Anchor" href="#37-序列化二叉树"></a> 37、序列化二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><a class="btn" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>树的前序遍历，从根节点开始。</p><ol><li>序列化：递归实现。</li><li>反序列化：也可以递归实现。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// Encodes a tree to a single string.</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
    &#125;
    <span class="hljs-keyword">return</span> serializeRecu(root, <span class="hljs-string">""</span>);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">serializeRecu</span><span class="hljs-params">(TreeNode node, String s)</span></span>&#123;
    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> s + <span class="hljs-string">"None,"</span>;
    &#125;<span class="hljs-keyword">else</span>&#123;
        s = s + node.val + <span class="hljs-string">","</span>;
        s = serializeRecu(node.left, s);
        s = serializeRecu(node.right, s);
    &#125;
    <span class="hljs-keyword">return</span> s;
&#125;

<span class="hljs-comment">// Decodes your encoded data to tree.</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-string">""</span>.equals(data))&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    String[] dataArray = data.split(<span class="hljs-string">","</span>);
    List&lt;String&gt; data_list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(dataArray));
    <span class="hljs-keyword">return</span> deserializeRecu(data_list);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">deserializeRecu</span><span class="hljs-params">(List&lt;String&gt; list)</span></span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-string">"None"</span>.equals(list.get(<span class="hljs-number">0</span>)))&#123;
        list.remove(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    TreeNode temp = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(list.get(<span class="hljs-number">0</span>)));
    list.remove(<span class="hljs-number">0</span>);
    temp.left = deserializeRecu(list);
    temp.right = deserializeRecu(list);
    <span class="hljs-keyword">return</span> temp;
&#125;</code></pre></div><h3 id="38-字符串的排列"><a class="markdownIt-Anchor" href="#38-字符串的排列"></a> 38、字符串的排列</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>考虑 dfs，固定第一位（n 种）、再固定第二位(n-1 种)…。其中，有重复字符需要剪枝。<br></p><p>相关题目：<br></p><ol><li>如果不是字符串的排列，而是字符串的组合，如 “abc&quot; 的组合有 ”a“ “b” “c” “ab” “ac” “bc”。这里方法和该题可以一样，不需要交换顺序，以组合的长度进行循环，第一位从起点到 length - 组合长度 + 0，第 n 位从起点到 length - 组合长度 + n - 1。也需要剪枝。</li><li>输入一个含有 8 个数字的数字，将它们放在正方体的 8 个顶点上，判断能否使得正方体上三组相对面上的 4 个顶点和相等。这题就是得到这 8 个数字的排列情况，判断有没有一个排列满足 a1 + a2 + a3 + a4 = a5 + a6 + a7 + a8 且 a1 + a3 + a5 + a7 = a2 + a4 + a6 + a8 且 a1 + a2 + a5 + a6 = a3 + a4 + a7 + a8。</li><li>八皇后问题。</li><li>如果题目是按照一定要求摆放若干数字，则可以先求出这些数字的所有排列，然后再进一步看是否满足要求。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">char</span>[] c;
List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
<span class="hljs-keyword">public</span> String[] permutation(String s) &#123;
    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    c = s.toCharArray();
    dfs(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> String[list.size()]);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;
    <span class="hljs-keyword">if</span>(index == c.length - <span class="hljs-number">1</span>)&#123;
        list.add(String.valueOf(c));
    &#125;
    Set&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index; i &lt; c.length; i++)&#123;
        <span class="hljs-keyword">if</span>(set.contains(c[i]))&#123;
            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 剪枝</span>
        &#125;
        set.add(c[i]);
        swap(index, i);
        dfs(index + <span class="hljs-number">1</span>);
        swap(index, i);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;
    <span class="hljs-keyword">char</span> temp = c[a];
    c[a] = c[b];
    c[b] = temp;
&#125;</code></pre></div><h2 id="第五章-优化时间和空间效率"><a class="markdownIt-Anchor" href="#第五章-优化时间和空间效率"></a> 第五章 优化时间和空间效率</h2><h3 id="39-数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#39-数组中出现次数超过一半的数字"></a> 39、数组中出现次数超过一半的数字</h3><div class="note note-danger"><p>题目：<br></p><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>注意，这里假设了数组一定存在一个数字出现次数超过数组长度的一半。</p><ol><li><p>摩尔投票法。众数票加一，非众数票减一。时间复杂度O(N)，空间复杂度O(1)；遍历数组，若当前数字与记录的数字相同，则加一；若不同，则减一。次数到零后，记录数字更换为当前数字。</p></li><li><p>HashMap法。用HashMap统计各数字数量。时间复杂度O(N)，空间复杂度O(N)；</p></li><li><p>数组排序法。排序后，众数一定在数组中间。采用特殊排序算法，时间复杂度O(N)，空间复杂度O(1)。借用快排的思想，选取一个数字，调整数组使得该数字左边的数字都比该数字小，该数字右边的数字都比该数字大。若该数字刚好在 n/2 的位置上，则该数字即为要找到数字。若它的下标小于 n/2，那么递归进入该数字右边进行寻找；若它的下标大于 n/2，那么递归进入该数字左边进行寻找。</p></li></ol><p>给出的示例为摩尔投票法。注意，书上没说数字一定是正常的且一定有这样的数字，因此，对于树上的题目，需要判断异常情况。1. 数组为空。2. 数组中出现最多次数的数字出现的次数不到数组长度的一半，也就是用上面的方法找到数字后，再遍历数字计算这个数字出现的次数，判断是否满足要求。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">int</span> target = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;
        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)  target = num;
        count += target == num ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> target;
&#125;</code></pre></div><h3 id="40-最小的-k-个数"><a class="markdownIt-Anchor" href="#40-最小的-k-个数"></a> 40、最小的 k 个数</h3><div class="note note-danger"><p>题目：<br></p><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>直接排序。时间复杂度O(NlogN)</p></li><li><p>利用最大堆。遍历数组，若最大堆中元素个数不足 k 个，则将该数组数字加入最大堆中；若元素个数已达 k 个，判断最大堆中最大的数字是否小于该数字，若小于，则不处理；若大于，则删除最大堆的这个数字，将数组中的数字插入进去。这个时间复杂度为O(Nlogk)。这个优点是不会改变数组结构。</p></li><li><p>数组排序法。排序后，众数一定在数组中间。采用特殊排序算法，时间复杂度O(N)，空间复杂度O(1)。借用快排的思想，选取一个数字，调整数组使得该数字左边的数字都比该数字小，该数字右边的数字都比该数字大。若该数字刚好在 k - 1 的位置上，则该数字即为要找到数字。若它的下标小于k - 1，那么递归进入该数字右边进行寻找；若它的下标大于 k - 1，那么递归进入该数字左边进行寻找。这个的缺点是会改变数组的结构。</p></li></ol><p>给出的示例为第三种思路。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;
    <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || k &gt;= arr.length)&#123;
        <span class="hljs-keyword">return</span> arr;
    &#125;
    <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
    &#125;
    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> end = arr.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> index;
    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;
        index = quickSortDemo(arr, begin, end);
        <span class="hljs-keyword">if</span>(index == k - <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> Arrays.copyOf(arr, k);
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index &gt; k - <span class="hljs-number">1</span>)&#123;
            end = index - <span class="hljs-number">1</span>;
        &#125;<span class="hljs-keyword">else</span>&#123;
            begin = index + <span class="hljs-number">1</span>;
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSortDemo</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;
    <span class="hljs-keyword">int</span> beginSave = begin;
    <span class="hljs-keyword">int</span> temp = arr[begin];
    <span class="hljs-keyword">while</span>(end &gt; begin)&#123;
        <span class="hljs-keyword">while</span>(end &gt; begin &amp;&amp; arr[end] &gt; temp)   end--;
        <span class="hljs-keyword">while</span>(end &gt; begin &amp;&amp; arr[begin] &lt;= temp)   begin++;
        <span class="hljs-keyword">if</span>(end != begin)&#123;
            <span class="hljs-keyword">int</span> temp2 = arr[begin];
            arr[begin] = arr[end];
            arr[end] = temp2;
        &#125;
    &#125;
    arr[beginSave] = arr[begin];
    arr[begin] = temp;
    <span class="hljs-keyword">return</span> begin;
&#125;</code></pre></div><h3 id="41-数据流的中位数"><a class="markdownIt-Anchor" href="#41-数据流的中位数"></a> 41、数据流的中位数</h3><div class="note note-danger"><p>题目：<br></p><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ol><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ol><p><a class="btn" href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>排好序的数据有这样一个特征，中位数左边的数字都比中位数右边的数字小。因此，建立两个堆。左边为最大堆，右边为最小堆。</p><ol><li>add 数据时，若两个堆中数字个数相同，则最大堆中数据个数应该增加一个。步骤为，先将该数据加入最小堆中，再将最小堆中的根节点（最小元素）弹出并加入到最大堆中；若两个堆中数字个数不相同，这时最大堆中数据个数比最小堆中数据个数多一个，则最小堆中数据个数应该增加一个。步骤为，先将该数据加入最大堆中，再将最大堆中的根节点（最大元素）弹出并加入到最小堆中。</li><li>find 数据时，若两个堆中数据个数不相同，则中位数为最大堆的根节点；若两个堆中数据个数相同，则中位数为两个堆中根节点的平均数。</li></ol></div><div class="hljs"><pre><code class="hljs java">Queue&lt;Integer&gt; large,small;
<span class="hljs-comment">/** initialize your data structure here. */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;
    large = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;( (x, y) -&gt; (y - x) );
    small = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(large.size() != small.size())&#123;
        large.offer(num);
        small.offer(large.poll());
    &#125;<span class="hljs-keyword">else</span>&#123;
        small.offer(num);
        large.offer(small.poll());
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">return</span> large.size() == small.size() ? (<span class="hljs-keyword">double</span>)(large.peek() + small.peek()) / (<span class="hljs-keyword">double</span>)<span class="hljs-number">2.0</span> 
                                        : large.peek();
&#125;</code></pre></div><h3 id="42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#42-连续子数组的最大和"></a> 42、连续子数组的最大和</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p><p><a class="btn" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>采用动态规划法。设以索引为 i 的元素结尾的子数组的最大和为 dp[i]，那么当 dp[i - 1] &lt;= 0 时，dp[i] = data[i]；当 dp[i - 1] &gt; 0 时，dp[i] = dp[i - 1] + data[i]。最后所需结果就是 dp 中的最大值，而这里由于动态规划时，只需要上一轮的 dp 来得到这一轮的 dp，因此 dp 不需要数组来存放，空间复杂度为O(1)。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);
    &#125;
    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">int</span> dp = res;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;
        dp = dp &lt;= <span class="hljs-number">0</span> ? nums[i] : dp + nums[i];
        res = dp &lt;= res ? res : dp;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="43-1~n-整数中-1-出现的次数"><a class="markdownIt-Anchor" href="#43-1~n-整数中-1-出现的次数"></a> 43、1~n 整数中 1 出现的次数</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p><p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p><a class="btn" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>将 1~n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</li><li>设数字是 x 位数，记第 i 位为 n(i)，那么输入的数字为 n(x) n(x-1) n(x-2) … n1。</li><li>称 n(i) 为当前位，记为 cur；</li><li>称 n(i-1) n(i-2) … n(1) 为低位，记为 low；</li><li>称 n(x) n(x-1) … n(i+1) 为高位，记为 high；</li><li>称 10^(i-1) 为位因子，记为 digit；</li><li>当 cur = 0 时，当前位为 1 的次数为 high * digit；当 cur = 1时，当前位为 1 的次数为 high * digit + low + 1；其他情况时，当前位为 1 的次数为 (high + 1) * digit。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">int</span> cur = n % <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> high = n / <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur !=<span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)        res += (high * digit);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)   res +=  (high * digit + low + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">else</span>                res += ((high + <span class="hljs-number">1</span>) * digit);
        low += (cur * digit);
        cur = high % <span class="hljs-number">10</span>;
        high /= <span class="hljs-number">10</span>;
        digit *= <span class="hljs-number">10</span>;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="44-数字序列中某一位的数字"><a class="markdownIt-Anchor" href="#44-数字序列中某一位的数字"></a> 44、数字序列中某一位的数字</h3><div class="note note-danger"><p>题目：<br></p><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>数字为 1 位数，1 位数的数字共有 9 个，这些数字所占位数有 9 位；</li><li>数字为 2 位数，2 位数的数字共有 90 个，这些数字所占位数有 180 位；</li><li>数字为 3 位数，3 位数的数字共有 900 个，这些数字所占位数有 2700 位；</li><li>得出结论，n 位数的数字共有 9 * 10^(n - 1)，这些数字所占位数有 9 * 10^(n - 1) * n。</li><li>第一步，确定该数位所属的数字为几位数；第二步，确定出该数字；第三步，确定出该数位。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常！"</span>);
    &#125;
    <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">long</span> count = <span class="hljs-number">9</span>;
    <span class="hljs-keyword">while</span>(n &gt; count)&#123;
        n -= count;
        start *= <span class="hljs-number">10</span>;
        digit++;
        count = start * digit * <span class="hljs-number">9</span>;
    &#125;
    <span class="hljs-keyword">long</span> num = start + (n - <span class="hljs-number">1</span>) / digit;
    <span class="hljs-keyword">return</span> Integer.valueOf(String.valueOf(num).charAt((n - <span class="hljs-number">1</span>) % digit) - <span class="hljs-string">'0'</span>);  <span class="hljs-comment">//注意，字符这里会转换为ASCII码，因此要 减'0'</span>
&#125;</code></pre></div><h3 id="45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#45-把数组排成最小的数"></a> 45、把数组排成最小的数</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>该题需要一些证明为算法提供支撑。</p><ol><li>定义一个排序规则：设两个以字符串形式表示的数字分别为 x 和 y，这里的加号表示字符串拼接，将两个数字拼接在一起。若 x + y &gt; y + x，那么 x &gt; y；若 x + y &lt; y + x，那么 x &lt; y。这样的排序规则需要满足三个条件：自反性、对称性和传递性。这三个证明略。</li><li>将数字数组转为对应的字符串数组，然后对字符串数组按照上述的排序规则从小到大进行排序（这里演示的是快排）。将排序好的数组中的字符串从左到右拼接起来即可得到答案。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);
    &#125;
    String[] strs = <span class="hljs-keyword">new</span> String[nums.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;
        strs[i] = String.valueOf(nums[i]);
    &#125;
    quickSort(strs, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);
    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-keyword">for</span>(String s : strs)&#123;
        res.append(s);
    &#125;
    <span class="hljs-keyword">return</span> res.toString();
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(String[] strs, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;
    <span class="hljs-keyword">if</span>(begin &gt;= end)&#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">int</span> i = begin;
    <span class="hljs-keyword">int</span> j = end;
    String tempVal = strs[begin];
    <span class="hljs-keyword">while</span>(i &lt; j)&#123;
        <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; (strs[j] + tempVal).compareTo(tempVal + strs[j]) &gt; <span class="hljs-number">0</span>)&#123;
            j--;
        &#125;
        <span class="hljs-keyword">while</span>(j &gt; i &amp;&amp; (strs[i] + tempVal).compareTo(tempVal + strs[i]) &lt;=<span class="hljs-number">0</span>)&#123;
            i++;
        &#125;
        <span class="hljs-keyword">if</span>(j != i)&#123;
            String temp = strs[i];
            strs[i] = strs[j];
            strs[j] = temp;
        &#125;
    &#125;
    strs[begin] = strs[i];
    strs[i] = tempVal;
    quickSort(strs, begin, i - <span class="hljs-number">1</span>);
    quickSort(strs, i + <span class="hljs-number">1</span>, end);
&#125;</code></pre></div><h3 id="46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#46-把数字翻译成字符串"></a> 46、把数字翻译成字符串</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>动态规划法。dp[i] 表示以第 i 个数字结尾的字符串的翻译方法种数。这里第一个数字不是 i = 0 而是 i = 1。从左往右和从右往左是一样的。这里用从左往右进行讲解，但代码采用从右往左的方式，以实现低空间复杂度的方法。</p><ol><li>当前数字和前一位数字组成的数，若在 10~25 之间，那么以当前数字结尾的数字，有 dp[i-1] + dp[i-2] 种翻译方式；若不在那个区间内，则有 dp[i-1] 种翻译方式。</li><li>注意到 dp 只用存两位的数据，因此 dp 只用两个整数变量存放即可，降低空间复杂度。初始化 dp[0] = dp[1] = 1。</li><li>接下来就是如何遍历数字，第一种方式是，转为字符串，顺序遍历，这样需要O(n)的空间复杂度以存放字符串。第二种方式是利用数字的求余求模运算，从右往左遍历数字。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;
    <span class="hljs-keyword">int</span> dpNew = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> dpOld = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> tempA = num % <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> tempB = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;
        num /= <span class="hljs-number">10</span>;
        tempB = num % <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> temp = tempB * <span class="hljs-number">10</span> + tempA;
        <span class="hljs-keyword">int</span> c = (temp &gt;= <span class="hljs-number">10</span> &amp;&amp; temp &lt;= <span class="hljs-number">25</span>) ? dpNew + dpOld : dpNew;
        dpOld = dpNew;
        dpNew = c;
        tempA = tempB;
    &#125;
    <span class="hljs-keyword">return</span> dpNew;
&#125;</code></pre></div><h3 id="47-礼物的最大价值"><a class="markdownIt-Anchor" href="#47-礼物的最大价值"></a> 47、礼物的最大价值</h3><div class="note note-danger"><p>题目：<br></p><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><a class="btn" href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>动态规划法。dp[i] [j] 表示到达行索引为 i、列索引为 j的格子能拿到礼物的最大价值。显然，一般情况下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + grid[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.03588em">g</span><span class="mord mathdefault" style="margin-right:.02778em">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.05724em">j</span><span class="mclose">]</span></span></span></span></span></p><p>为降低空间复杂度，可将 dp 直接建立在输入数组中。第 0 行和第 0 列为特殊情况，需要判断，为了不在循环中进行大量的判断，可在初始化时先对第 0 行和第 0 列进行处理。<br></p><p>若不想改变原数组，也不必建立 M x N 的 dp 矩阵。注意到我们不需要当前行的前两行及之前的数据，因此只需要建立一个一维数组，长度为 N 。不断更新该数组即可。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(grid == <span class="hljs-keyword">null</span> || grid.length &lt;= <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>].length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常！"</span>);
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;
        grid[i][<span class="hljs-number">0</span>] += grid[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;
        grid[<span class="hljs-number">0</span>][j] += grid[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;grid.length; i++)&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;
            grid[i][j] += Math.max(grid[i-<span class="hljs-number">1</span>][j], grid[i][j-<span class="hljs-number">1</span>]);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> grid[grid.length - <span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>];
&#125;</code></pre></div><h3 id="48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#48-最长不含重复字符的子字符串"></a> 48、最长不含重复字符的子字符串</h3><div class="note note-danger"><p>题目：<br></p><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>动态规划法。dp[i] 表示以索引为 i 的元素为子字符串的结尾的最大长度</p><ol><li>初始化 dp[0] = 1；</li><li>若索引为 i 的元素与之前的元素没有重复，则 dp[i] = dp[i-1] + 1;若有重复，则进一步判断；</li><li>重复后，判断上一次重复的元素是否在当前得到的最大子字符串之前，也就是当前元素与它的最近重复的那个元素的距离 d 是否大于 dp[i-1]，若大于，则该重复元素不对本次规划造成影响，它在该子字符串的前面，则 dp[i] = dp[i-1] + 1；若不大于，则该重复元素就在该子字符串之中，dp[i] = d。</li><li>采用一个HashMap记录每个元素最新的索引，由于是字符，HashMap键值对数量有上限，因此空间复杂度为O(1)，时间复杂度为O(1)。因此可以用长度固定的数组带替，数组操作比hashmap快。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    HashMap&lt;Character,Integer&gt; hashmap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    <span class="hljs-keyword">int</span> dp = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> res = dp;
    hashmap.put(s.charAt(<span class="hljs-number">0</span>), <span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;
        <span class="hljs-keyword">char</span> temp = s.charAt(i);
        <span class="hljs-keyword">if</span>(hashmap.get(temp) == <span class="hljs-keyword">null</span>)&#123;
            dp++;
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">if</span>(i - hashmap.get(temp) &gt; dp)&#123;
                dp++;
            &#125;<span class="hljs-keyword">else</span>&#123;
                dp = i - hashmap.get(temp);
            &#125;
        &#125;
        res = dp &gt; res? dp : res;
        hashmap.put(temp, i);
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="49-丑数"><a class="markdownIt-Anchor" href="#49-丑数"></a> 49、丑数</h3><div class="note note-danger"><p>题目：<br></p><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p><a class="btn" href="https://leetcode-cn.com/problems/chou-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>动态规划。</p><ol><li>我们将前面求得的丑数记录下来，后面的丑数就是前面的丑数 2，3，5倍；</li><li>已知前面k-1个丑数，需要确定第k个丑数；</li><li>采取用三个指针的方法，p2,p3,p5</li><li>p2指向的数字下一次乘上2，p3指向的数字下一次乘上3，p5指向的数字乘上5</li><li>我们从 2p2 3p3 5p5 选取最小的一个数字，作为第k个丑数</li><li>如果 第K个丑数 == 2p2，也就是说前面0-p2个丑数*2不可能产生比第K个丑数更大的丑数了，所以p2++</li><li>p3,p5同理</li><li>返回第n个丑数</li><li>第一个丑数是 1，以 1 初始化丑数表。注意第6、7步需要用 if 而不能是 if else，因为某些丑数能有多种情况被得到，</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常！"</span>);
    &#125;
    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> p2 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> p3 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> p5 = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;
        dp[i] = Math.min(dp[p2] * <span class="hljs-number">2</span>, Math.min(dp[p3] * <span class="hljs-number">3</span>, dp[p5] * <span class="hljs-number">5</span>));
        <span class="hljs-keyword">if</span>(dp[p2] * <span class="hljs-number">2</span> == dp[i]) p2++;
        <span class="hljs-keyword">if</span>(dp[p3] * <span class="hljs-number">3</span> == dp[i]) p3++;
        <span class="hljs-keyword">if</span>(dp[p5] * <span class="hljs-number">5</span> == dp[i]) p5++;
    &#125;
    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];
&#125;</code></pre></div><h3 id="501-第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#501-第一个只出现一次的字符"></a> 50.1、第一个只出现一次的字符</h3><div class="note note-danger"><p>题目：<br></p><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><p><a class="btn" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>第一次遍历时存放字符出现的次数，第二次遍历寻找第一次出现次数为 1 的字符。由于 s 只包含小写字母，可以用长度固定的数组来存放信息，数组操作比HashMap快。<br></p><p>More：<br></p><p>若没附加 s 只包含小写字母，则可能有中文字符等。这是可以用HashMap来存放信息。进一步的，可以采用有序哈希表 LinkedHashMap，第二轮遍历时不需要遍历原字符串，这样会有大量重复字符的遍历，而只用遍历有序哈希表，因为有序哈希表是按插入顺序排序的。<br></p><ol><li><p>输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。用数组当作哈希表，将第二个字符串的字符出现信息存入数组中。再遍历第一个字符串，每次判断该字符是否出现再第二个字符串中，时间复杂度为O(1) * O(N)。</p></li><li><p>删除字符串中重复出现的字符。如 “google” 被删除为 “gole”。这也可以用一个数组存放字符是否出现过的信息。</p></li><li><p>判断两个单词是否互为变位词，即单词字母出现的一样，每个字母出现的次数也一样。用数组实现一个哈希表，存放第一个单词每个字母出现的次数；再遍历第二个单词，每遍历一个字母就将数组对应位置的元素减一，遍历完毕后，判断数组是否全为0。</p></li></ol><p>总的来说，在一些情况下，可以用数组代替哈希表，提高时间效率。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;
    <span class="hljs-keyword">int</span>[] num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;
        num[s.charAt(i)]++;
    &#125;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;
        <span class="hljs-keyword">char</span> temp = s.charAt(i);
        <span class="hljs-keyword">if</span>(num[temp] == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> temp;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;
&#125;</code></pre></div><h3 id="502-字符流中第一个只出现一次的字符"><a class="markdownIt-Anchor" href="#502-字符流中第一个只出现一次的字符"></a> 50.2 字符流中第一个只出现一次的字符</h3><div class="note note-danger"><p>题目：<br></p><p>请实现一个函数，用来找出字符流中第一个只出现一次的字符。</p></div><div class="note note-primary"><p>思路分析：<br></p><p>用一个数组，元素初始化为 -1，索引为字符的ASCII码，每当加入一个字符时，判断该字符位置对应的元素是否为 -1，若是，则将该字符出现的索引放入该数组对应位置中；若大于等于 0，则已出现过，将数组中该位置元素置为 -2，则不需要操作。</p></div><h3 id="51-数组中的逆序对"><a class="markdownIt-Anchor" href="#51-数组中的逆序对"></a> 51、数组中的逆序对</h3><div class="note note-danger"><p>题目：<br></p><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>采用分治的思想，结合归并排序，若右边的数字插入原数组中，则当时左边还剩余多少个数字，就是这时的逆序对个数。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">1</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">int</span> length = nums.length;
    <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length]; <span class="hljs-comment">//不修改原数组</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)&#123;
        copy[i] = nums[i];
    &#125;
    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];
    <span class="hljs-keyword">return</span> mergeSort(copy, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>, temp);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;
    <span class="hljs-keyword">if</span>(begin == end)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">int</span> mid = begin + (end - begin) / <span class="hljs-number">2</span>; <span class="hljs-comment">//避免出现二分法经典溢出bug</span>
    <span class="hljs-keyword">int</span> count1 = mergeSort(nums, begin, mid, temp);
    <span class="hljs-keyword">int</span> count2 = mergeSort(nums, mid + <span class="hljs-number">1</span>, end, temp);
    <span class="hljs-keyword">int</span> count3 = merge(nums, begin, mid, end, temp);
    <span class="hljs-keyword">return</span> count1 + count2 + count3;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)&#123;
        temp[i] = nums[i];
    &#125;
    <span class="hljs-keyword">int</span> i = begin;
    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = begin; k &lt;= end; k++)&#123;
        <span class="hljs-keyword">if</span>(i == mid + <span class="hljs-number">1</span>)    nums[k] = temp[j++];
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == end + <span class="hljs-number">1</span>)   nums[k] = temp[i++];
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(temp[i] &lt;= temp[j])   nums[k] = temp[i++];
        <span class="hljs-keyword">else</span>&#123;
            nums[k] = temp[j++];
            count += (mid - i + <span class="hljs-number">1</span>); 
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> count;
&#125;</code></pre></div><h3 id="52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#52-两个链表的第一个公共节点"></a> 52、两个链表的第一个公共节点</h3><div class="note note-danger"><p>题目：<br></p><p>输入两个链表，找出它们的第一个公共节点。</p><p><img src="https://i.loli.net/2020/07/27/rzNUm9Vw1x8McuT.png" srcset="/img/loading.gif" alt=""></p><p><a class="btn" href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>从第一个相同节点后，两个链表相同。</p><ol><li><p>将两个链表分别压入两个栈中。再从栈中同时弹出节点，直到找到最后一个相同的节点。</p></li><li><p>先分别遍历两个链表，求出两个链表长度。将较长的那个链表先往前走两个链表长度之差`的长度。之后，再同时让两个链表往前走，第一个相同节点即为要寻找的节点。</p></li><li><p>双指针法，浪漫相遇！使用两个指针，分别从两个链表头开始，向前遍历，若节点为null，则转到另一个链表头重新开始，直到两个链表节点相同。这个解法很秀。摘一些有趣的评论~</p></li></ol><div class="hljs"><pre><code class="hljs erlang">两个链表长度分别为L1+C、L2+C，C为公共部分的长度。第一个人走了L1+C步后，回到第二个人起点走L2步；
第二个人走了L2+C步后，回到第一个人起点走L1步。 当两个人走的步数都为L1+L2+C时就两个家伙就相爱了。

你变成我，走过我走过的路。
我变成你，走过你走过的路。
然后我们便相遇了...</code></pre></div></div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法2</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;
           <span class="hljs-keyword">int</span> countA = <span class="hljs-number">0</span>;
           <span class="hljs-keyword">int</span> countB = <span class="hljs-number">0</span>;
           ListNode tempA = headA;
           ListNode tempB = headB;
           <span class="hljs-keyword">while</span>(tempA != <span class="hljs-keyword">null</span>)&#123;
               tempA = tempA.next;
               countA++;
           &#125;
           <span class="hljs-keyword">while</span>(tempB != <span class="hljs-keyword">null</span>)&#123;
               tempB = tempB.next;
               countB++;
           &#125;
           <span class="hljs-keyword">while</span>(countA &gt; countB)&#123;
               headA = headA.next;
               countA--;
           &#125;
           <span class="hljs-keyword">while</span>(countA &lt; countB)&#123;
               headB = headB.next;
               countB--;
           &#125;
           <span class="hljs-keyword">while</span>(headA != headB)&#123;
               headA = headA.next;
               headB = headB.next;
           &#125;
           <span class="hljs-keyword">return</span> headA;
     &#125;

<span class="hljs-comment">// 方法3</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;
       ListNode tempA = headA;
       ListNode tempB = headB;
       <span class="hljs-keyword">while</span>(tempA != tempB)&#123;
           tempA = tempA == <span class="hljs-keyword">null</span> ? headB : tempA.next;
           tempB = tempB == <span class="hljs-keyword">null</span> ? headA : tempB.next;
       &#125;
       <span class="hljs-keyword">return</span> tempA;
   &#125;</code></pre></div><h2 id="第六章-面试中的各项能力"><a class="markdownIt-Anchor" href="#第六章-面试中的各项能力"></a> 第六章 面试中的各项能力</h2><h3 id="531-数字在排序数组中出现的次数"><a class="markdownIt-Anchor" href="#531-数字在排序数组中出现的次数"></a> 53.1、数字在排序数组中出现的次数</h3><div class="note note-danger"><p>题目：<br></p><p>统计一个数字在排序数组中出现的次数。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>利用二分法，寻找 target + 0.5 和 target - 0.5 的位置，也就是想找到 taget 的左右边界。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">int</span> i = find(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, target + <span class="hljs-number">0.5</span>);
    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] != target)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = find(nums, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>, target - <span class="hljs-number">0.5</span>);
    <span class="hljs-keyword">return</span> i - j;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">double</span> target)</span></span>&#123;
    <span class="hljs-keyword">int</span> i = begin;
    <span class="hljs-keyword">int</span> j = end;
    <span class="hljs-keyword">while</span>(i &lt;= j)&#123;
        <span class="hljs-keyword">int</span> mid = i + (j - i) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(nums[mid] &lt; target)  i = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; target)    j = mid - <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> i;
&#125;</code></pre></div><h3 id="532-0~n-1-中缺失的数字"><a class="markdownIt-Anchor" href="#532-0~n-1-中缺失的数字"></a> 53.2 0~n-1 中缺失的数字</h3><div class="note note-danger"><p>题目：<br></p><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>利用二分法。左子数组一定没有缺失，右子数组中包含缺失的数字。那么，我们需要找到右子数组的起点。若 nums[mid] != mid，则说明有缺失，则 j = mid - 1。反之，也可分析。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据异常"</span>);
    &#125;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = nums.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(i &lt;= j)&#123;
        <span class="hljs-keyword">int</span> mid = i + (j - i) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(nums[mid] != mid)    j = mid - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>    i = mid + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> i;
&#125;</code></pre></div><h3 id="533-数组中数值和下标相等的元素"><a class="markdownIt-Anchor" href="#533-数组中数值和下标相等的元素"></a> 53.3 数组中数值和下标相等的元素</h3><div class="note note-danger"><p>题目：<br></p><p>假设一个单调递增的数组里每个元素都是整数并且是唯一的，请编写程序实现一个函数，找出数组中任意一个数值等于其下标的元素。</p></div><div class="note note-primary"><p>思路分析：<br></p><p>典型二分法。</p></div><h3 id="54-二叉搜索树中的第-k-大节点"><a class="markdownIt-Anchor" href="#54-二叉搜索树中的第-k-大节点"></a> 54、二叉搜索树中的第 k 大节点</h3><div class="note note-danger"><p>题目：<br></p><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>二叉搜索树的中序遍历是升序，则其中序遍历的倒序为降序，遍历顺序为 右-根-左，遍历到第 k 个节点，停止遍历，保存其值，用成员变量来保存数据。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || k &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);
    &#125;
    num = k;
    midOrder(root);
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midOrder</span><span class="hljs-params">(TreeNode node)</span></span>&#123;
    <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;
        midOrder(node.right);
    &#125;
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    num--;
    <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;
        res = node.val;
    &#125;
    <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;
        midOrder(node.left);
    &#125;
&#125;</code></pre></div><h3 id="551-二叉树的深度"><a class="markdownIt-Anchor" href="#551-二叉树的深度"></a> 55.1、二叉树的深度</h3><div class="note note-danger"><p>题目：<br></p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>一个树的深度等于其左子树和右子树深度的更大值加一。因此用递归实现。</li><li>层序遍历。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 方法1</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
       <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;
   &#125;

<span class="hljs-comment">// 方法2</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
       Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
       queue.add(root);
       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span>)&#123;
           res++;
           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size(); i &gt; <span class="hljs-number">0</span>; i--)&#123;
               TreeNode temp = queue.poll();
               <span class="hljs-keyword">if</span>(temp.left != <span class="hljs-keyword">null</span>)   queue.add(temp.left);
               <span class="hljs-keyword">if</span>(temp.right != <span class="hljs-keyword">null</span>)  queue.add(temp.right);
           &#125;
       &#125;
       <span class="hljs-keyword">return</span> res;
   &#125;</code></pre></div><h3 id="552-平衡二叉树"><a class="markdownIt-Anchor" href="#552-平衡二叉树"></a> 55.2 平衡二叉树</h3><div class="note note-danger"><p>题目：<br></p><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>沿用上一题的思想，若一个节点的左子树右子树深度之差大于 1，则不是平衡树，这里用 -1 表示。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;
    <span class="hljs-keyword">return</span> recur(root) == -<span class="hljs-number">1</span> ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode node)</span></span>&#123;
    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> left = recur(node.left);
    <span class="hljs-keyword">if</span>(left == -<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> right = recur(node.right);
    <span class="hljs-keyword">if</span>(right == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> Math.abs(right - left) &gt; <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : Math.max(right,left) + <span class="hljs-number">1</span>;
&#125;</code></pre></div><h3 id="561-数组中只出现一次的两个数字"><a class="markdownIt-Anchor" href="#561-数组中只出现一次的两个数字"></a> 56.1 数组中只出现一次的两个数字</h3><div class="note note-danger"><p>题目：<br></p><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>相同的数字异或为 0，如果把数组中所有元素进行异或，那么就相当于只有那两个出现次数为 1 且不相同的数字进行了异或（其它成对数字异或为 0 ）。如果只有一个数字出现一次，则所有元素异或完毕，得到的结果就是那个只出现一次的数字。那么，可以想到，如果将这个数组分为两类，其中一类包含待寻找的一个数字，且包含的其它数字都成对；另一类包含待寻找的另一个数字，且包含的其它数字都成对。那么，分别对这两类数字进行异或，就能得到两个最终的数字，即为该题的解。接下来就是对该数组进行分类。</p><ol><li>对原数组进行异或，得到一个数字，这个数字是那两个目标数字进行异或得到的，这个数字中 位为 1，表示这两个数字该位不相同。那么，我们可以找到该数字中第一个位为 1 的位置。假如得到的数字为 01100100，第一个为 1 的位置为从右到左的第三个，那么建立一个数 00000100 ，原数组和该数相与结果不为 1为一类，结果为 1 为另一类。这样就能够得到目标分类。</li><li>分别对两类进行异或，则可以得到解。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;
    <span class="hljs-keyword">int</span> res = xor(nums);
    <span class="hljs-keyword">int</span> help = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>((res &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>)&#123;
        res = res &gt;&gt; <span class="hljs-number">1</span>;
        help = help &lt;&lt; <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;
        <span class="hljs-keyword">if</span>((num &amp; help) == <span class="hljs-number">0</span>)  a ^= num;
        <span class="hljs-keyword">else</span>    b ^= num;
    &#125;
    <span class="hljs-keyword">int</span>[] target = &#123;a,b&#125;;
    <span class="hljs-keyword">return</span> target;
&#125;

<span class="hljs-comment">// 对一个数组中所有元素进行异或</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">xor</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;
    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;
        res ^= nums[i];
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="562-数组中唯一出现一次的数字"><a class="markdownIt-Anchor" href="#562-数组中唯一出现一次的数字"></a> 56.2 数组中唯一出现一次的数字</h3><div class="note note-danger"><p>题目：<br></p><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><a class="btn" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>其它数字都出现了三次，那么，这些数字二进制每一位出现的 1 的次数相加，都能够被 3 整除。因此，将数组中所有元素的二进制位出现的 1 的次数相加，再对 3 求余，得到的结果就是那个只出现一次的数字在那一位上的值。</p><ol><li>利用一个长度为 32 的数组，存放每一位 1 出现的次数。具体操作为：每次取数组中的一个数字，进行 32 次循环，将这个数字最右边一位取出并与 1 相与，判断该位是否为 1，将信息存入新建数组中，再将数字右移一位，循环操作，将该数字的 32 位的情况都进行判断；然后再对下一个数字进行相同的操作。最后，将新建数组恢复成待寻找的数字。</li><li>有限状态机：因为要被 3 整除，那么 1 出现的次数为 0—&gt;1----&gt;2-----&gt;0…，状态有 3 个，因此得用两位的 0 和 1表示，ones 表示低位，twos 表示高位。列出状态转换表。可总结出规律。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">int</span> ones = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> twos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;
        ones = ones ^ num &amp; ~twos;
        twos = twos ^ num &amp; ~ones;
    &#125;
    <span class="hljs-keyword">return</span> ones;
&#125;</code></pre></div><h3 id="571-和为-s-的两个数字"><a class="markdownIt-Anchor" href="#571-和为-s-的两个数字"></a> 57.1 和为 s 的两个数字</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p><a class="btn" href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>对撞双指针。初始化 begin = 0 以及 end = length - 1，若这两个指针上对应元素相加小于目标元素，则 begin++；若大于，则 end–。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);
    &#125;
    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> end = nums.length - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(begin &lt; end &amp;&amp; (nums[begin] + nums[end] != target))&#123;
        <span class="hljs-keyword">while</span>(begin &lt; end &amp;&amp; (nums[begin] + nums[end] &lt; target))&#123;
            begin++;
        &#125;
        <span class="hljs-keyword">while</span>(begin &lt; end &amp;&amp; (nums[begin] + nums[end] &gt; target))&#123;
            end--;
        &#125;
    &#125;
    <span class="hljs-keyword">int</span>[] res = &#123;nums[begin], nums[end]&#125;;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="572-和为-s-的连续正数序列"><a class="markdownIt-Anchor" href="#572-和为-s-的连续正数序列"></a> 57.2 和为 s 的连续正数序列</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><p><a class="btn" href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>类似上题，双指针，滑动窗口。设定一个窗口，若窗口内数字和小于目标数字，则窗口右边界向右扩张；若窗口内数字和大于目标数字，则窗口左边界向右缩小；若等于，则保存结果，将窗口整体向右平移一格，进行下个解的寻找。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;
    <span class="hljs-keyword">if</span>(target &lt;= <span class="hljs-number">2</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入数据不合法！"</span>);
    &#125;
    <span class="hljs-keyword">int</span> begin = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> end = <span class="hljs-number">2</span>;
    List&lt;<span class="hljs-keyword">int</span>[]&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">while</span>(begin &lt;= target / <span class="hljs-number">2</span>)&#123;
        <span class="hljs-keyword">while</span>(((begin + end) * (end - begin + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> &lt; target)&#123;
            end++;
        &#125;
        <span class="hljs-keyword">while</span>(begin &lt;= target / <span class="hljs-number">2</span> &amp;&amp; ((begin + end) * (end - begin + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> &gt; target)&#123;
            begin++;
        &#125;
        <span class="hljs-keyword">if</span>(((begin + end) * (end - begin + <span class="hljs-number">1</span>)) / <span class="hljs-number">2</span> == target)&#123;
            <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end - begin + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = begin; i &lt;= end; i++)&#123;
                temp[j++] = i;
            &#125;
            list.add(temp);
            begin++;
            end++;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[list.size()][]);
&#125;</code></pre></div><h3 id="581-翻转单词顺序"><a class="markdownIt-Anchor" href="#581-翻转单词顺序"></a> 58.1 翻转单词顺序</h3><div class="note note-danger"><p>题目：<br></p><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。注意，输入的原单词中间可能有连续多个空格，输出时每个单词间隔只能是一个空格。</p><p><a class="btn" href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>书上给出的解法：定义一个函数，翻转输入的字符串。那么可以分为两步：1. 将原字符串翻转。2. 再将每个单词分别翻转回来。</li><li>直接调转单词的顺序，定义一个StringBuffer，定义两个指针，从原数组最后面开始往左检索，直到遇到空格或者到头，检索到一段单词，substring这一段，添加到StringBuffer中</li></ol></div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法1</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;
       s = s.trim();
       StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(s);
       sb = reverse(sb, <span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);
       <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">int</span> end = <span class="hljs-number">0</span>;
       <span class="hljs-keyword">while</span>(begin &lt; sb.length())&#123;
           <span class="hljs-keyword">while</span>(end &lt;= sb.length() -<span class="hljs-number">1</span> &amp;&amp; sb.charAt(end) != <span class="hljs-string">' '</span>)&#123;
               end++;
           &#125;
           sb = reverse(sb, begin, end - <span class="hljs-number">1</span>);
           begin = end;
           <span class="hljs-keyword">while</span>(end &lt;= sb.length() -<span class="hljs-number">1</span> &amp;&amp; sb.charAt(end) == <span class="hljs-string">' '</span>)&#123;
               end++;
           &#125;
           <span class="hljs-keyword">if</span>(begin &lt;= sb.length() -<span class="hljs-number">1</span>)&#123;
               sb.replace(begin, end, String.valueOf(<span class="hljs-string">' '</span>));
               begin = end - (end - begin - <span class="hljs-number">1</span>);
               end = begin;
           &#125;
       &#125;
       <span class="hljs-keyword">return</span> sb.toString();
   &#125;

   <span class="hljs-function"><span class="hljs-keyword">private</span> StringBuffer <span class="hljs-title">reverse</span><span class="hljs-params">(StringBuffer s, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;
       <span class="hljs-keyword">while</span>(begin &lt; end)&#123;
           <span class="hljs-keyword">char</span> temp = s.charAt(begin);
           s.replace(begin,begin + <span class="hljs-number">1</span>, String.valueOf(s.charAt(end)));
           s.replace(end,end + <span class="hljs-number">1</span>, String.valueOf(temp));
           begin++;
           end--;
       &#125;
       <span class="hljs-keyword">return</span> s;
   &#125;</code></pre></div><h3 id="582-左旋转字符串"><a class="markdownIt-Anchor" href="#582-左旋转字符串"></a> 58.2 左旋转字符串</h3><div class="note note-danger"><p>题目：<br></p><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p><p><a class="btn" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>书上给出的解法：类似上题，我们把前 n 个数字看做一组，后面的剩余数字看作一组。分别翻转这两组中的内容，再将翻转后的整体内容进行一次翻转。</li><li>利用substring切片函数，直接切片。</li><li>字符串拼接，StringBuffer减少内存消耗。还可利用求余运算简化操作。</li></ol></div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法2</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;
       <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt;= <span class="hljs-number">0</span>)&#123;
           <span class="hljs-keyword">return</span> s;
       &#125;
       <span class="hljs-keyword">if</span>(n &gt; s.length())&#123;
           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
       &#125;
       String res = <span class="hljs-string">""</span>;
       <span class="hljs-keyword">int</span> length = s.length();
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &lt; n + s.length(); i++)&#123;
           res += s.charAt(i % length);
       &#125;
       <span class="hljs-keyword">return</span> res;
   &#125;</code></pre></div><h3 id="591-滑动窗口的最大值"><a class="markdownIt-Anchor" href="#591-滑动窗口的最大值"></a> 59.1 滑动窗口的最大值</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p><a class="btn" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/submissions/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>暴力解法。</li><li>建立一个单调队列，存放窗口中可能存在的最大值，里面的元素顺序为非单调递减。向右滑动窗口，若当前新进入窗口的元素大于单调队列尾部元素，则需要删除队列尾部元素，这个过程需要循环，直至队列为空或者进入窗口的元素不大于单调队列尾部元素；将新加的元素存放在队列尾部。注意，还需要判断窗口滑动后，失去的那个元素是否是最大的元素，若是，则需要删除队列头部中的该元素。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;= <span class="hljs-number">0</span> || k &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">int</span>[] resExcep = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">return</span> resExcep;
    &#125;
    Deque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123; <span class="hljs-comment">//第一个窗口，不用考虑剔除窗口滑动失去的元素</span>
        <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span> &amp;&amp; queue.peekLast() &lt; nums[i])&#123;
            queue.removeLast();
        &#125;
        queue.addLast(nums[i]);
    &#125;
    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];
    res[<span class="hljs-number">0</span>] = queue.peekFirst();
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++)&#123;
        <span class="hljs-keyword">if</span>(queue.peekFirst() == nums[i - k])&#123;
            queue.removeFirst();
        &#125;
        <span class="hljs-keyword">while</span>(queue.size() != <span class="hljs-number">0</span> &amp;&amp; queue.peekLast() &lt; nums[i])&#123;
            queue.removeLast();
        &#125;
        queue.addLast(nums[i]);
        res[i -k + <span class="hljs-number">1</span>] = queue.peekFirst();
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="592-队列的最大值"><a class="markdownIt-Anchor" href="#592-队列的最大值"></a> 59.2 队列的最大值</h3><div class="note note-danger"><p>题目：<br></p><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1。</p><p><a class="btn" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>类似上题，建立一个单调队列，存放可能存在的最大值。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; max;
<span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt; list;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;
    max = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;   
    <span class="hljs-keyword">return</span> max.size() == <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : max.getFirst();
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;
    list.addLast(value);
    <span class="hljs-keyword">while</span>(max.size() != <span class="hljs-number">0</span> &amp;&amp; max.getLast() &lt; value)&#123;
        max.removeLast();
    &#125;
    max.addLast(value);
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span>(list.size() == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> res = list.getFirst();
    <span class="hljs-keyword">if</span>(max.getFirst() == res)&#123;
        max.removeFirst();
    &#125;
    list.removeFirst();
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="60-n-个骰子的点数"><a class="markdownIt-Anchor" href="#60-n-个骰子的点数"></a> 60、n 个骰子的点数</h3><div class="note note-danger"><p>题目：<br></p><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><a class="btn" href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>动态规划。 n 个骰子可以分为 n - 1 个骰子和 1 个骰子组合。首先，n 个骰子，可能的点数个数为 5 * n + 1。n - 1个骰子和 1 个骰子组合中的 1 个骰子，概率是固定的，6个元素概率均为 1 / 6；n - 1 个骰子和 1 个骰子组合，就是他们的元素两两相乘。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;
    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
    &#125;
    <span class="hljs-keyword">double</span>[] pre = &#123;<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d,<span class="hljs-number">1</span>/<span class="hljs-number">6</span>d&#125;; <span class="hljs-comment">// n - 1 个骰子</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;
        <span class="hljs-keyword">double</span>[] later = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">5</span> * i + <span class="hljs-number">1</span>];  <span class="hljs-comment">// n 个骰子</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; pre.length; j++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++)&#123;
                later[k + j] += pre[j] / <span class="hljs-number">6</span>d;  <span class="hljs-comment">// n - 1 个骰子和 1 个骰子组合得到 n 个骰子结果</span>
            &#125;
        &#125;
        pre = later;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;</code></pre></div><h3 id="61-扑克牌中的顺子"><a class="markdownIt-Anchor" href="#61-扑克牌中的顺子"></a> 61、扑克牌中的顺子</h3><div class="note note-danger"><p>题目：<br></p><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><p><a class="btn" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>大王小王为 0，其余牌为 1~13。同时满足以下两个条件，5张扑克牌构成顺子。</p><ol><li>除 0 外，无重复牌；</li><li>牌中最大的数字减去最小的数字 &lt; 5。</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;
    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> min = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;
        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">continue</span>;
        &#125;
        <span class="hljs-keyword">if</span>(set.contains(num))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;
        max = Math.max(max,num);
        min = Math.min(min,num);
        set.add(num);
    &#125;
    <span class="hljs-keyword">return</span> max - min &lt; <span class="hljs-number">5</span>;
&#125;</code></pre></div><h3 id="62-圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#62-圆圈中最后剩下的数字"></a> 62、圆圈中最后剩下的数字</h3><div class="note note-danger"><p>题目：<br></p><p>0,1,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。每次删除一个数字后，从该数字后面一个数字重新开始数数，求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p><a class="btn" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>Josephu问题。</p><ol><li><p>将数字构成一个环形链表，双指针法。初始时，helper 指针指向尾部，target指针指向头部，每次将两个指针往前移动 m-1 下，利用helper 指针删除target指针，循环 n - 1次，最后两个指针重合得到解。</p></li><li><p><a class="btn" href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/" target="_blank">数学分析</a></p></li></ol><p>首先，对于N=8，m=3的情况，我们知道最后删除的元素为G，观察每次G所在的索引，如下图。最后只有一个元素，G的索引肯定为0。</p><p><img src="https://i.loli.net/2020/08/03/1TK758tNCRIyOnG.png" srcset="/img/loading.gif" alt=""></p><p>接下来倒推一下，如果从N=7倒推N=8时G的索引，将N=8删除的C补进来，并且将整体向右移动 m 下，再把溢出的部分补到前端。我们可以得到N=8时，G的索引。因此，总结可得，由这一次G的索引可以得到上一次G的索引位置，则由 0 倒推至初始数组，得到最初的索引，得到被删除的元素。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo>+</mo><mi>m</mi><mo stretchy="false">]</mo><mi mathvariant="normal">%</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">f(n,m) = [f(n-1,m) + m] \% n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:.10764em">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mord">%</span><span class="mord mathdefault">n</span></span></span></span></span></p><p><img src="https://i.loli.net/2020/08/03/p9U2A7je1iCG36n.png" srcset="/img/loading.gif" alt=""></p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span> || m &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
    &#125;
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;
        res = (res + m) % i;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="63-股票的最大利润"><a class="markdownIt-Anchor" href="#63-股票的最大利润"></a> 63、股票的最大利润</h3><div class="note note-danger"><p>题目：<br></p><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><div class="hljs"><pre><code class="hljs angelscript">输入: [<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]
输出: <span class="hljs-number">5</span>
解释: 在第 <span class="hljs-number">2</span> 天（股票价格 = <span class="hljs-number">1</span>）的时候买入，在第 <span class="hljs-number">5</span> 天（股票价格 = <span class="hljs-number">6</span>）的时候卖出，最大利润 = <span class="hljs-number">6</span><span class="hljs-number">-1</span> = <span class="hljs-number">5</span> 。
     注意利润不能是 <span class="hljs-number">7</span><span class="hljs-number">-1</span> = <span class="hljs-number">6</span>, 因为卖出价格需要大于买入价格。</code></pre></div><p><a class="btn" href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>动态规划。dp[i] 为以索引 i 元素结尾的日子的最大利润。那么以今天结尾的利润：为以 昨天结尾的利润 和 今天的股票价格与今天之前的股票最低价之差 更大的那一个： dp[i] = dp[i-1] + prices[i] - min(prices[0:i])。初始为 0。由于每次只需要上次的信息，因此可以节省空间。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(prices == <span class="hljs-keyword">null</span> || prices.length &lt;= <span class="hljs-number">1</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> later = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> min = prices[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.length; i++)&#123;
        pre = later;
        min = Math.min(min, prices[i]);
        later = Math.max(pre, prices[i] - min);
    &#125;
    <span class="hljs-keyword">return</span> later;
&#125;</code></pre></div><h3 id="64-求-1-2-n"><a class="markdownIt-Anchor" href="#64-求-1-2-n"></a> 64、求 1 + 2 + … + n</h3><div class="note note-danger"><p>题目：<br></p><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><a class="btn" href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li>利用短路与，前一个不满足不执行后一个。</li><li>利用 try catch。消耗时间较长。</li></ol></div><div class="hljs"><pre><code class="hljs java">   <span class="hljs-comment">// 方法1</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
       <span class="hljs-keyword">boolean</span> b = n &gt; <span class="hljs-number">0</span> &amp;&amp; (n += sumNums(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>;
       <span class="hljs-keyword">return</span> n;
   &#125;

<span class="hljs-comment">// 方法2</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] temp = &#123;<span class="hljs-number">0</span>&#125;;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;
       <span class="hljs-keyword">try</span>&#123;
           <span class="hljs-keyword">return</span> temp[n];
       &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;
           <span class="hljs-keyword">return</span> n + sumNums(n - <span class="hljs-number">1</span>);
       &#125;
   &#125;</code></pre></div><h3 id="65-不用加减乘除做加法"><a class="markdownIt-Anchor" href="#65-不用加减乘除做加法"></a> 65、不用加减乘除做加法</h3><div class="note note-danger"><p>题目：<br></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p><a class="btn" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>两数相加，分别得到不做进位的结果 A（两数位异或，相同为0不同为1） 以及进位信息 C（两数位相与，只有全为 1 才进位）（即在哪一位相加发生了进位）。那么将 C 整体左移一位加上 A 就是结果。但是由于不能用加法，我们可以对 A C 再次进行上面的操作，那么我们需要不断循环以上操作直至 C为 0，也就是没有进位了。<br></p><p>More:<br></p><p>交换两个数字：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = a + b<span class="hljs-comment">;</span>
<span class="hljs-attr">b</span> = a - b<span class="hljs-comment">;</span>
<span class="hljs-attr">a</span> = a - b<span class="hljs-comment">;</span>

<span class="hljs-attr">a</span> = a ^ b<span class="hljs-comment">;</span>
<span class="hljs-attr">b</span> = a ^ b<span class="hljs-comment">;</span>
<span class="hljs-attr">a</span> = a ^ b<span class="hljs-comment">;</span></code></pre></div></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;
    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 进位信息</span>
    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;
        c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;
        a = a ^ b;  <span class="hljs-comment">// 不做进位的结果</span>
        b = c;
    &#125;
    <span class="hljs-keyword">return</span> a;
&#125;</code></pre></div><h3 id="66-构建乘积数组"><a class="markdownIt-Anchor" href="#66-构建乘积数组"></a> 66、构建乘积数组</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p><a class="btn" href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>暴力解法。</p></li><li><p>时间复杂度O(N)。将原数组构成一张表，对角线处改为 1。那么，第一个循环是将左下部分元素相乘，第二个循环是再乘上右上部分的值。</p></li></ol><p><img src="https://i.loli.net/2020/08/05/yfUVrzdXv7nqgFB.png" srcset="/img/loading.gif" alt=""></p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;
    <span class="hljs-keyword">if</span>(a == <span class="hljs-keyword">null</span> || a.length &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
    &#125;
    <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];
    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++)&#123;
        b[i] = b[i - <span class="hljs-number">1</span>] * a[i - <span class="hljs-number">1</span>];
    &#125;
    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;=<span class="hljs-number">0</span>; i--)&#123;
        temp *= a[i + <span class="hljs-number">1</span>];
        b[i] *= temp;
    &#125;
    <span class="hljs-keyword">return</span> b;
&#125;</code></pre></div><h2 id="第七章-两个面试案例"><a class="markdownIt-Anchor" href="#第七章-两个面试案例"></a> 第七章 两个面试案例</h2><h3 id="67-把字符串转换为整数"><a class="markdownIt-Anchor" href="#67-把字符串转换为整数"></a> 67、把字符串转换为整数</h3><div class="note note-danger"><p>题目：<br></p><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p><a class="btn" href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>按要求匹配即可，需要注意的有：</p><ol><li>去除字符串开头的空格；</li><li>检索正负号；</li><li>当遇到非数字时停止扫描；</li><li>注意字符串数字不能超过 int 类型的最大值。这里要当心的是，若简单的将数字与 int 类型范围进行比较来判断是否溢出，会出错，因为在计算时，res 为 int 类型，溢出时会自动转换，因此，我们需要在每次计算 res 之前，就提前判断这一次计算 res 后，它是否会溢出，具体方法为：将其与 max（<em>2147483647</em>） / 10比较，若大于，此次计算后必溢出，若等于，则判断此次字符是否大于 ‘7’，若大于，则溢出。（这里很巧妙，将负数时的 8 也能囊括进去。）</li></ol></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span> || str.length() &lt;= <span class="hljs-number">0</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正负号</span>
    <span class="hljs-keyword">int</span> max = Integer.MAX_VALUE;
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(str.charAt(index) == <span class="hljs-string">' '</span>)&#123;
        <span class="hljs-keyword">if</span>(++index == str.length())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
    &#125; <span class="hljs-comment">// 去除头部空格</span>
    <span class="hljs-keyword">if</span>(str.charAt(index) == <span class="hljs-string">'-'</span>)&#123;
        sign = -<span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">if</span>(str.charAt(index) == <span class="hljs-string">'+'</span> || str.charAt(index) == <span class="hljs-string">'-'</span>)&#123;
        index++;
    &#125; <span class="hljs-comment">// 检索正负号</span>
    <span class="hljs-keyword">for</span>(; index &lt; str.length(); index++)&#123;
        <span class="hljs-keyword">if</span>(str.charAt(index) &lt; <span class="hljs-string">'0'</span> || str.charAt(index) &gt; <span class="hljs-string">'9'</span>)&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-keyword">if</span>(res &gt; max / <span class="hljs-number">10</span> || (res == max / <span class="hljs-number">10</span> &amp;&amp; str.charAt(index) &gt; <span class="hljs-string">'7'</span>))&#123;
            <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? max : Integer.MIN_VALUE;
        &#125;
        res = res * <span class="hljs-number">10</span> + (str.charAt(index) - <span class="hljs-string">'0'</span>);
    &#125;
    <span class="hljs-keyword">return</span> sign * res;
&#125;</code></pre></div><h3 id="681-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#681-二叉搜索树的最近公共祖先"></a> 68.1 二叉搜索树的最近公共祖先</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><p>二叉搜索树，一个节点的左子树中所有节点的值它的值小，右子树中所有节点的值它的值大。对于输入的两个节点，若找到一个节点的值，介于这两个之间，则找到目标节点。若一个节点的值大于这两个节点的值，则需要在该节点的左子节点继续寻找；若一个节点的值小于这两个节点的值，则需要在该节点的右子节点继续寻找.</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;
    <span class="hljs-keyword">while</span>(root != <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;
            root = root.left;
        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;
            root = root.right;
        &#125;<span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;</code></pre></div><h3 id="682-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#682-二叉树的最近公共祖先"></a> 68.2 二叉树的最近公共祖先</h3><div class="note note-danger"><p>题目：<br></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a class="btn" href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank">力扣：用例测试</a></p></div><div class="note note-primary"><p>思路分析：<br></p><ol><li><p>p 和 q 在 root 的子树中，且分列 rootroot 的 异侧（即分别在左、右子树中）；</p></li><li><p>p = root ，且 q 在 root 的左或右子树中；</p></li><li><p>q = root ，且 p 在 root 的左或右子树中。</p></li></ol><p>不断递归。</p></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q)&#123;
        <span class="hljs-keyword">return</span> root;
    &#125;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> right;
    &#125;
    <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>)&#123;
        <span class="hljs-keyword">return</span> left;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;</code></pre></div></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">数据结构和算法</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/Java/">Java</a> <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener"><font color="#CAC4C4"><u>CC BY-SA 4.0 协议</u></font></a> ，转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/posts/blog-techniques-v1/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">博客瞎玩玩</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/posts/jvm-v1/"><span class="hidden-mobile">Java虚拟机(JVM)</span> <span class="visible-mobile">下一篇</span><i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"><div id="vcomments"></div><script>function loadValine(){addScript("https://cdn.staticfile.org/valine/1.4.14/Valine.min.js",function(){new Valine({el:"#vcomments",app_id:"WLIvPVVRoeWhnHGUavoLR0F0-9Nh9j0Va",app_key:"19OuG1Cn8ss6vpIXBxYjjff0",placeholder:"说点什么吧~",path:window.location.pathname,avatar:"retro",meta:["nick","mail","link"],pageSize:"10",lang:"zh-CN",highlight:!1,recordIP:!1,serverURLs:"https://wlivpvvr.lc-cn-e1-shared.com"})})}createObserver(loadValine,"vcomments")</script><noscript>Please enable JavaScript to view the <a href="https://valine.js.org" target="_blank" rel="nofollow noopener noopener">comments powered by Valine.</a></noscript></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><i class="iconfont icon-copyright"></i> <a href="javascript:void(0)" target="_self" rel="nofollow noopener"><span>2020</span> <a href="https://www.rooftopj.cn" target="_blank" rel="nofollow noopener"><span>rooftopj</span></a>&nbsp;<i class="iconfont icon-huo"></i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>&nbsp;<i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>&nbsp;<i class="iconfont icon-aliyun"></i> <a href="https://www.aliyun.com/" target="_blank" rel="nofollow noopener"><span>阿里云</span></a>&nbsp;<i class="iconfont icon-qianniu"></i> <a href="https://www.qiniu.com/" target="_blank" rel="nofollow noopener"><span>七牛云</span></a>&nbsp;<i class="iconfont icon-tupian"></i> <a href="https://sm.ms/" target="_blank" rel="nofollow noopener"><span>sm.ms</span></a><br><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("02/03/2020 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站安全运行&nbsp"+dnum+"&nbsp天",document.getElementById("times").innerHTML=hnum+"&nbsp小时&nbsp"+mnum+"&nbsp分&nbsp"+snum+"&nbsp秒"}setInterval("createtime()",250)</script></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量<span id="leancloud-site-pv"></span> 次</span> <span id="leancloud-site-uv-container" style="display:none">总访客数<span id="leancloud-site-uv"></span> 人</span></div><div class="beian"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">鄂ICP备20011952号-1</a> <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42018502004644" rel="nofollow noopener" class="beian-police" target="_blank"><span class="beian-police-sep">&nbsp;|&nbsp;</span> <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon"> <span>鄂公网安备 42018502004644号</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script defer>(function () {
    // 查询存储的记录
    function getRecord(Counter, target) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({target})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {target, time: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    }

    // 发起自增请求
    function increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    }

    // 构建自增请求体
    function buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "time": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    }

    // 校验是否为有效的 UV
    function validUV() {
      var key = 'LeanCloud_UV_Flag';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    }

    function addCount(Counter) {
      var enableIncr = 'true' === 'true' && window.location.hostname !== 'localhost';
      var getterArr = [];
      var incrArr = [];

      // 请求 PV 并自增
      var pvCtn = document.querySelector('#leancloud-site-pv-container');
      if (pvCtn || enableIncr) {
        var pvGetter = getRecord(Counter, 'site-pv').then((record) => {
          incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-pv');
          if (ele) {
            ele.innerText = record.time + 1;
            if (pvCtn) {
              pvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#leancloud-site-uv-container');
      if (uvCtn || enableIncr) {
        var uvGetter = getRecord(Counter, 'site-uv').then((record) => {
          var vuv = validUV();
          vuv && incrArr.push(buildIncrement(record.objectId))
          var ele = document.querySelector('#leancloud-site-uv');
          if (ele) {
            ele.innerText = record.time + (vuv ? 1 : 0);
            if (uvCtn) {
              uvCtn.style.display = 'inline';
            }
          }
        });
        getterArr.push(uvGetter);
      }

      // 如果是文章，请求文章的浏览数，并自增
      if ('true' === 'true') {
        var viewCtn = document.querySelector('#leancloud-post-views-container');
        if (viewCtn || enableIncr) {
          var target = decodeURI('/posts/point-to-offer-v2-java/');
          var viewGetter = getRecord(Counter, target).then((record) => {
            incrArr.push(buildIncrement(record.objectId))
            if (viewCtn) {
              var ele = document.querySelector('#leancloud-post-views');
              if (ele) {
                ele.innerText = (record.time || 0) + 1;
                viewCtn.style.display = 'inline';
              }
            }
          });
          getterArr.push(viewGetter);
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && increment(Counter, incrArr);
        })
      }
    }

    var app_id = 'WLIvPVVRoeWhnHGUavoLR0F0-9Nh9j0Va'
    var app_key = '19OuG1Cn8ss6vpIXBxYjjff0'
    var server_url = 'https://wlivpvvr.lc-cn-e1-shared.com'

    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': app_id,
            'X-LC-Key': app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };

      addCount(Counter);
    }

    var api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${ app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(resp => resp.json())
        .then(({api_server}) => {
          fetchData('https://' + api_server);
        });
    }
  })();</script><script src="/js/custom.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"article.markdown-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","剑指Offer第二版Java实现&nbsp;"],cursorChar:"🍬",typeSpeed:80,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
      icon: "❡"
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css"></body></html>